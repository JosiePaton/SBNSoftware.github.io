<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>util Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">util Namespace Reference<div class="ingroups"><a class="el" href="../../dd/d0f/group__Utilities.html">General utilities</a> &#124; <a class="el" href="../../d7/da1/group__RangeTool.html">RangeTool</a> &#124; <a class="el" href="../../d4/db7/group__Util.html">Util</a> &#124; <a class="el" href="../../de/d68/group__CMTool.html">CMTool</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for general, non-LArSoft-specific utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:de/df8/namespaceutil_1_1details"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/namespaceutil_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d95/namespaceutil_1_1fhicl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d95/namespaceutil_1_1fhicl.html">fhicl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/dcc/namespaceutil_1_1flags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcc/namespaceutil_1_1flags.html">flags</a></td></tr>
<tr class="memdesc:d9/dcc/namespaceutil_1_1flags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and functions to manage bit masks and flags. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d00/namespaceutil_1_1manip"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d00/namespaceutil_1_1manip.html">manip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d92/namespaceutil_1_1pre__std"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d92/namespaceutil_1_1pre__std.html">pre_std</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d63/namespaceutil_1_1quantities"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/namespaceutil_1_1quantities.html">quantities</a></td></tr>
<tr class="memdesc:d3/d63/namespaceutil_1_1quantities"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of variables with a unit. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d98/namespaceutil_1_1ROOT"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d98/namespaceutil_1_1ROOT.html">ROOT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd0/classutil_1_1Binner.html">Binner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class binning values in a range.  <a href="../../d5/dd0/classutil_1_1Binner.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3b/classutil_1_1FastAndPoorGauss.html">FastAndPoorGauss</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a number <em>u</em> uniformly distributed between 0 and 1 into a Gaussian distributed one <em>z</em>.  <a href="../../d4/d3b/classutil_1_1FastAndPoorGauss.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d04/classutil_1_1GaussianTransformer.html">GaussianTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a standard normal number into one on a different normal distribution.  <a href="../../d8/d04/classutil_1_1GaussianTransformer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd1/classutil_1_1UniformSequence.html">UniformSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the interval [ 0, 1 ] in sequence, cyclically.  <a href="../../d1/dd1/classutil_1_1UniformSequence.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0c/classutil_1_1NonRandomCounter.html">NonRandomCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast random engine which returns sequential numbers.  <a href="../../d6/d0c/classutil_1_1NonRandomCounter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d09/classutil_1_1RandFastGauss.html">RandFastGauss</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution focussing on speed.  <a href="../../da/d09/classutil_1_1RandFastGauss.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d73/classutil_1_1SampledFunction.html">SampledFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputed discrete sampling of a given function.  <a href="../../db/d73/classutil_1_1SampledFunction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9d/structutil_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute for C++20 <code>std::identity</code>.  <a href="../../d5/d9d/structutil_1_1identity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dda/structutil_1_1ArtHandleTrackerInterface.html">ArtHandleTrackerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to facilitate the use of <code>util::ArtHandleTracker</code> specializations.  <a href="../../d9/dda/structutil_1_1ArtHandleTrackerInterface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classutil_1_1ArtHandleTrackerManager.html">ArtHandleTrackerManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages handle trackers for an easy call of <code>removeCachedProduct()</code>.  <a href="../../de/da2/classutil_1_1ArtHandleTrackerManager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6c/classutil_1_1LocalArtHandleTrackerManager.html">LocalArtHandleTrackerManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code><a class="el" href="../../de/da2/classutil_1_1ArtHandleTrackerManager.html" title="Manages handle trackers for an easy call of removeCachedProduct(). ">util::ArtHandleTrackerManager</a></code> in local scope.  <a href="../../dd/d6c/classutil_1_1LocalArtHandleTrackerManager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df1/structutil_1_1addIndent.html">addIndent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream modifier that makes it "indented".  <a href="../../da/df1/structutil_1_1addIndent.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db8/classutil_1_1NormalDistribution.html">NormalDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d82/structutil_1_1collection__value__type.html">collection_value_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait of value contained in the template collection <code>Coll</code>.  <a href="../../d2/d82/structutil_1_1collection__value__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc2/structutil_1_1collection__value__access__type.html">collection_value_access_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait of type obtained by access to element of collection <code>Coll</code>.  <a href="../../d5/dc2/structutil_1_1collection__value__access__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd6/structutil_1_1collection__value__constant__access__type.html">collection_value_constant_access_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait of type obtained by constant access to element of collection <code>Coll</code>.  <a href="../../df/dd6/structutil_1_1collection__value__constant__access__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd4/structutil_1_1collection__reference__type.html">collection_reference_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait of a type that can be used to reference the collection <code>Coll</code>.  <a href="../../d4/dd4/structutil_1_1collection__reference__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df1/structutil_1_1collection__from__reference__type.html">collection_from_reference_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait with the type of collection referenced by <code>collRef</code>.  <a href="../../d3/df1/structutil_1_1collection__from__reference__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d23/classutil_1_1count__iterator.html">count_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator dereferencing to a counter value.  <a href="../../db/d23/classutil_1_1count__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait returning the very same type as in the template argument.  <a href="../../d9/d02/structutil_1_1self__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/structutil_1_1always__false__type.html">always_false_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::false_type</code> with a template argument.  <a href="../../da/d94/structutil_1_1always__false__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd1/structutil_1_1always__true__type.html">always_true_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::true_type</code> with a template argument.  <a href="../../d4/dd1/structutil_1_1always__true__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d02/structutil_1_1find__next__type.html">find_next_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: index of the first occurrence of <code>T</code> among the specified <code>Types</code>, starting from the one with index <code>StartFrom</code>.  <a href="../../d9/d02/structutil_1_1find__next__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d95/structutil_1_1is__any__of.html">is_any_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether <code>T</code> is among the specified <code>Types</code>.  <a href="../../d7/d95/structutil_1_1is__any__of.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d21/structutil_1_1is__instance__of.html">is_instance_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait describing whether <code>T</code> is a template instance of <code>Template</code>.  <a href="../../de/d21/structutil_1_1is__instance__of.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d87/structutil_1_1is__STLarray.html">is_STLarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether the specified type is a STL array.  <a href="../../df/d87/structutil_1_1is__STLarray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d12/structutil_1_1is__character__type.html">is_character_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether type <code>T</code> is a character type.  <a href="../../d0/d12/structutil_1_1is__character__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/def/structutil_1_1is__string__type.html">is_string_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether type <code>T</code> is a character string type.  <a href="../../d6/def/structutil_1_1is__string__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d54/structutil_1_1is__basic__string__type.html">is_basic_string_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether type <code>T</code> is a STL string type.  <a href="../../d1/d54/structutil_1_1is__basic__string__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/structutil_1_1is__basic__string__view__type.html">is_basic_string_view_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether type <code>T</code> is a <code>std::string_view</code> type.  <a href="../../d8/d01/structutil_1_1is__basic__string__view__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d17/structutil_1_1with__const__as.html">with_const_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait with type <code>Base</code>, plus the constantness as in <code>Key</code>.  <a href="../../d5/d17/structutil_1_1with__const__as.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d28/structutil_1_1strip__referenceness__type.html">strip_referenceness_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait with type <code>T</code> stripped of all known reference types.  <a href="../../da/d28/structutil_1_1strip__referenceness__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0b/structutil_1_1reference__addresser.html">reference_addresser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor applying the proper <code><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#ga4b9316020a748b26e0c8e6d40c3900a0" title="Returns the address of the referenced object. ">referenced_address()</a></code> function.  <a href="../../dd/d0b/structutil_1_1reference__addresser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de1/structutil_1_1lvalue__reference__into__wrapper__type.html">lvalue_reference_into_wrapper_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait with type <code>T</code> into <code>std::reference_wrapper</code> if reference.  <a href="../../d4/de1/structutil_1_1lvalue__reference__into__wrapper__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d37/structutil_1_1is__STLarray_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_STLarray&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/structutil_1_1AddressTaker.html">AddressTaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor returning the address in memory of the operand.  <a href="../../de/db1/structutil_1_1AddressTaker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de2/structutil_1_1Dereferencer.html">Dereferencer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor dereferencing the operand.  <a href="../../d3/de2/structutil_1_1Dereferencer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/db3/structutil_1_1KeepByPositionFilterTag.html">KeepByPositionFilterTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for filters.  <a href="../../d9/db3/structutil_1_1KeepByPositionFilterTag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d58/classutil_1_1PositionInVolumeFilter.html">PositionInVolumeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to keep particles with at least part of trajectory in a volume.  <a href="../../d9/d58/classutil_1_1PositionInVolumeFilter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/structutil_1_1span__base.html">span_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base class for <code>span</code>.  <a href="../../de/df8/structutil_1_1span__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d70/structutil_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class with a begin and an end.  <a href="../../d5/d70/structutil_1_1span.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d71/classutil_1_1UBDaqID.html">UBDaqID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d9a/classutil_1_1DatabaseUtil.html">DatabaseUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de6/classutil_1_1GeometryUtilities.html">GeometryUtilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d04/classutil_1_1GridContainerIndicesBase1D.html">GridContainerIndicesBase1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index manager for a container of data arranged on a &gt;=1-dim grid.  <a href="../../d7/d04/classutil_1_1GridContainerIndicesBase1D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classutil_1_1GridContainerIndicesBase2D.html">GridContainerIndicesBase2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index manager for a container of data arranged on a &gt;=2-dim grid.  <a href="../../d9/d70/classutil_1_1GridContainerIndicesBase2D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/da6/classutil_1_1GridContainerIndicesBase3D.html">GridContainerIndicesBase3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index manager for a container of data arranged on a &gt;=3-dim grid.  <a href="../../d6/da6/classutil_1_1GridContainerIndicesBase3D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6d/classutil_1_1GridContainerBase1D.html">GridContainerBase1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a container of data arranged on a 1D-grid.  <a href="../../df/d6d/classutil_1_1GridContainerBase1D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classutil_1_1GridContainerBase2D.html">GridContainerBase2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a container of data arranged on a 2D-grid.  <a href="../../d6/d8e/classutil_1_1GridContainerBase2D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d07/classutil_1_1GridContainerBase3D.html">GridContainerBase3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a container of data arranged on a 3D-grid.  <a href="../../d9/d07/classutil_1_1GridContainerBase3D.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d53/classutil_1_1LArFFT.html">LArFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d15/classutil_1_1LArFFTW.html">LArFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dcd/classutil_1_1LArFFTWPlan.html">LArFFTWPlan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1d/classutil_1_1PxHitConverter.html">PxHitConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/def/classutil_1_1PxPoint.html">PxPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8a/classutil_1_1PxHit.html">PxHit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d65/classutil_1_1PxLine.html">PxLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de7/classutil_1_1UniqueRangeSet.html">UniqueRangeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set of <a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">util::Range</a>, which does not allow any overlap in contained element. std::set&lt;Range&gt; w/ modified insert/emplace function. Original std::set does not allow <br/>
modification of element. I assume what we're interested in is "find if the range already \n
exists, and merge if it exists". The insert function does that by recursively looking up <br/>
overlapping elements w.r.t. input argument of insert function. <br/>
 <a href="../../d1/de7/classutil_1_1UniqueRangeSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d18/classutil_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a "Range" w/ notion of ordering. A range is defined by a pair of "start" and "end" values. This is stored in std::pair <br/>
attribute <a class="el" href="../../df/d18/classutil_1_1Range.html#ab5ba3a946853f9a30aacf2eb9fdf1bc1" title="Protected to avoid user&#39;s illegal modification on first/second (sorry users!) ">util::Range::_window</a>. This attribute is protected so that the start/end cannot <br/>
be changed w/o a check that start is always less than end. Note the specialization <br/>
requires a template class T to have less operator implemented. <br/>
 <a href="../../df/d18/classutil_1_1Range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/structutil_1_1RangeForWrapperTag.html">RangeForWrapperTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag marking the use of RangeForWrapperBox.  <a href="../../d6/d72/structutil_1_1RangeForWrapperTag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/classutil_1_1SignalShaper.html">SignalShaper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd1/classutil_1_1SignalShaping.html">SignalShaping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/structutil_1_1TensorIndicesBasicTypes.html">TensorIndicesBasicTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types for <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html" title="Converts a tensor element specification into a linear index. ">TensorIndices</a> class.  <a href="../../d8/deb/structutil_1_1TensorIndicesBasicTypes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a tensor element specification into a linear index.  <a href="../../dc/de3/classutil_1_1TensorIndices.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de7/classutil_1_1TensorIndices_3_011U_01_4.html">TensorIndices&lt; 1U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d03/structutil_1_1count__type__in__tuple.html">count_type_in_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds whether the <code>Target</code> type is element of the specified <code>std::tuple</code>.  <a href="../../d0/d03/structutil_1_1count__type__in__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html">extract_to_tuple_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type <code>TargetClass&lt;U...&gt;</code> from a <code>SrcTuple&lt;T...&gt;</code>.  <a href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d32/structutil_1_1index__of__extracted__type.html">index_of_extracted_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element in <code>Tuple</code> with the specified type.  <a href="../../d9/d32/structutil_1_1index__of__extracted__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d2a/structutil_1_1has__extracted__type.html">has_extracted_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding whether an element in <code>Tuple</code> type contains <code>Target</code>.  <a href="../../dc/d2a/structutil_1_1has__extracted__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html">has_duplicate_extracted_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits holding whether elements of <code>Tuple</code> have duplicate types.  <a href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html">count_extracted_types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements of a tuple-like type containing a <code>Target</code> type.  <a href="../../d8/dd0/structutil_1_1count__extracted__types.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d86/structutil_1_1TaggedType.html">TaggedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type with a specified tag.  <a href="../../dd/d86/structutil_1_1TaggedType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d07/structutil_1_1add__tag.html">add_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddd/structutil_1_1remove__tag.html">remove_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the type contained in a <code><a class="el" href="../../dd/d86/structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code> (or the type itself).  <a href="../../dd/ddd/structutil_1_1remove__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8b/structutil_1_1remove__tag_3_01TaggedType_3_01T_00_01Tag_01_4_01_4.html">remove_tag&lt; TaggedType&lt; T, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d11/structutil_1_1TagN.html">TagN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class parametrized by a sequence of numbers.  <a href="../../d8/d11/structutil_1_1TagN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the tag from a type.  <a href="../../df/d36/structutil_1_1TagExtractor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dec/structutil_1_1count__type__in__tuple_3_01Target_00_01std_1_1tuple_3_01T_8_8_8_4_01_4.html">count_type_in_tuple&lt; Target, std::tuple&lt; T...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de1/classutil_1_1UtilException.html">UtilException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d57/classutil_1_1LArPropTest.html">LArPropTest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db3/structutil_1_1MappedContainerBase.html">MappedContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template base class for <code><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html" title="A meta-container providing transparent mapping on top of another. ">MappedContainer</a></code>.  <a href="../../d4/db3/structutil_1_1MappedContainerBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html">MappedContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A meta-container providing transparent mapping on top of another.  <a href="../../d4/d4e/classutil_1_1MappedContainer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3f/classutil_1_1MultipleChoiceSelectionBase.html">MultipleChoiceSelectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of <code><a class="el" href="../../d9/d6f/classutil_1_1MultipleChoiceSelection.html" title="Helper to select one among multiple choices via strings. ">util::MultipleChoiceSelection</a></code> with basics independent of the option type.  <a href="../../dc/d3f/classutil_1_1MultipleChoiceSelectionBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6f/classutil_1_1MultipleChoiceSelection.html">MultipleChoiceSelection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to select one among multiple choices via strings.  <a href="../../d9/d6f/classutil_1_1MultipleChoiceSelection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da3/classutil_1_1LazyVector.html">LazyVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contiguous data container expanded on write.  <a href="../../d2/da3/classutil_1_1LazyVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d57/classutil_1_1SumSecondFunction.html">SumSecondFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d77/classutil_1_1EventChangeTracker__t.html">EventChangeTracker_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the presence of a new event.  <a href="../../da/d77/classutil_1_1EventChangeTracker__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dde/classutil_1_1DataProductChangeTracker__t.html">DataProductChangeTracker_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the presence of a new event or data product.  <a href="../../d1/dde/classutil_1_1DataProductChangeTracker__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d68/classutil_1_1PlaneDataChangeTracker__t.html">PlaneDataChangeTracker_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the presence of a new event, data product or wire plane.  <a href="../../dd/d68/classutil_1_1PlaneDataChangeTracker__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/classutil_1_1GaussianEliminationAlg.html">GaussianEliminationAlg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/df9/classutil_1_1FileSpec.html">FileSpec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dbc/classutil_1_1FileCatalogMetadataSBN.html">FileCatalogMetadataSBN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df9/classutil_1_1MetadataSBN.html">MetadataSBN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d92/classutil_1_1SignalShapingServiceSBND.html">SignalShapingServiceSBND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ada5647082a33c085c6cd4556712066bb"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:ada5647082a33c085c6cd4556712066bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ada5647082a33c085c6cd4556712066bb">ArtHandleData_t</a> = typename Handle::element_type::value_type</td></tr>
<tr class="memdesc:ada5647082a33c085c6cd4556712066bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of data in a <em>art</em> handle to vector data product.  <a href="#ada5647082a33c085c6cd4556712066bb">More...</a><br/></td></tr>
<tr class="separator:ada5647082a33c085c6cd4556712066bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1de93ae9853deac245708c89676409c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1de93ae9853deac245708c89676409c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af1de93ae9853deac245708c89676409c">DataProductPointerMap_t</a> = <a class="el" href="../../de/df8/namespaceutil_1_1details.html#ac66982acdadafd712181850d760caa93">details::DataProductPointerMap_t</a>&lt; T &gt;</td></tr>
<tr class="memdesc:af1de93ae9853deac245708c89676409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map for data product pointers to <em>art</em> pointers.  <a href="#af1de93ae9853deac245708c89676409c">More...</a><br/></td></tr>
<tr class="separator:af1de93ae9853deac245708c89676409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4df4a53b59d80b5d8b688bbb2fd6bd0"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:gaa4df4a53b59d80b5d8b688bbb2fd6bd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#gaa4df4a53b59d80b5d8b688bbb2fd6bd0">collection_value_t</a> = typename <a class="el" href="../../d2/d82/structutil_1_1collection__value__type.html">collection_value_type</a>&lt; Coll &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gaa4df4a53b59d80b5d8b688bbb2fd6bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type contained in the collection <code>Coll</code>.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#gaa4df4a53b59d80b5d8b688bbb2fd6bd0">More...</a><br/></td></tr>
<tr class="separator:gaa4df4a53b59d80b5d8b688bbb2fd6bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6860a285ad0b29c6a2b0b5363dbaed0"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:gab6860a285ad0b29c6a2b0b5363dbaed0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#gab6860a285ad0b29c6a2b0b5363dbaed0">collection_value_access_t</a> = typename <a class="el" href="../../d5/dc2/structutil_1_1collection__value__access__type.html">collection_value_access_type</a>&lt; Coll &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gab6860a285ad0b29c6a2b0b5363dbaed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type obtained by constant access to element of collection <code>Coll</code>.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#gab6860a285ad0b29c6a2b0b5363dbaed0">More...</a><br/></td></tr>
<tr class="separator:gab6860a285ad0b29c6a2b0b5363dbaed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1f034abc85cd7040b41bfde1ded7fd"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:ga1f1f034abc85cd7040b41bfde1ded7fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#ga1f1f034abc85cd7040b41bfde1ded7fd">collection_value_constant_access_t</a> = typename <a class="el" href="../../df/dd6/structutil_1_1collection__value__constant__access__type.html">collection_value_constant_access_type</a>&lt; Coll &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga1f1f034abc85cd7040b41bfde1ded7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type obtained by constant access to element of collection <code>Coll</code>.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#ga1f1f034abc85cd7040b41bfde1ded7fd">More...</a><br/></td></tr>
<tr class="separator:ga1f1f034abc85cd7040b41bfde1ded7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1c763b1a3ce738e20d3e6e1273f307"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:gade1c763b1a3ce738e20d3e6e1273f307"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#gade1c763b1a3ce738e20d3e6e1273f307">collection_reference_t</a> = typename <a class="el" href="../../d4/dd4/structutil_1_1collection__reference__type.html">collection_reference_type</a>&lt; Coll &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gade1c763b1a3ce738e20d3e6e1273f307"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type contained in <code><a class="el" href="../../d4/dd4/structutil_1_1collection__reference__type.html" title="Trait of a type that can be used to reference the collection Coll. ">util::collection_reference_type</a></code> trait.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#gade1c763b1a3ce738e20d3e6e1273f307">More...</a><br/></td></tr>
<tr class="separator:gade1c763b1a3ce738e20d3e6e1273f307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6190c6f1e8ecf45a8fc6fa0a60de7a5b"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga6190c6f1e8ecf45a8fc6fa0a60de7a5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#ga6190c6f1e8ecf45a8fc6fa0a60de7a5b">collection_from_reference_t</a> = typename <a class="el" href="../../d3/df1/structutil_1_1collection__from__reference__type.html">collection_from_reference_type</a>&lt; Cont &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga6190c6f1e8ecf45a8fc6fa0a60de7a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type contained in <code><a class="el" href="../../d3/df1/structutil_1_1collection__from__reference__type.html" title="Trait with the type of collection referenced by collRef. ">util::collection_from_reference_type</a></code> trait.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#ga6190c6f1e8ecf45a8fc6fa0a60de7a5b">More...</a><br/></td></tr>
<tr class="separator:ga6190c6f1e8ecf45a8fc6fa0a60de7a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92e74901a6fa461ce0ccbd97c445928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad92e74901a6fa461ce0ccbd97c445928"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gad92e74901a6fa461ce0ccbd97c445928">self_t</a> = typename <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>&lt; T &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gad92e74901a6fa461ce0ccbd97c445928"><td class="mdescLeft">&#160;</td><td class="mdescRight">The very same type as in the template argument.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#gad92e74901a6fa461ce0ccbd97c445928">More...</a><br/></td></tr>
<tr class="separator:gad92e74901a6fa461ce0ccbd97c445928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ec377e9ab85c27b7d6cb7571b97c98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gae9ec377e9ab85c27b7d6cb7571b97c98">type_traits</a> = std::bool_constant&lt; Value &gt;</td></tr>
<tr class="separator:gae9ec377e9ab85c27b7d6cb7571b97c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4f01d734224cf596f7e619a1b7d093b3">is_not_same</a> = std::negation&lt; std::is_same&lt; A, B &gt;&gt;</td></tr>
<tr class="memdesc:ga4f01d734224cf596f7e619a1b7d093b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negation of <code>std::is_same</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga4f01d734224cf596f7e619a1b7d093b3">More...</a><br/></td></tr>
<tr class="separator:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08165b3442ddda786a178ce2823ef668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga08165b3442ddda786a178ce2823ef668"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668">find_type</a> = <a class="el" href="../../d9/d02/structutil_1_1find__next__type.html">find_next_type</a>&lt; T, 0U, Types...&gt;</td></tr>
<tr class="memdesc:ga08165b3442ddda786a178ce2823ef668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: index of the first occurrence of <code>T</code> among the specified <code>Types</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668">More...</a><br/></td></tr>
<tr class="separator:ga08165b3442ddda786a178ce2823ef668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9947403b20eeda8700f1c8dcc075a2f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9947403b20eeda8700f1c8dcc075a2f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga9947403b20eeda8700f1c8dcc075a2f4">is_reference_wrapper</a> = <a class="el" href="../../de/d21/structutil_1_1is__instance__of.html">is_instance_of</a>&lt; std::reference_wrapper, T &gt;</td></tr>
<tr class="memdesc:ga9947403b20eeda8700f1c8dcc075a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether the specified type is a <code>std::reference_wrapper</code>.  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga9947403b20eeda8700f1c8dcc075a2f4">More...</a><br/></td></tr>
<tr class="separator:ga9947403b20eeda8700f1c8dcc075a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b435defed53818920121ade83c2d8fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5b435defed53818920121ade83c2d8fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga5b435defed53818920121ade83c2d8fd">is_unique_ptr</a> = <a class="el" href="../../de/d21/structutil_1_1is__instance__of.html">is_instance_of</a>&lt; std::unique_ptr, T &gt;</td></tr>
<tr class="memdesc:ga5b435defed53818920121ade83c2d8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether the specified type is a <code>std::unique_ptr</code>.  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga5b435defed53818920121ade83c2d8fd">More...</a><br/></td></tr>
<tr class="separator:ga5b435defed53818920121ade83c2d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57ba40c761bbf9be1812068ee9322a4"><td class="memTemplParams" colspan="2">template&lt;typename Base , typename Key &gt; </td></tr>
<tr class="memitem:gad57ba40c761bbf9be1812068ee9322a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gad57ba40c761bbf9be1812068ee9322a4">with_const_as_t</a> = typename <a class="el" href="../../d5/d17/structutil_1_1with__const__as.html">with_const_as</a>&lt; Base, Key &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gad57ba40c761bbf9be1812068ee9322a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type <code>Base</code>, plus the constantness as in <code>Key</code>.  <a href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gad57ba40c761bbf9be1812068ee9322a4">More...</a><br/></td></tr>
<tr class="separator:gad57ba40c761bbf9be1812068ee9322a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac599ddc82f0d9092351413029b8ec28f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac599ddc82f0d9092351413029b8ec28f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gac599ddc82f0d9092351413029b8ec28f">strip_referenceness_t</a> = typename <a class="el" href="../../da/d28/structutil_1_1strip__referenceness__type.html">strip_referenceness_type</a>&lt; T &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gac599ddc82f0d9092351413029b8ec28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type <code>T</code> stripped of all known reference types.  <a href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gac599ddc82f0d9092351413029b8ec28f">More...</a><br/></td></tr>
<tr class="separator:gac599ddc82f0d9092351413029b8ec28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db99d2ed15643dcffc3a132e8df6ed4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1db99d2ed15643dcffc3a132e8df6ed4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#ga1db99d2ed15643dcffc3a132e8df6ed4">lvalue_reference_into_wrapper_t</a> = typename <a class="el" href="../../d4/de1/structutil_1_1lvalue__reference__into__wrapper__type.html">lvalue_reference_into_wrapper_type</a>&lt; T &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga1db99d2ed15643dcffc3a132e8df6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type <code>T</code> stripped of all known reference types.  <a href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#ga1db99d2ed15643dcffc3a132e8df6ed4">More...</a><br/></td></tr>
<tr class="separator:ga1db99d2ed15643dcffc3a132e8df6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1e47d8bc8d524a05f14f786e25af2e"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">UBLArSoftCh_t</a></td></tr>
<tr class="separator:a5e1e47d8bc8d524a05f14f786e25af2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097740c1c11a734156bf86e85b210e1b"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="../../db/d71/classutil_1_1UBDaqID.html">UBDaqID</a>, <br class="typebreak"/>
<a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">UBLArSoftCh_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a097740c1c11a734156bf86e85b210e1b">UBChannelMap_t</a></td></tr>
<tr class="separator:a097740c1c11a734156bf86e85b210e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212740e3c13bae3ed850ef0310bbb62e"><td class="memItemLeft" align="right" valign="top">typedef std::map<br class="typebreak"/>
&lt; <a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">UBLArSoftCh_t</a>, <a class="el" href="../../db/d71/classutil_1_1UBDaqID.html">UBDaqID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a212740e3c13bae3ed850ef0310bbb62e">UBChannelReverseMap_t</a></td></tr>
<tr class="separator:a212740e3c13bae3ed850ef0310bbb62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab557de18370e4a773f005e37285b439"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aab557de18370e4a773f005e37285b439">GridContainer2DIndices</a> = <a class="el" href="../../d9/d70/classutil_1_1GridContainerIndicesBase2D.html">GridContainerIndicesBase2D</a>&lt;&gt;</td></tr>
<tr class="memdesc:aab557de18370e4a773f005e37285b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index manager for a container of data arranged on a 2D grid.  <a href="#aab557de18370e4a773f005e37285b439">More...</a><br/></td></tr>
<tr class="separator:aab557de18370e4a773f005e37285b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac25b5d7b5d55ecd725a92e86750744"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#abac25b5d7b5d55ecd725a92e86750744">GridContainer3DIndices</a> = <a class="el" href="../../d6/da6/classutil_1_1GridContainerIndicesBase3D.html">GridContainerIndicesBase3D</a>&lt;&gt;</td></tr>
<tr class="memdesc:abac25b5d7b5d55ecd725a92e86750744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index manager for a container of data arranged on a 3D grid.  <a href="#abac25b5d7b5d55ecd725a92e86750744">More...</a><br/></td></tr>
<tr class="separator:abac25b5d7b5d55ecd725a92e86750744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379847876f76e55ce72f99edcc9d7cee"><td class="memTemplParams" colspan="2">template&lt;typename DATUM &gt; </td></tr>
<tr class="memitem:a379847876f76e55ce72f99edcc9d7cee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a379847876f76e55ce72f99edcc9d7cee">GridContainer2D</a> = <a class="el" href="../../d6/d8e/classutil_1_1GridContainerBase2D.html">GridContainerBase2D</a>&lt; DATUM, <a class="el" href="../../d6/d72/namespaceutil.html#aab557de18370e4a773f005e37285b439">GridContainer2DIndices</a> &gt;</td></tr>
<tr class="memdesc:a379847876f76e55ce72f99edcc9d7cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container allowing 2D indexing.  <a href="#a379847876f76e55ce72f99edcc9d7cee">More...</a><br/></td></tr>
<tr class="separator:a379847876f76e55ce72f99edcc9d7cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503302a79d6be4def6577e2c86bc11be"><td class="memTemplParams" colspan="2">template&lt;typename DATUM &gt; </td></tr>
<tr class="memitem:a503302a79d6be4def6577e2c86bc11be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a503302a79d6be4def6577e2c86bc11be">GridContainer3D</a> = <a class="el" href="../../d9/d07/classutil_1_1GridContainerBase3D.html">GridContainerBase3D</a>&lt; DATUM, <a class="el" href="../../d6/d72/namespaceutil.html#abac25b5d7b5d55ecd725a92e86750744">GridContainer3DIndices</a> &gt;</td></tr>
<tr class="memdesc:a503302a79d6be4def6577e2c86bc11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container allowing 3D indexing.  <a href="#a503302a79d6be4def6577e2c86bc11be">More...</a><br/></td></tr>
<tr class="separator:a503302a79d6be4def6577e2c86bc11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4166e03c037e92995c75f98c98dc488d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4166e03c037e92995c75f98c98dc488d">MatrixIndices</a> = <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt; 2U &gt;</td></tr>
<tr class="memdesc:a4166e03c037e92995c75f98c98dc488d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for indexing a 2D-tensor (matrix)  <a href="#a4166e03c037e92995c75f98c98dc488d">More...</a><br/></td></tr>
<tr class="separator:a4166e03c037e92995c75f98c98dc488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd76c6a44bd9dab837bcf7681cc2de0b"><td class="memTemplParams" colspan="2">template&lt;typename SrcTuple , template&lt; typename T, typename...&gt; class Extractor, template&lt; typename...&gt; class TargetClass = std::tuple&gt; </td></tr>
<tr class="memitem:gadd76c6a44bd9dab837bcf7681cc2de0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gadd76c6a44bd9dab837bcf7681cc2de0b">extract_to_tuple_type_t</a> = typename <a class="el" href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html">extract_to_tuple_type</a>&lt; SrcTuple, Extractor, TargetClass &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gadd76c6a44bd9dab837bcf7681cc2de0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code><a class="el" href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html" title="Returns type TargetClass&lt;U...&gt; from a SrcTuple&lt;T...&gt;. ">extract_to_tuple_type</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gadd76c6a44bd9dab837bcf7681cc2de0b">More...</a><br/></td></tr>
<tr class="separator:gadd76c6a44bd9dab837bcf7681cc2de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8233ce252707b0a9a30ce91232a1e6"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , template&lt; typename...&gt; class TargetClass = std::tuple&gt; </td></tr>
<tr class="memitem:ga1e8233ce252707b0a9a30ce91232a1e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga1e8233ce252707b0a9a30ce91232a1e6">to_tuple</a> = <a class="el" href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html">extract_to_tuple_type</a>&lt; Tuple, <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>, TargetClass &gt;</td></tr>
<tr class="separator:ga1e8233ce252707b0a9a30ce91232a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac372bfffacc4e0446d6ff32c844394b7"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , template&lt; typename...&gt; class TargetClass = std::tuple&gt; </td></tr>
<tr class="memitem:gac372bfffacc4e0446d6ff32c844394b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gac372bfffacc4e0446d6ff32c844394b7">to_tuple_t</a> = typename <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga1e8233ce252707b0a9a30ce91232a1e6">to_tuple</a>&lt; Tuple, TargetClass &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gac372bfffacc4e0446d6ff32c844394b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code>to_tuple</code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gac372bfffacc4e0446d6ff32c844394b7">More...</a><br/></td></tr>
<tr class="separator:gac372bfffacc4e0446d6ff32c844394b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad61220544ced8dd6c9295a8a5c8fb9"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga5ad61220544ced8dd6c9295a8a5c8fb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga5ad61220544ced8dd6c9295a8a5c8fb9">index_of_type</a> = <a class="el" href="../../d9/d32/structutil_1_1index__of__extracted__type.html">index_of_extracted_type</a>&lt; <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>, Target, Tuple &gt;</td></tr>
<tr class="separator:ga5ad61220544ced8dd6c9295a8a5c8fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ee1697c0663d8b142aa4e3463ed67b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga10ee1697c0663d8b142aa4e3463ed67b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga10ee1697c0663d8b142aa4e3463ed67b">type_with_extracted_type</a> = std::tuple_element&lt; <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga25797fa292a1c406715a11f5935d6571">index_of_extracted_type_v</a>&lt; Extractor, Target, Tuple &gt;, Tuple &gt;</td></tr>
<tr class="memdesc:ga10ee1697c0663d8b142aa4e3463ed67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element type in <code>Tuple</code> with the specified type.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga10ee1697c0663d8b142aa4e3463ed67b">More...</a><br/></td></tr>
<tr class="separator:ga10ee1697c0663d8b142aa4e3463ed67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736649ad4081338a9b13ca4c1c5ad79e"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga736649ad4081338a9b13ca4c1c5ad79e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga736649ad4081338a9b13ca4c1c5ad79e">type_with_extracted_type_t</a> = typename <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga10ee1697c0663d8b142aa4e3463ed67b">type_with_extracted_type</a>&lt; Extractor, Target, Tuple &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga736649ad4081338a9b13ca4c1c5ad79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>type_with_extracted_type</code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga736649ad4081338a9b13ca4c1c5ad79e">More...</a><br/></td></tr>
<tr class="separator:ga736649ad4081338a9b13ca4c1c5ad79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5212f210676e5a04fc33b4883d15a4c"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:gad5212f210676e5a04fc33b4883d15a4c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gad5212f210676e5a04fc33b4883d15a4c">has_type</a> = <a class="el" href="../../dc/d2a/structutil_1_1has__extracted__type.html">has_extracted_type</a>&lt; <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>, Target, Tuple &gt;</td></tr>
<tr class="separator:gad5212f210676e5a04fc33b4883d15a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab049559e46e277472c3bb4455994fe8e"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:gab049559e46e277472c3bb4455994fe8e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gab049559e46e277472c3bb4455994fe8e">has_duplicate_types</a> = <a class="el" href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html">has_duplicate_extracted_types</a>&lt; <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>, Tuple &gt;</td></tr>
<tr class="separator:gab049559e46e277472c3bb4455994fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e61d6541b80ca8c4484761a639fd5f"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga94e61d6541b80ca8c4484761a639fd5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga94e61d6541b80ca8c4484761a639fd5f">count_types</a> = <a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html">count_extracted_types</a>&lt; <a class="el" href="../../d9/d02/structutil_1_1self__type.html">self_type</a>, Target, Tuple &gt;</td></tr>
<tr class="separator:ga94e61d6541b80ca8c4484761a639fd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tag &gt; </td></tr>
<tr class="memitem:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">add_tag_t</a> = typename <a class="el" href="../../d1/d07/structutil_1_1add__tag.html">add_tag</a>&lt; T, Tag &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="separator:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b135825beaff13bf4abacec82d618b5"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga5b135825beaff13bf4abacec82d618b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga5b135825beaff13bf4abacec82d618b5">remove_tag_t</a> = typename <a class="el" href="../../dd/ddd/structutil_1_1remove__tag.html">remove_tag</a>&lt; Tagged &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga5b135825beaff13bf4abacec82d618b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type contained in <code><a class="el" href="../../dd/ddd/structutil_1_1remove__tag.html" title="Trait holding the type contained in a TaggedType (or the type itself). ">remove_tag</a></code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga5b135825beaff13bf4abacec82d618b5">More...</a><br/></td></tr>
<tr class="separator:ga5b135825beaff13bf4abacec82d618b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf2c3171daa4919784330b46b09e098"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:gacbf2c3171daa4919784330b46b09e098"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gacbf2c3171daa4919784330b46b09e098">tag_of</a> = <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>&lt; Tagged &gt;</td></tr>
<tr class="memdesc:gacbf2c3171daa4919784330b46b09e098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the tag of <code>Tagged</code> as <code>type</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gacbf2c3171daa4919784330b46b09e098">More...</a><br/></td></tr>
<tr class="separator:gacbf2c3171daa4919784330b46b09e098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaf44ec834b967f8d3635a635cacc6ec80">tag_of_t</a> = typename <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gacbf2c3171daa4919784330b46b09e098">tag_of</a>&lt; Tagged &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gaf44ec834b967f8d3635a635cacc6ec80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code>tag_of</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gaf44ec834b967f8d3635a635cacc6ec80">More...</a><br/></td></tr>
<tr class="separator:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memTemplParams" colspan="2">template&lt;typename SrcTuple &gt; </td></tr>
<tr class="memitem:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga2c8dd8d85383c9a067a0ac3674f1c50e">extract_tags</a> = <a class="el" href="../../dc/d0b/structutil_1_1extract__to__tuple__type.html">extract_to_tuple_type</a>&lt; SrcTuple, <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a> &gt;</td></tr>
<tr class="memdesc:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tuple with all the tags from <code>SrcTuple</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga2c8dd8d85383c9a067a0ac3674f1c50e">More...</a><br/></td></tr>
<tr class="separator:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memTemplParams" colspan="2">template&lt;typename SrcTuple &gt; </td></tr>
<tr class="memitem:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gabc0685c0b0eafbf7aedb59f3e9eef67c">extract_tags_t</a> = typename <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga2c8dd8d85383c9a067a0ac3674f1c50e">extract_tags</a>&lt; SrcTuple &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code>extract_tags</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gabc0685c0b0eafbf7aedb59f3e9eef67c">More...</a><br/></td></tr>
<tr class="separator:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388">index_of_tag</a> = <a class="el" href="../../d9/d32/structutil_1_1index__of__extracted__type.html">index_of_extracted_type</a>&lt; <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the index of the element of <code>Tuple</code> with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388">More...</a><br/></td></tr>
<tr class="separator:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09c7641292f908026f622a4b887845c"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaf09c7641292f908026f622a4b887845c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">type_with_tag</a> = <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga10ee1697c0663d8b142aa4e3463ed67b">type_with_extracted_type</a>&lt; <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:gaf09c7641292f908026f622a4b887845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the type of the element of <code>Tuple</code> with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">More...</a><br/></td></tr>
<tr class="separator:gaf09c7641292f908026f622a4b887845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdf38097f72e12a2b25660704d84522"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaefdf38097f72e12a2b25660704d84522"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaefdf38097f72e12a2b25660704d84522">type_with_tag_t</a> = typename <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">type_with_tag</a>&lt; Tag, Tuple &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gaefdf38097f72e12a2b25660704d84522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>type_with_tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gaefdf38097f72e12a2b25660704d84522">More...</a><br/></td></tr>
<tr class="separator:gaefdf38097f72e12a2b25660704d84522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba4dd10684e5ec60541764d14db537f"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaeba4dd10684e5ec60541764d14db537f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f">has_tag</a> = <a class="el" href="../../dc/d2a/structutil_1_1has__extracted__type.html">has_extracted_type</a>&lt; <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:gaeba4dd10684e5ec60541764d14db537f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait informing if there are elements in <code>Tuple</code> with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f">More...</a><br/></td></tr>
<tr class="separator:gaeba4dd10684e5ec60541764d14db537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324">count_tags</a> = <a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html">count_extracted_types</a>&lt; <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:ga8f12cb0558ab8f41cd640961b3e53324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait counting the elements in <code>Tuple</code> with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324">More...</a><br/></td></tr>
<tr class="separator:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585">has_duplicate_tags</a> = <a class="el" href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html">has_duplicate_extracted_types</a>&lt; <a class="el" href="../../df/d36/structutil_1_1TagExtractor.html">TagExtractor</a>, Tuple &gt;</td></tr>
<tr class="memdesc:ga0cfc7db316e0d8085e278be1ddd56585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait reporting if multiple elements in <code>Tuple</code> have the same tag.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585">More...</a><br/></td></tr>
<tr class="separator:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a958d846096090f6b9a8ffc0c1756b5ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a958d846096090f6b9a8ffc0c1756b5ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a958d846096090f6b9a8ffc0c1756b5ef">operator&lt;&lt;</a> (std::ostream &amp;, <a class="el" href="../../d5/dd0/classutil_1_1Binner.html">Binner</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="separator:a958d846096090f6b9a8ffc0c1756b5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dfade21c61885697d926440f77118a"><td class="memTemplParams" colspan="2">template&lt;typename Event &gt; </td></tr>
<tr class="memitem:a34dfade21c61885697d926440f77118a"><td class="memTemplItemLeft" align="right" valign="top">art::InputTag&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">inputTagOf</a> (Event const &amp;event, art::ProductID const &amp;productID)</td></tr>
<tr class="memdesc:a34dfade21c61885697d926440f77118a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the input tag of the producer of <code>productID</code>.  <a href="#a34dfade21c61885697d926440f77118a">More...</a><br/></td></tr>
<tr class="separator:a34dfade21c61885697d926440f77118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b3baf272be38961453b208e3f8cd44"><td class="memTemplParams" colspan="2">template&lt;typename Event , typename Handle &gt; </td></tr>
<tr class="memitem:a48b3baf272be38961453b208e3f8cd44"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_void_v&lt; std::void_t<br class="typebreak"/>
&lt; typename Handle::HandleTag &gt;<br class="typebreak"/>
 &gt;, art::InputTag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a48b3baf272be38961453b208e3f8cd44">inputTagOf</a> (Event const &amp;event, Handle const &amp;handle)</td></tr>
<tr class="memdesc:a48b3baf272be38961453b208e3f8cd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the input tag of the product with the specified <code>handle</code>.  <a href="#a48b3baf272be38961453b208e3f8cd44">More...</a><br/></td></tr>
<tr class="separator:a48b3baf272be38961453b208e3f8cd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1164888fe44fc72dd6690011fbf1fc1"><td class="memTemplParams" colspan="2">template&lt;typename Event , typename T &gt; </td></tr>
<tr class="memitem:ae1164888fe44fc72dd6690011fbf1fc1"><td class="memTemplItemLeft" align="right" valign="top">art::InputTag&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae1164888fe44fc72dd6690011fbf1fc1">inputTagOf</a> (Event const &amp;event, art::Ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ae1164888fe44fc72dd6690011fbf1fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the input tag of the product <code>ptr</code> points to.  <a href="#ae1164888fe44fc72dd6690011fbf1fc1">More...</a><br/></td></tr>
<tr class="separator:ae1164888fe44fc72dd6690011fbf1fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa5684872204728adc89bc973f65b91"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename KeyOp , typename CmpOp , typename RefOp , typename KeySortOp &gt; </td></tr>
<tr class="memitem:adfa5684872204728adc89bc973f65b91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#adfa5684872204728adc89bc973f65b91">clusterBy</a> (Coll const &amp;objs, KeyOp keyFunc, CmpOp sameGroup, RefOp objRef, KeySortOp keySort)</td></tr>
<tr class="memdesc:adfa5684872204728adc89bc973f65b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a simple clustering.  <a href="#adfa5684872204728adc89bc973f65b91">More...</a><br/></td></tr>
<tr class="separator:adfa5684872204728adc89bc973f65b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fd61a6b4d7f9f81c6a42a296d2b81b"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename KeyOp , typename CmpOp , typename KeySortOp &gt; </td></tr>
<tr class="memitem:a99fd61a6b4d7f9f81c6a42a296d2b81b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a99fd61a6b4d7f9f81c6a42a296d2b81b">clusterBy</a> (Coll const &amp;objs, KeyOp keyFunc, CmpOp sameGroup, KeySortOp keySort)</td></tr>
<tr class="memdesc:a99fd61a6b4d7f9f81c6a42a296d2b81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <code><a class="el" href="../../d6/d72/namespaceutil.html#adfa5684872204728adc89bc973f65b91" title="Performs a simple clustering. ">clusterBy()</a></code> storing a copy of each object as "reference".  <a href="#a99fd61a6b4d7f9f81c6a42a296d2b81b">More...</a><br/></td></tr>
<tr class="separator:a99fd61a6b4d7f9f81c6a42a296d2b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ad2af7ab2588eaea858cddcf72614"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter , typename Key , typename Sorter  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a078ad2af7ab2588eaea858cddcf72614"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a078ad2af7ab2588eaea858cddcf72614">sortBy</a> (BIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>, EIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>, Key key, Sorter sorter={})</td></tr>
<tr class="memdesc:a078ad2af7ab2588eaea858cddcf72614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vectors to pointers to <code>coll</code> elements, sorted by <code>key</code>.  <a href="#a078ad2af7ab2588eaea858cddcf72614">More...</a><br/></td></tr>
<tr class="separator:a078ad2af7ab2588eaea858cddcf72614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2a442802ada37b9974cb605a4b34a"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename Key , typename Sorter  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:af4a2a442802ada37b9974cb605a4b34a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af4a2a442802ada37b9974cb605a4b34a">sortCollBy</a> (Coll &amp;coll, Key key, Sorter sorter={})</td></tr>
<tr class="memdesc:af4a2a442802ada37b9974cb605a4b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vectors to pointers to <code>coll</code> elements, sorted by <code>key</code>.  <a href="#af4a2a442802ada37b9974cb605a4b34a">More...</a><br/></td></tr>
<tr class="separator:af4a2a442802ada37b9974cb605a4b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648066c28180a7cdfac53270a2b4a80d"><td class="memTemplParams" colspan="2">template&lt;typename Handle &gt; </td></tr>
<tr class="memitem:a648066c28180a7cdfac53270a2b4a80d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d72/namespaceutil.html#af1de93ae9853deac245708c89676409c">DataProductPointerMap_t</a><br class="typebreak"/>
&lt; <a class="el" href="../../d6/d72/namespaceutil.html#ada5647082a33c085c6cd4556712066bb">ArtHandleData_t</a>&lt; Handle &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a648066c28180a7cdfac53270a2b4a80d">mapDataProductPointers</a> (art::Event const &amp;event, Handle const &amp;handle)</td></tr>
<tr class="memdesc:a648066c28180a7cdfac53270a2b4a80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map from address of data product element to <em>art</em> pointer to it.  <a href="#a648066c28180a7cdfac53270a2b4a80d">More...</a><br/></td></tr>
<tr class="separator:a648066c28180a7cdfac53270a2b4a80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d88f5bae56f21ca3cb21da09295a7d"><td class="memItemLeft" align="right" valign="top">std::map<br class="typebreak"/>
&lt; fhicl::ParameterSetID, <br class="typebreak"/>
fhicl::ParameterSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af2d88f5bae56f21ca3cb21da09295a7d">readConfigurationFromArtFile</a> (TFile &amp;<a class="el" href="../../da/dd5/updateLAr__v09__43__00_8sh.html#a4fb1a7a55b4ce38d6527639eb9412f22">file</a>)</td></tr>
<tr class="memdesc:af2d88f5bae56f21ca3cb21da09295a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the <em>art</em> configuration stored in <code>sourceDir</code>.  <a href="#af2d88f5bae56f21ca3cb21da09295a7d">More...</a><br/></td></tr>
<tr class="separator:af2d88f5bae56f21ca3cb21da09295a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036bd6f8e03bba53c152f04343399088"><td class="memTemplParams" colspan="2">template&lt;typename Principal &gt; </td></tr>
<tr class="memitem:a036bd6f8e03bba53c152f04343399088"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
fhicl::ParameterSet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a036bd6f8e03bba53c152f04343399088">readConfigurationFromArtPrincipal</a> (Principal const &amp;principal)</td></tr>
<tr class="memdesc:a036bd6f8e03bba53c152f04343399088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the complete <em>art</em> configuration in the principal.  <a href="#a036bd6f8e03bba53c152f04343399088">More...</a><br/></td></tr>
<tr class="separator:a036bd6f8e03bba53c152f04343399088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdd815e3060ee2d44042c2108d6515"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:ac5bdd815e3060ee2d44042c2108d6515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac5bdd815e3060ee2d44042c2108d6515">operator&lt;&lt;</a> (<a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;out, <a class="el" href="../../da/df1/structutil_1_1addIndent.html">addIndent</a> &amp;&amp;adder)</td></tr>
<tr class="memdesc:ac5bdd815e3060ee2d44042c2108d6515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <code><a class="el" href="../../da/df1/structutil_1_1addIndent.html" title="Stream modifier that makes it &quot;indented&quot;. ">addIndent</a></code> (.  <a href="#ac5bdd815e3060ee2d44042c2108d6515">More...</a><br/></td></tr>
<tr class="separator:ac5bdd815e3060ee2d44042c2108d6515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905d3846eb20504eee9d539b96af3f44"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:ga905d3846eb20504eee9d539b96af3f44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#ga905d3846eb20504eee9d539b96af3f44">make_collection_reference</a> (Coll &amp;&amp;coll)</td></tr>
<tr class="memdesc:ga905d3846eb20504eee9d539b96af3f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object referencing to the data contained in <code>coll</code>.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#ga905d3846eb20504eee9d539b96af3f44">More...</a><br/></td></tr>
<tr class="separator:ga905d3846eb20504eee9d539b96af3f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2fe56b53a2676ac06ff52f62c125b4"><td class="memTemplParams" colspan="2">template&lt;typename CollRef &gt; </td></tr>
<tr class="memitem:gaee2fe56b53a2676ac06ff52f62c125b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/da4/group__ContainerMetaprogramming.html#gaee2fe56b53a2676ac06ff52f62c125b4">collection_from_reference</a> (CollRef &amp;collRef)</td></tr>
<tr class="memdesc:gaee2fe56b53a2676ac06ff52f62c125b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object referenced by <code>collRef</code> as a C++ reference.  <a href="../../dd/da4/group__ContainerMetaprogramming.html#gaee2fe56b53a2676ac06ff52f62c125b4">More...</a><br/></td></tr>
<tr class="separator:gaee2fe56b53a2676ac06ff52f62c125b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1d3a95ec691bb7e21db6b8699c2540"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename Extractor &gt; </td></tr>
<tr class="memitem:adc1d3a95ec691bb7e21db6b8699c2540"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#adc1d3a95ec691bb7e21db6b8699c2540">makeValueIndex</a> (Coll const &amp;coll, Extractor getter)</td></tr>
<tr class="memdesc:adc1d3a95ec691bb7e21db6b8699c2540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of value to index.  <a href="#adc1d3a95ec691bb7e21db6b8699c2540">More...</a><br/></td></tr>
<tr class="separator:adc1d3a95ec691bb7e21db6b8699c2540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5023638aa8f2849c0d1ea4981bdbf6d"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:ab5023638aa8f2849c0d1ea4981bdbf6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ab5023638aa8f2849c0d1ea4981bdbf6d">makeValueIndex</a> (Coll const &amp;coll)</td></tr>
<tr class="separator:ab5023638aa8f2849c0d1ea4981bdbf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9316020a748b26e0c8e6d40c3900a0"><td class="memTemplParams" colspan="2">template&lt;typename Ref &gt; </td></tr>
<tr class="memitem:ga4b9316020a748b26e0c8e6d40c3900a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#ga4b9316020a748b26e0c8e6d40c3900a0">referenced_address</a> (Ref &amp;&amp;ref)</td></tr>
<tr class="memdesc:ga4b9316020a748b26e0c8e6d40c3900a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the referenced object.  <a href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#ga4b9316020a748b26e0c8e6d40c3900a0">More...</a><br/></td></tr>
<tr class="separator:ga4b9316020a748b26e0c8e6d40c3900a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a3aa37f4565a91ccc8783d202fcddb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9a3aa37f4565a91ccc8783d202fcddb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gaf9a3aa37f4565a91ccc8783d202fcddb">lvalue_reference_into_wrapper</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:gaf9a3aa37f4565a91ccc8783d202fcddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a l-value reference object into a <code>std::reference_wrapper</code>.  <a href="../../da/d7b/group__MetaprogrammingTypeManipulation.html#gaf9a3aa37f4565a91ccc8783d202fcddb">More...</a><br/></td></tr>
<tr class="separator:gaf9a3aa37f4565a91ccc8783d202fcddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7b3801e849acc3b819c67e57bff2f3"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3">takeAddress</a> ()</td></tr>
<tr class="memdesc:a1b7b3801e849acc3b819c67e57bff2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a functor that returns the address of its argument.  <a href="#a1b7b3801e849acc3b819c67e57bff2f3">More...</a><br/></td></tr>
<tr class="separator:a1b7b3801e849acc3b819c67e57bff2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed27837049c72a2cd23c980fc4472fef"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aed27837049c72a2cd23c980fc4472fef">dereference</a> ()</td></tr>
<tr class="memdesc:aed27837049c72a2cd23c980fc4472fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a functor that returns <code>*ptr</code> of its argument <code>ptr</code>.  <a href="#aed27837049c72a2cd23c980fc4472fef">More...</a><br/></td></tr>
<tr class="separator:aed27837049c72a2cd23c980fc4472fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60c2dec3570d550a2aaf9402ca13ee6"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:ae60c2dec3570d550a2aaf9402ca13ee6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6">makePointerVector</a> (Coll &amp;coll)</td></tr>
<tr class="memdesc:ae60c2dec3570d550a2aaf9402ca13ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a STL vector with pointers to data from another collection.  <a href="#ae60c2dec3570d550a2aaf9402ca13ee6">More...</a><br/></td></tr>
<tr class="separator:ae60c2dec3570d550a2aaf9402ca13ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68ff571825cfe2793a2645b8d64fc5"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename PtrColl &gt; </td></tr>
<tr class="memitem:a6a68ff571825cfe2793a2645b8d64fc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a6a68ff571825cfe2793a2645b8d64fc5">MoveFromPointers</a> (Coll &amp;dest, PtrColl &amp;src)</td></tr>
<tr class="memdesc:a6a68ff571825cfe2793a2645b8d64fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the content from a collection of pointers to one of data.  <a href="#a6a68ff571825cfe2793a2645b8d64fc5">More...</a><br/></td></tr>
<tr class="separator:a6a68ff571825cfe2793a2645b8d64fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147c69da475cca9b6f083920f6b072d2"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename Sorter &gt; </td></tr>
<tr class="memitem:a147c69da475cca9b6f083920f6b072d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a147c69da475cca9b6f083920f6b072d2">SortByPointers</a> (Coll &amp;coll, Sorter sorter)</td></tr>
<tr class="memdesc:a147c69da475cca9b6f083920f6b072d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies sorting indirectly, minimizing data copy.  <a href="#a147c69da475cca9b6f083920f6b072d2">More...</a><br/></td></tr>
<tr class="separator:a147c69da475cca9b6f083920f6b072d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015eacf29c9f7ae95a10ae66d70df561"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename Sorter &gt; </td></tr>
<tr class="memitem:a015eacf29c9f7ae95a10ae66d70df561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a015eacf29c9f7ae95a10ae66d70df561">SortUniquePointers</a> (Coll &amp;coll, Sorter &amp;&amp;sorter)</td></tr>
<tr class="memdesc:a015eacf29c9f7ae95a10ae66d70df561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a vector of unique pointers using a C pointer sorter.  <a href="#a015eacf29c9f7ae95a10ae66d70df561">More...</a><br/></td></tr>
<tr class="separator:a015eacf29c9f7ae95a10ae66d70df561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa522ec41346933950a2a529e5bc0f47f"><td class="memTemplParams" colspan="2">template&lt;typename T  = double&gt; </td></tr>
<tr class="memitem:aa522ec41346933950a2a529e5bc0f47f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa522ec41346933950a2a529e5bc0f47f">pi</a> ()</td></tr>
<tr class="memdesc:aa522ec41346933950a2a529e5bc0f47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant pi (up to 35 decimal digits of precision)  <a href="#aa522ec41346933950a2a529e5bc0f47f">More...</a><br/></td></tr>
<tr class="separator:aa522ec41346933950a2a529e5bc0f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56bf9ebfc74bda03a0eadc58d57e54d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac56bf9ebfc74bda03a0eadc58d57e54d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac56bf9ebfc74bda03a0eadc58d57e54d">DegreesToRadians</a> (T <a class="el" href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a>)</td></tr>
<tr class="memdesc:ac56bf9ebfc74bda03a0eadc58d57e54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the argument angle from degrees into radians.  <a href="#ac56bf9ebfc74bda03a0eadc58d57e54d">More...</a><br/></td></tr>
<tr class="separator:ac56bf9ebfc74bda03a0eadc58d57e54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f30d0d780990b313247818126b73b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a610f30d0d780990b313247818126b73b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a610f30d0d780990b313247818126b73b">RadiansToDegrees</a> (T <a class="el" href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a>)</td></tr>
<tr class="memdesc:a610f30d0d780990b313247818126b73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the argument angle from radians into degrees ( <img class="formulaInl" alt="$ \pi \rightarrow 180 $" src="../../form_63.png"/>)  <a href="#a610f30d0d780990b313247818126b73b">More...</a><br/></td></tr>
<tr class="separator:a610f30d0d780990b313247818126b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343cf786ba234efafdb427e1f148ab79"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename Left , typename Right , typename Data &gt; </td></tr>
<tr class="memitem:a343cf786ba234efafdb427e1f148ab79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a343cf786ba234efafdb427e1f148ab79">DumpAssociationsIntro</a> (<a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;out, art::Assns&lt; Left, Right, <a class="el" href="../../d4/ddc/structData.html">Data</a> &gt; const &amp;assns)</td></tr>
<tr class="memdesc:a343cf786ba234efafdb427e1f148ab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a short introduction about specified association.  <a href="#a343cf786ba234efafdb427e1f148ab79">More...</a><br/></td></tr>
<tr class="separator:a343cf786ba234efafdb427e1f148ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016dc123242a7f1d5c81594de910717"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac016dc123242a7f1d5c81594de910717"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac016dc123242a7f1d5c81594de910717">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; const &amp;b, art::Assns&lt; U, T &gt; &amp;assn, std::string a_instance, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:ac016dc123242a7f1d5c81594de910717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-one association.  <a href="#ac016dc123242a7f1d5c81594de910717">More...</a><br/></td></tr>
<tr class="separator:ac016dc123242a7f1d5c81594de910717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afc8c0b9fe1897a99b07acb8eda03ba"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6afc8c0b9fe1897a99b07acb8eda03ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a6afc8c0b9fe1897a99b07acb8eda03ba">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; const &amp;b, art::Assns&lt; U, T &gt; &amp;assn, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:a6afc8c0b9fe1897a99b07acb8eda03ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-one association.  <a href="#a6afc8c0b9fe1897a99b07acb8eda03ba">More...</a><br/></td></tr>
<tr class="separator:a6afc8c0b9fe1897a99b07acb8eda03ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a93d9952eeece1172eadc00924165"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afc8a93d9952eeece1172eadc00924165"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#afc8a93d9952eeece1172eadc00924165">CreateAssn</a> (art::Event &amp;evt, art::Ptr&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; const &amp;b, art::Assns&lt; U, T &gt; &amp;assn)</td></tr>
<tr class="memdesc:afc8a93d9952eeece1172eadc00924165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-one association.  <a href="#afc8a93d9952eeece1172eadc00924165">More...</a><br/></td></tr>
<tr class="separator:afc8a93d9952eeece1172eadc00924165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c681859826ad7b4f471365cbbd1abc1"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4c681859826ad7b4f471365cbbd1abc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4c681859826ad7b4f471365cbbd1abc1">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::PtrVector&lt; U &gt; const &amp;b, art::Assns&lt; T, U &gt; &amp;assn, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:a4c681859826ad7b4f471365cbbd1abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#a4c681859826ad7b4f471365cbbd1abc1">More...</a><br/></td></tr>
<tr class="separator:a4c681859826ad7b4f471365cbbd1abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a92868911ae6540a306c33c3f92e0f"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a94a92868911ae6540a306c33c3f92e0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a94a92868911ae6540a306c33c3f92e0f">CreateAssn</a> (art::Event &amp;evt, art::Ptr&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt;&gt; const &amp;b, art::Assns&lt; T, U &gt; &amp;assn)</td></tr>
<tr class="memdesc:a94a92868911ae6540a306c33c3f92e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#a94a92868911ae6540a306c33c3f92e0f">More...</a><br/></td></tr>
<tr class="separator:a94a92868911ae6540a306c33c3f92e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e9bb0c43ca9f79cf6b227b0783ae1"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a901e9bb0c43ca9f79cf6b227b0783ae1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a901e9bb0c43ca9f79cf6b227b0783ae1">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt;&gt; const &amp;b, art::Assns&lt; T, U &gt; &amp;assn, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:a901e9bb0c43ca9f79cf6b227b0783ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#a901e9bb0c43ca9f79cf6b227b0783ae1">More...</a><br/></td></tr>
<tr class="separator:a901e9bb0c43ca9f79cf6b227b0783ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28abf414a9cc74066cdc86008e13da9"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae28abf414a9cc74066cdc86008e13da9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae28abf414a9cc74066cdc86008e13da9">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; const &amp;b, art::Assns&lt; T, U &gt; &amp;assn, size_t startU, size_t endU, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:ae28abf414a9cc74066cdc86008e13da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#ae28abf414a9cc74066cdc86008e13da9">More...</a><br/></td></tr>
<tr class="separator:ae28abf414a9cc74066cdc86008e13da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e926d6e3d7cbd5ee0171147dd12c848"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0e926d6e3d7cbd5ee0171147dd12c848"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a0e926d6e3d7cbd5ee0171147dd12c848">CreateAssn</a> (art::Event &amp;evt, std::vector&lt; T &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; const &amp;b, art::Assns&lt; T, U &gt; &amp;assn, std::vector&lt; size_t &gt; const &amp;indices, size_t index=UINT_MAX)</td></tr>
<tr class="memdesc:a0e926d6e3d7cbd5ee0171147dd12c848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#a0e926d6e3d7cbd5ee0171147dd12c848">More...</a><br/></td></tr>
<tr class="separator:a0e926d6e3d7cbd5ee0171147dd12c848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d47e6280798ded3546b84ad103fb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Iter &gt; </td></tr>
<tr class="memitem:a570d47e6280798ded3546b84ad103fb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a570d47e6280798ded3546b84ad103fb8">CreateAssn</a> (art::Event &amp;evt, art::Assns&lt; T, U &gt; &amp;assn, size_t first_index, Iter from_second_index, Iter to_second_index)</td></tr>
<tr class="memdesc:a570d47e6280798ded3546b84ad103fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-many association.  <a href="#a570d47e6280798ded3546b84ad103fb8">More...</a><br/></td></tr>
<tr class="separator:a570d47e6280798ded3546b84ad103fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34b9d1584810132b1c34642fe0c2c64"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae34b9d1584810132b1c34642fe0c2c64"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const U * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae34b9d1584810132b1c34642fe0c2c64">FindUNotAssociatedToT</a> (art::Handle&lt; U &gt; b, art::Event const &amp;evt, std::string const &amp;label)</td></tr>
<tr class="separator:ae34b9d1584810132b1c34642fe0c2c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf1b63829a628c891afea555a5da720"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5bf1b63829a628c891afea555a5da720"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5bf1b63829a628c891afea555a5da720">FindUNotAssociatedToTP</a> (art::Handle&lt; U &gt; b, art::Event const &amp;evt, std::string const &amp;label)</td></tr>
<tr class="separator:a5bf1b63829a628c891afea555a5da720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ab92d0904f321db37740cd35c427fb"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a24ab92d0904f321db37740cd35c427fb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a24ab92d0904f321db37740cd35c427fb">GetAssociatedVectorOneI</a> (art::Handle&lt; art::Assns&lt; T, U &gt; &gt; <a class="el" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>, art::Handle&lt; std::vector&lt; T &gt; &gt; index_p)</td></tr>
<tr class="separator:a24ab92d0904f321db37740cd35c427fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9e14dfb9470b263283607c381695bc"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:afa9e14dfb9470b263283607c381695bc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const U * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#afa9e14dfb9470b263283607c381695bc">GetAssociatedVectorOneP</a> (art::Handle&lt; art::Assns&lt; T, U &gt; &gt; <a class="el" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>, art::Handle&lt; std::vector&lt; T &gt; &gt; index_p)</td></tr>
<tr class="separator:afa9e14dfb9470b263283607c381695bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad77dda9b06a4598bea92f328bc7e76"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aaad77dda9b06a4598bea92f328bc7e76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; size_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aaad77dda9b06a4598bea92f328bc7e76">GetAssociatedVectorManyI</a> (art::Handle&lt; art::Assns&lt; T, U &gt; &gt; <a class="el" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>, art::Handle&lt; std::vector&lt; T &gt; &gt; index_p)</td></tr>
<tr class="separator:aaad77dda9b06a4598bea92f328bc7e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23324fc3481d806fa12b9ced6f904c08"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a23324fc3481d806fa12b9ced6f904c08"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; const U * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a23324fc3481d806fa12b9ced6f904c08">GetAssociatedVectorManyP</a> (art::Handle&lt; art::Assns&lt; T, U &gt; &gt; <a class="el" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>, art::Handle&lt; std::vector&lt; T &gt; &gt; index_p)</td></tr>
<tr class="separator:a23324fc3481d806fa12b9ced6f904c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61245df67af7b4e7f877f713e51991f0"><td class="memTemplParams" colspan="2">template&lt;typename Producer , typename... Args&gt; </td></tr>
<tr class="memitem:a61245df67af7b4e7f877f713e51991f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_base_of_v<br class="typebreak"/>
&lt; art::EDProducer, Producer &gt;<br class="typebreak"/>
, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a61245df67af7b4e7f877f713e51991f0">CreateAssn</a> (Producer const &amp;, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a61245df67af7b4e7f877f713e51991f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6b8551ef84e353098384562a972b9a"><td class="memTemplParams" colspan="2">template&lt;typename Producer , typename... Args&gt; </td></tr>
<tr class="memitem:a3e6b8551ef84e353098384562a972b9a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_base_of_v<br class="typebreak"/>
&lt; art::EDProducer, Producer &gt;<br class="typebreak"/>
, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3e6b8551ef84e353098384562a972b9a">CreateAssnD</a> (Producer const &amp;, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a3e6b8551ef84e353098384562a972b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62da271458feca9cb29c496feea8f72"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Pred &gt; </td></tr>
<tr class="memitem:aa62da271458feca9cb29c496feea8f72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa62da271458feca9cb29c496feea8f72">filterRangeFor</a> (<a class="el" href="../../df/d18/classutil_1_1Range.html">Range</a> &amp;&amp;range, Pred &amp;&amp;pred) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:aa62da271458feca9cb29c496feea8f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides iteration only through elements passing a condition.  <a href="#aa62da271458feca9cb29c496feea8f72">More...</a><br/></td></tr>
<tr class="separator:aa62da271458feca9cb29c496feea8f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cc23cf942017f81281aeee4c7ba4c1"><td class="memTemplParams" colspan="2">template&lt;class A , class F &gt; </td></tr>
<tr class="memitem:a19cc23cf942017f81281aeee4c7ba4c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a19cc23cf942017f81281aeee4c7ba4c1">for_each_associated_group</a> (A const &amp;assns, <a class="el" href="../../d4/daf/sbnana_2sbnana_2CAFAna_2Analysis_2Surface_8cxx.html#a2c3bf28add4b70497e6fd9070cd7dfc9">F</a> &amp;func)</td></tr>
<tr class="memdesc:a19cc23cf942017f81281aeee4c7ba4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to access associations in order.  <a href="#a19cc23cf942017f81281aeee4c7ba4c1">More...</a><br/></td></tr>
<tr class="separator:a19cc23cf942017f81281aeee4c7ba4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a267ed8783b05b951db1b985e4f057"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a66a267ed8783b05b951db1b985e4f057"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a66a267ed8783b05b951db1b985e4f057">associated_groups</a> (A const &amp;assns)</td></tr>
<tr class="memdesc:a66a267ed8783b05b951db1b985e4f057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to access associations in order.  <a href="#a66a267ed8783b05b951db1b985e4f057">More...</a><br/></td></tr>
<tr class="separator:a66a267ed8783b05b951db1b985e4f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1593f344a06d605cbc7ecafcf1636e99"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a1593f344a06d605cbc7ecafcf1636e99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a1593f344a06d605cbc7ecafcf1636e99">associated_groups_with_left</a> (A const &amp;assns)</td></tr>
<tr class="memdesc:a1593f344a06d605cbc7ecafcf1636e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to access associations in order, also with key.  <a href="#a1593f344a06d605cbc7ecafcf1636e99">More...</a><br/></td></tr>
<tr class="separator:a1593f344a06d605cbc7ecafcf1636e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fdd67e7ecbab0d50595428482dbfd1"><td class="memTemplParams" colspan="2">template&lt;typename Groups &gt; </td></tr>
<tr class="memitem:a99fdd67e7ecbab0d50595428482dbfd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a99fdd67e7ecbab0d50595428482dbfd1">groupByIndex</a> (Groups &amp;&amp;groups, std::size_t index) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a99fdd67e7ecbab0d50595428482dbfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group within <code>groups</code> with the specified index.  <a href="#a99fdd67e7ecbab0d50595428482dbfd1">More...</a><br/></td></tr>
<tr class="separator:a99fdd67e7ecbab0d50595428482dbfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f3c0e9aaa9c0640cefeb60a7abeb51"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename KeyOf &gt; </td></tr>
<tr class="memitem:a38f3c0e9aaa9c0640cefeb60a7abeb51"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a38f3c0e9aaa9c0640cefeb60a7abeb51">MakeIndex</a> (Coll const &amp;data, KeyOf key_of=KeyOf())</td></tr>
<tr class="memdesc:a38f3c0e9aaa9c0640cefeb60a7abeb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map of indices from an existing collection.  <a href="#a38f3c0e9aaa9c0640cefeb60a7abeb51">More...</a><br/></td></tr>
<tr class="separator:a38f3c0e9aaa9c0640cefeb60a7abeb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18642be0ec704376f3a90a55a6258587"><td class="memTemplParams" colspan="2">template&lt;typename Coll , typename KeyOf &gt; </td></tr>
<tr class="memitem:a18642be0ec704376f3a90a55a6258587"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a18642be0ec704376f3a90a55a6258587">MakeMap</a> (Coll const &amp;data, KeyOf key_of=KeyOf()) -&gt; std::vector&lt; decltype(key_of(*(<a class="el" href="../../df/db6/geo__vectors__utils__TVector_8h.html#abd762dc0ccf00b6ee7f81a289b7bd4f8">data.begin</a>()))) const * &gt;</td></tr>
<tr class="memdesc:a18642be0ec704376f3a90a55a6258587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map of objects from an existing collection.  <a href="#a18642be0ec704376f3a90a55a6258587">More...</a><br/></td></tr>
<tr class="separator:a18642be0ec704376f3a90a55a6258587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9260dbf51f5a9d40bc2cc68f179179"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a4d9260dbf51f5a9d40bc2cc68f179179"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4d9260dbf51f5a9d40bc2cc68f179179">wrapRangeFor</a> (<a class="el" href="../../df/d18/classutil_1_1Range.html">Range</a> &amp;&amp;range) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a4d9260dbf51f5a9d40bc2cc68f179179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an object for use in a range-for loop.  <a href="#a4d9260dbf51f5a9d40bc2cc68f179179">More...</a><br/></td></tr>
<tr class="separator:a4d9260dbf51f5a9d40bc2cc68f179179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27485ae016c22bdc5eeb4d399195dd60"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a27485ae016c22bdc5eeb4d399195dd60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a27485ae016c22bdc5eeb4d399195dd60">operator|</a> (<a class="el" href="../../df/d18/classutil_1_1Range.html">Range</a> &amp;&amp;range, <a class="el" href="../../d6/d72/structutil_1_1RangeForWrapperTag.html">RangeForWrapperTag</a>) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a27485ae016c22bdc5eeb4d399195dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a range so that it can be used in a range-for loop.  <a href="#a27485ae016c22bdc5eeb4d399195dd60">More...</a><br/></td></tr>
<tr class="separator:a27485ae016c22bdc5eeb4d399195dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc9c542e10ef72479ce299f90b34431"><td class="memTemplParams" colspan="2">template&lt;unsigned int RANK1, unsigned int RANK2, typename  = std::enable_if_t&lt;(RANK1 != RANK2), bool&gt;&gt; </td></tr>
<tr class="memitem:a9cc9c542e10ef72479ce299f90b34431"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a9cc9c542e10ef72479ce299f90b34431">operator==</a> (<a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt; RANK1 &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt; RANK2 &gt; const &amp;b)</td></tr>
<tr class="memdesc:a9cc9c542e10ef72479ce299f90b34431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator with tensors of different rank.  <a href="#a9cc9c542e10ef72479ce299f90b34431">More...</a><br/></td></tr>
<tr class="separator:a9cc9c542e10ef72479ce299f90b34431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b6af003aae2adbb7bffbaf8f7bb5ba"><td class="memTemplParams" colspan="2">template&lt;unsigned int RANK1, unsigned int RANK2, typename  = std::enable_if_t&lt;(RANK1 != RANK2), bool&gt;&gt; </td></tr>
<tr class="memitem:a58b6af003aae2adbb7bffbaf8f7bb5ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a58b6af003aae2adbb7bffbaf8f7bb5ba">operator!=</a> (<a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt; RANK1 &gt; const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt; RANK2 &gt; const &amp;b)</td></tr>
<tr class="memdesc:a58b6af003aae2adbb7bffbaf8f7bb5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator with tensors of different rank.  <a href="#a58b6af003aae2adbb7bffbaf8f7bb5ba">More...</a><br/></td></tr>
<tr class="separator:a58b6af003aae2adbb7bffbaf8f7bb5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec03781f4514c89c45f6451da830fb94"><td class="memTemplParams" colspan="2">template&lt;typename... DIMS&gt; </td></tr>
<tr class="memitem:aec03781f4514c89c45f6451da830fb94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aec03781f4514c89c45f6451da830fb94">makeTensorIndices</a> (DIMS...dims)</td></tr>
<tr class="memdesc:aec03781f4514c89c45f6451da830fb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html" title="Converts a tensor element specification into a linear index. ">TensorIndices</a> class with the specified dimensions.  <a href="#aec03781f4514c89c45f6451da830fb94">More...</a><br/></td></tr>
<tr class="separator:aec03781f4514c89c45f6451da830fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce95d97a180ee193d80d1f3c4cb3063"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga9ce95d97a180ee193d80d1f3c4cb3063"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga9ce95d97a180ee193d80d1f3c4cb3063">getByExtractedType</a> (Tuple const &amp;data) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga9ce95d97a180ee193d80d1f3c4cb3063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the element containing the specified type.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga9ce95d97a180ee193d80d1f3c4cb3063">More...</a><br/></td></tr>
<tr class="separator:ga9ce95d97a180ee193d80d1f3c4cb3063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4417e45bc692ac9d1667479dcafb381e"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga4417e45bc692ac9d1667479dcafb381e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga4417e45bc692ac9d1667479dcafb381e">makeTagged</a> (T &amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga4417e45bc692ac9d1667479dcafb381e"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga4417e45bc692ac9d1667479dcafb381e">More...</a><br/></td></tr>
<tr class="separator:ga4417e45bc692ac9d1667479dcafb381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d0849e186add2239834cf1c4b805c5"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga80d0849e186add2239834cf1c4b805c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga80d0849e186add2239834cf1c4b805c5">makeTagged</a> (T const &amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga80d0849e186add2239834cf1c4b805c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga80d0849e186add2239834cf1c4b805c5">More...</a><br/></td></tr>
<tr class="separator:ga80d0849e186add2239834cf1c4b805c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga203ab7f1d6cac9d7c1a809268e66f1ef">makeTagged</a> (T const &amp;&amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga203ab7f1d6cac9d7c1a809268e66f1ef">More...</a><br/></td></tr>
<tr class="separator:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec1f0e583af63d593c99e689c842844"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga2ec1f0e583af63d593c99e689c842844"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga2ec1f0e583af63d593c99e689c842844">makeTagged</a> (T &amp;&amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga2ec1f0e583af63d593c99e689c842844"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga2ec1f0e583af63d593c99e689c842844">More...</a><br/></td></tr>
<tr class="separator:ga2ec1f0e583af63d593c99e689c842844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga3501a5dcc0a73dbe1eeb35962fc1072d">removeTag</a> (Tagged &amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga3501a5dcc0a73dbe1eeb35962fc1072d">More...</a><br/></td></tr>
<tr class="separator:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7301708ee42ce486d5d916e4608d4def"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga7301708ee42ce486d5d916e4608d4def"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga7301708ee42ce486d5d916e4608d4def">removeTag</a> (Tagged const &amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga7301708ee42ce486d5d916e4608d4def"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga7301708ee42ce486d5d916e4608d4def">More...</a><br/></td></tr>
<tr class="separator:ga7301708ee42ce486d5d916e4608d4def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a174508a8b306a65841d3514fe7dd99"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga3a174508a8b306a65841d3514fe7dd99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga3a174508a8b306a65841d3514fe7dd99">removeTag</a> (Tagged const &amp;&amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga3a174508a8b306a65841d3514fe7dd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga3a174508a8b306a65841d3514fe7dd99">More...</a><br/></td></tr>
<tr class="separator:ga3a174508a8b306a65841d3514fe7dd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga1f3c35ec5f6dcb0948918080eec4f2df">removeTag</a> (Tagged &amp;&amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga1f3c35ec5f6dcb0948918080eec4f2df">More...</a><br/></td></tr>
<tr class="separator:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5077b90fa8c5e783381625ddda42579c"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga5077b90fa8c5e783381625ddda42579c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga5077b90fa8c5e783381625ddda42579c">getByTag</a> (Tuple const &amp;data) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga5077b90fa8c5e783381625ddda42579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object with the specified tag.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga5077b90fa8c5e783381625ddda42579c">More...</a><br/></td></tr>
<tr class="separator:ga5077b90fa8c5e783381625ddda42579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41abde744908d25ab113abcd4e67dfd"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Mapping &gt; </td></tr>
<tr class="memitem:aa41abde744908d25ab113abcd4e67dfd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa41abde744908d25ab113abcd4e67dfd">mapContainer</a> (Cont cont, Mapping mapping)</td></tr>
<tr class="memdesc:aa41abde744908d25ab113abcd4e67dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container-like object mapping the content of <code>cont</code>.  <a href="#aa41abde744908d25ab113abcd4e67dfd">More...</a><br/></td></tr>
<tr class="separator:aa41abde744908d25ab113abcd4e67dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01604213800d76620886170c986935fa"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Mapping , typename Container , typename Reference &gt; </td></tr>
<tr class="memitem:a01604213800d76620886170c986935fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html">MappedContainer</a>&lt; Cont, Mapping &gt;<br class="typebreak"/>
::template IteratorBase<br class="typebreak"/>
&lt; Container, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a01604213800d76620886170c986935fa">operator+</a> (typename <a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html">MappedContainer</a>&lt; Cont, Mapping &gt;::template IteratorBase&lt; Container, Reference &gt;::difference_type <a class="el" href="../../d0/d99/find__fhicl_8sh.html#a1bfbd78e0d8a2bc06df6cee466cca51a">n</a>, typename <a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html">MappedContainer</a>&lt; Cont, Mapping &gt;::template IteratorBase&lt; Container, Reference &gt; const &amp;it)</td></tr>
<tr class="separator:a01604213800d76620886170c986935fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c4472a5341320f48fb89ef5ddde6d6"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a79c4472a5341320f48fb89ef5ddde6d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a79c4472a5341320f48fb89ef5ddde6d6">operator==</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="separator:a79c4472a5341320f48fb89ef5ddde6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14c0e43a90e7b91bd329a8e4eef47f"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:adf14c0e43a90e7b91bd329a8e4eef47f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#adf14c0e43a90e7b91bd329a8e4eef47f">operator&lt;</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="separator:adf14c0e43a90e7b91bd329a8e4eef47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dac94677261b934f9ccaf19ad9c0584"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a2dac94677261b934f9ccaf19ad9c0584"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a2dac94677261b934f9ccaf19ad9c0584">operator!=</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="memdesc:a2dac94677261b934f9ccaf19ad9c0584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator==.  <a href="#a2dac94677261b934f9ccaf19ad9c0584">More...</a><br/></td></tr>
<tr class="separator:a2dac94677261b934f9ccaf19ad9c0584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7ce54e3ab65b02e5a7cb5aa7558a63"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:aaf7ce54e3ab65b02e5a7cb5aa7558a63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aaf7ce54e3ab65b02e5a7cb5aa7558a63">operator&gt;</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="memdesc:aaf7ce54e3ab65b02e5a7cb5aa7558a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="#aaf7ce54e3ab65b02e5a7cb5aa7558a63">More...</a><br/></td></tr>
<tr class="separator:aaf7ce54e3ab65b02e5a7cb5aa7558a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2cb6771c97d36df4985b184f2fb3d7"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:aee2cb6771c97d36df4985b184f2fb3d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aee2cb6771c97d36df4985b184f2fb3d7">operator&lt;=</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="memdesc:aee2cb6771c97d36df4985b184f2fb3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="#aee2cb6771c97d36df4985b184f2fb3d7">More...</a><br/></td></tr>
<tr class="separator:aee2cb6771c97d36df4985b184f2fb3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f3f2bb1702b0200d3ef7874ed6a3b9"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a15f3f2bb1702b0200d3ef7874ed6a3b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a15f3f2bb1702b0200d3ef7874ed6a3b9">operator&gt;=</a> (const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, const <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="memdesc:a15f3f2bb1702b0200d3ef7874ed6a3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="#a15f3f2bb1702b0200d3ef7874ed6a3b9">More...</a><br/></td></tr>
<tr class="separator:a15f3f2bb1702b0200d3ef7874ed6a3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c96a01b8b19491fba3f0b04bf4b30c"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:a78c96a01b8b19491fba3f0b04bf4b30c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a78c96a01b8b19491fba3f0b04bf4b30c">swap</a> (<a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__x, <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>&lt; _Key, _Tp, _Compare &gt; &amp;__y)</td></tr>
<tr class="memdesc:a78c96a01b8b19491fba3f0b04bf4b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html#a011489d28ce5d769e4340cb9cffc5437">VectorMap::swap()</a>.  <a href="#a78c96a01b8b19491fba3f0b04bf4b30c">More...</a><br/></td></tr>
<tr class="separator:a78c96a01b8b19491fba3f0b04bf4b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5aee8fe16506ca25702d0d0334af87"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a1a5aee8fe16506ca25702d0d0334af87">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="../../da/d77/classutil_1_1EventChangeTracker__t.html">EventChangeTracker_t</a> const &amp;trk)</td></tr>
<tr class="separator:a1a5aee8fe16506ca25702d0d0334af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3374b894f30cb4c2adc8996589aee5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5a3374b894f30cb4c2adc8996589aee5">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="../../d1/dde/classutil_1_1DataProductChangeTracker__t.html">DataProductChangeTracker_t</a> const &amp;trk)</td></tr>
<tr class="separator:a5a3374b894f30cb4c2adc8996589aee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785de3ffa76318f6e841b8595ffb5d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5785de3ffa76318f6e841b8595ffb5d2">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="../../dd/d68/classutil_1_1PlaneDataChangeTracker__t.html">PlaneDataChangeTracker_t</a> const &amp;trk)</td></tr>
<tr class="separator:a5785de3ffa76318f6e841b8595ffb5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8cdd2947ac85743279c480ab444787"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#afd8cdd2947ac85743279c480ab444787">root_env</a></td></tr>
<tr class="separator:afd8cdd2947ac85743279c480ab444787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a366470c9c9b9d3a2172f37fa1b8740"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a2a366470c9c9b9d3a2172f37fa1b8740">wait</a></td></tr>
<tr class="separator:a2a366470c9c9b9d3a2172f37fa1b8740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81157b17422732381feb626f9be3379"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ab81157b17422732381feb626f9be3379">write</a></td></tr>
<tr class="separator:ab81157b17422732381feb626f9be3379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e63fe4e140fefa6bdb4ba844a148a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">with_input_args</a></td></tr>
<tr class="separator:af94e63fe4e140fefa6bdb4ba844a148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb71489058a2dd4620fb7264fa19e4c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#abb71489058a2dd4620fb7264fa19e4c8">filespec</a></td></tr>
<tr class="separator:abb71489058a2dd4620fb7264fa19e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95e22f641fc311d452e4b0ab6f97b9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae95e22f641fc311d452e4b0ab6f97b9a">get_tobject</a></td></tr>
<tr class="separator:ae95e22f641fc311d452e4b0ab6f97b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4963cf5fc98fe4d01ad8c9158a921b52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4963cf5fc98fe4d01ad8c9158a921b52">with_text_args</a></td></tr>
<tr class="separator:a4963cf5fc98fe4d01ad8c9158a921b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f617446509643ca091b521d5c618c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a83f617446509643ca091b521d5c618c2">draw_text</a></td></tr>
<tr class="separator:a83f617446509643ca091b521d5c618c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4046d74d1677e7c6ba8b6253cd1a2285"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">with_display_args</a></td></tr>
<tr class="separator:a4046d74d1677e7c6ba8b6253cd1a2285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232d69e15ae3bef0c7e4f093f94096cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a232d69e15ae3bef0c7e4f093f94096cb">with_io_args</a></td></tr>
<tr class="separator:a232d69e15ae3bef0c7e4f093f94096cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2d09360a2f1724c5a928b93994eb82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">with_graphsize_args</a></td></tr>
<tr class="separator:a7c2d09360a2f1724c5a928b93994eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58d6fbb4df28b9d3a17e67bf9cbf06d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae58d6fbb4df28b9d3a17e67bf9cbf06d">with_histosize_args</a></td></tr>
<tr class="separator:ae58d6fbb4df28b9d3a17e67bf9cbf06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf9a32ad36d4898b3eeaa4a0c9f2b3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4bf9a32ad36d4898b3eeaa4a0c9f2b3c">resize_graph</a></td></tr>
<tr class="separator:a4bf9a32ad36d4898b3eeaa4a0c9f2b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eda96341323a214c82023547b1a452b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a8eda96341323a214c82023547b1a452b">resize_histo</a></td></tr>
<tr class="separator:a8eda96341323a214c82023547b1a452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4b435aac9795179f8e857019c76202"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ada4b435aac9795179f8e857019c76202">int_pair</a></td></tr>
<tr class="separator:ada4b435aac9795179f8e857019c76202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d71536f0aaebe36f32d1d15b581c021"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a8d71536f0aaebe36f32d1d15b581c021">with_histostyle_args</a></td></tr>
<tr class="separator:a8d71536f0aaebe36f32d1d15b581c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3802fbad8267765c94febc0ef77b31e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af3802fbad8267765c94febc0ef77b31e">optstat</a></td></tr>
<tr class="separator:af3802fbad8267765c94febc0ef77b31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf4876cc648f293505a82b303ad1ad0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3bf4876cc648f293505a82b303ad1ad0">style</a></td></tr>
<tr class="separator:a3bf4876cc648f293505a82b303ad1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2377386e81dcf37ed9492c880ab7527"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae2377386e81dcf37ed9492c880ab7527">fillcolors</a></td></tr>
<tr class="separator:ae2377386e81dcf37ed9492c880ab7527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc05abafaee59d66ab1a1510d05306"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4ddc05abafaee59d66ab1a1510d05306">namecolors</a></td></tr>
<tr class="separator:a4ddc05abafaee59d66ab1a1510d05306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78763547f615316fc4a54ad5a473789a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a78763547f615316fc4a54ad5a473789a">comma_separated</a></td></tr>
<tr class="separator:a78763547f615316fc4a54ad5a473789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01494a9fa792a5164f54d978be3fc541"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a01494a9fa792a5164f54d978be3fc541">draw_potlabel</a></td></tr>
<tr class="separator:a01494a9fa792a5164f54d978be3fc541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b571c6292afe0dab16baeff0d07f2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#acf4b571c6292afe0dab16baeff0d07f2">draw_sbnlabel</a></td></tr>
<tr class="separator:acf4b571c6292afe0dab16baeff0d07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84ba76bb5b6b9c6e915e1da6a3e25e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a9d84ba76bb5b6b9c6e915e1da6a3e25e">draw_iclabel</a></td></tr>
<tr class="separator:a9d84ba76bb5b6b9c6e915e1da6a3e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf86b37b7f27dd8e26cb35a61b566398"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#acf86b37b7f27dd8e26cb35a61b566398">draw_sbndlabel</a></td></tr>
<tr class="separator:acf86b37b7f27dd8e26cb35a61b566398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18509a1ee0c6aed41a4ffd6163a8842"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad18509a1ee0c6aed41a4ffd6163a8842">legend_position</a></td></tr>
<tr class="separator:ad18509a1ee0c6aed41a4ffd6163a8842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460884f7c7be5ebcb68581fd3910e59b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a460884f7c7be5ebcb68581fd3910e59b">histo_list</a></td></tr>
<tr class="separator:a460884f7c7be5ebcb68581fd3910e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a372ce12124227afecb423d4237611"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad8a372ce12124227afecb423d4237611">validate_hists</a></td></tr>
<tr class="separator:ad8a372ce12124227afecb423d4237611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1b35c6340b6c133e6047946feee983"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a2b1b35c6340b6c133e6047946feee983">ECCQE</a> (const TVector3 &amp;l_momentum, double l_energy)</td></tr>
<tr class="separator:a2b1b35c6340b6c133e6047946feee983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa47a1a36712e98d450e2e6fe3fc1f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aefa47a1a36712e98d450e2e6fe3fc1f2">ContainedLength</a> (const TVector3 &amp;v0, const TVector3 &amp;v1, const std::vector&lt; <a class="el" href="../../db/d54/classgeo_1_1BoxBoundedGeo.html">geo::BoxBoundedGeo</a> &gt; &amp;boxes)</td></tr>
<tr class="separator:aefa47a1a36712e98d450e2e6fe3fc1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ee679df3a620774f76771dc3b0a9bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a69ee679df3a620774f76771dc3b0a9bf">MCParticleLength</a> (const simb::MCParticle &amp;particle)</td></tr>
<tr class="separator:a69ee679df3a620774f76771dc3b0a9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552d34284b2fcf1991b777c08e9998a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a552d34284b2fcf1991b777c08e9998a8">MCParticleContainedLength</a> (const simb::MCParticle &amp;particle, const std::vector&lt; <a class="el" href="../../db/d54/classgeo_1_1BoxBoundedGeo.html">geo::BoxBoundedGeo</a> &gt; &amp;active_volumes)</td></tr>
<tr class="separator:a552d34284b2fcf1991b777c08e9998a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae4eb96d0ec103986b67eaeda56792523"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:ae4eb96d0ec103986b67eaeda56792523"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae4eb96d0ec103986b67eaeda56792523">makeIndented</a> (<a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;out, std::string indent, std::string firstIndent)</td></tr>
<tr class="memdesc:ae4eb96d0ec103986b67eaeda56792523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an indented stream wrapper.  <a href="#ae4eb96d0ec103986b67eaeda56792523">More...</a><br/></td></tr>
<tr class="separator:ae4eb96d0ec103986b67eaeda56792523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299fa63cb45bbb0570165f3c779f0487"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:a299fa63cb45bbb0570165f3c779f0487"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a299fa63cb45bbb0570165f3c779f0487">makeIndented</a> (<a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;out, std::string const &amp;indent)</td></tr>
<tr class="separator:a299fa63cb45bbb0570165f3c779f0487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Counted iterations</div></td></tr>
<tr class="memitem:a9462a726cd010ab8ada5eead879a4b9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9462a726cd010ab8ada5eead879a4b9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f">counter</a> (T <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>, T <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>)</td></tr>
<tr class="memdesc:a9462a726cd010ab8ada5eead879a4b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object to iterate values from <code>begin</code> to <code>end</code> in a range-for loop.  <a href="#a9462a726cd010ab8ada5eead879a4b9f">More...</a><br/></td></tr>
<tr class="separator:a9462a726cd010ab8ada5eead879a4b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b9b82160a0ba48b6993899ed07d613"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2b9b82160a0ba48b6993899ed07d613"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa2b9b82160a0ba48b6993899ed07d613">counter</a> (T <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>)</td></tr>
<tr class="separator:aa2b9b82160a0ba48b6993899ed07d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e50ab383cb5972d782bc7e3814a83"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::size_t&gt; </td></tr>
<tr class="memitem:a938e50ab383cb5972d782bc7e3814a83"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a938e50ab383cb5972d782bc7e3814a83">infinite_counter</a> (T <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>=T{})</td></tr>
<tr class="memdesc:a938e50ab383cb5972d782bc7e3814a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f" title="Returns an object to iterate values from begin to end in a range-for loop. ">util::counter()</a></code> starting at <code>begin</code> and never ending.  <a href="#a938e50ab383cb5972d782bc7e3814a83">More...</a><br/></td></tr>
<tr class="separator:a938e50ab383cb5972d782bc7e3814a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Enumerated iterations</div></td></tr>
<tr class="memitem:af0615b7538ff948ea65d5206a23c84f2"><td class="memTemplParams" colspan="2">template&lt;std::size_t Lead, typename... Iterables&gt; </td></tr>
<tr class="memitem:af0615b7538ff948ea65d5206a23c84f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">enumerate</a> (Iterables &amp;&amp;...iterables)</td></tr>
<tr class="memdesc:af0615b7538ff948ea65d5206a23c84f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper tracking the number of iteration.  <a href="#af0615b7538ff948ea65d5206a23c84f2">More...</a><br/></td></tr>
<tr class="separator:af0615b7538ff948ea65d5206a23c84f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7661a52749ed0bcd221f86b51f9607a"><td class="memTemplParams" colspan="2">template&lt;typename... Iterables&gt; </td></tr>
<tr class="memitem:af7661a52749ed0bcd221f86b51f9607a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#af7661a52749ed0bcd221f86b51f9607a">enumerate</a> (Iterables &amp;&amp;...iterables)</td></tr>
<tr class="memdesc:af7661a52749ed0bcd221f86b51f9607a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>enumerate</code> implicitly uses the first iterable as lead.  <a href="#af7661a52749ed0bcd221f86b51f9607a">More...</a><br/></td></tr>
<tr class="separator:af7661a52749ed0bcd221f86b51f9607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformed iterations</div></td></tr>
<tr class="memitem:a86614a681b6e3194af2c27467c922e55"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Indices, typename Coll &gt; </td></tr>
<tr class="memitem:a86614a681b6e3194af2c27467c922e55"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a86614a681b6e3194af2c27467c922e55">get_elements</a> (Coll &amp;&amp;coll)</td></tr>
<tr class="memdesc:a86614a681b6e3194af2c27467c922e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper iterating across some of the element of each value in the specified collection.  <a href="#a86614a681b6e3194af2c27467c922e55">More...</a><br/></td></tr>
<tr class="separator:a86614a681b6e3194af2c27467c922e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c01229293476942473afa9469a21638"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Indices, typename Coll &gt; </td></tr>
<tr class="memitem:a6c01229293476942473afa9469a21638"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a6c01229293476942473afa9469a21638">get_const_elements</a> (Coll &amp;&amp;coll)</td></tr>
<tr class="memdesc:a6c01229293476942473afa9469a21638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper iterating across the constant values of the specified collection.  <a href="#a6c01229293476942473afa9469a21638">More...</a><br/></td></tr>
<tr class="separator:a6c01229293476942473afa9469a21638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a55399a188de49d3d1461d3b0f37dc4"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:a5a55399a188de49d3d1461d3b0f37dc4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4">values</a> (Coll &amp;&amp;coll)</td></tr>
<tr class="memdesc:a5a55399a188de49d3d1461d3b0f37dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper iterating across the values of the specified collection.  <a href="#a5a55399a188de49d3d1461d3b0f37dc4">More...</a><br/></td></tr>
<tr class="separator:a5a55399a188de49d3d1461d3b0f37dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4707f84c6dc5c269f147302722611f"><td class="memTemplParams" colspan="2">template&lt;typename Coll &gt; </td></tr>
<tr class="memitem:aac4707f84c6dc5c269f147302722611f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aac4707f84c6dc5c269f147302722611f">const_values</a> (Coll &amp;&amp;coll)</td></tr>
<tr class="memdesc:aac4707f84c6dc5c269f147302722611f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper iterating across the constant values of the specified collection.  <a href="#aac4707f84c6dc5c269f147302722611f">More...</a><br/></td></tr>
<tr class="separator:aac4707f84c6dc5c269f147302722611f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">staticDumpClassName</a> ()</td></tr>
<tr class="memdesc:ga7399688afb3116ea838d6b2ae1015cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine the type of a variable at compilation time.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">More...</a><br/></td></tr>
<tr class="separator:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga8815c7b8fe5d503b3f10d45ee197ba34">staticDumpClassName</a> (T)</td></tr>
<tr class="separator:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaae39c2a7066e6a24ff172e5471939ae"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aaae39c2a7066e6a24ff172e5471939ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aaae39c2a7066e6a24ff172e5471939ae">absDiff</a> (A const &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, B const &amp;b)</td></tr>
<tr class="memdesc:aaae39c2a7066e6a24ff172e5471939ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the difference between two values.  <a href="#aaae39c2a7066e6a24ff172e5471939ae">More...</a><br/></td></tr>
<tr class="separator:aaae39c2a7066e6a24ff172e5471939ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Span helper functions</div></td></tr>
<tr class="memitem:a72a30797c98a8c53b51848fcfd82700d"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:a72a30797c98a8c53b51848fcfd82700d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a72a30797c98a8c53b51848fcfd82700d">make_span</a> (BIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>, EIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>)</td></tr>
<tr class="memdesc:a72a30797c98a8c53b51848fcfd82700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span from specified iterators (can use constructor instead).  <a href="#a72a30797c98a8c53b51848fcfd82700d">More...</a><br/></td></tr>
<tr class="separator:a72a30797c98a8c53b51848fcfd82700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bb447f8910e14763c8273cb72ca0a1"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:a47bb447f8910e14763c8273cb72ca0a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a47bb447f8910e14763c8273cb72ca0a1">make_span</a> (Cont &amp;cont)</td></tr>
<tr class="memdesc:a47bb447f8910e14763c8273cb72ca0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span from a container type.  <a href="#a47bb447f8910e14763c8273cb72ca0a1">More...</a><br/></td></tr>
<tr class="separator:a47bb447f8910e14763c8273cb72ca0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e70798d0a3cc7f9b4d294b2b616a8a"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ae9e70798d0a3cc7f9b4d294b2b616a8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae9e70798d0a3cc7f9b4d294b2b616a8a">make_const_span</a> (Cont &amp;cont)</td></tr>
<tr class="memdesc:ae9e70798d0a3cc7f9b4d294b2b616a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span with constant iterator access from a container type.  <a href="#ae9e70798d0a3cc7f9b4d294b2b616a8a">More...</a><br/></td></tr>
<tr class="separator:ae9e70798d0a3cc7f9b4d294b2b616a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adapted span helper functions</div></td></tr>
<tr class="memitem:ab9b7f1582941ed1c7c4eaf5f5eb26903"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter , typename Adaptor &gt; </td></tr>
<tr class="memitem:ab9b7f1582941ed1c7c4eaf5f5eb26903"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">make_adapted_span</a> (BIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>, EIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>, Adaptor &amp;&amp;adaptor)</td></tr>
<tr class="separator:ab9b7f1582941ed1c7c4eaf5f5eb26903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65416c3fa16554ba175c505293ea081f"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Adaptor &gt; </td></tr>
<tr class="memitem:a65416c3fa16554ba175c505293ea081f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a65416c3fa16554ba175c505293ea081f">make_adapted_span</a> (Cont &amp;cont, Adaptor &amp;&amp;adaptor)</td></tr>
<tr class="memdesc:a65416c3fa16554ba175c505293ea081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span from specified collection via an adaptor.  <a href="#a65416c3fa16554ba175c505293ea081f">More...</a><br/></td></tr>
<tr class="separator:a65416c3fa16554ba175c505293ea081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51696cc45fda3ac2b4336f39639d6685"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Adaptor &gt; </td></tr>
<tr class="memitem:a51696cc45fda3ac2b4336f39639d6685"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a51696cc45fda3ac2b4336f39639d6685">make_adapted_const_span</a> (Cont &amp;cont, Adaptor &amp;&amp;adaptor)</td></tr>
<tr class="memdesc:a51696cc45fda3ac2b4336f39639d6685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates constant iteration span from specified collection via an adaptor.  <a href="#a51696cc45fda3ac2b4336f39639d6685">More...</a><br/></td></tr>
<tr class="separator:a51696cc45fda3ac2b4336f39639d6685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transformed span helper functions</div></td></tr>
<tr class="memitem:ad93ad1c533f5f788da7639764cb9518b"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter , typename Op &gt; </td></tr>
<tr class="memitem:ad93ad1c533f5f788da7639764cb9518b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">make_transformed_span</a> (BIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a>, EIter <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a>, Op &amp;&amp;op)</td></tr>
<tr class="separator:ad93ad1c533f5f788da7639764cb9518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae61d7c3bc5e105cd93d9c1f26113b2"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Op &gt; </td></tr>
<tr class="memitem:aeae61d7c3bc5e105cd93d9c1f26113b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aeae61d7c3bc5e105cd93d9c1f26113b2">make_transformed_span</a> (Cont &amp;cont, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:aeae61d7c3bc5e105cd93d9c1f26113b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span from specified collection via an adaptor.  <a href="#aeae61d7c3bc5e105cd93d9c1f26113b2">More...</a><br/></td></tr>
<tr class="separator:aeae61d7c3bc5e105cd93d9c1f26113b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a968a7f3f63b6472274f83a2f29b39"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Op &gt; </td></tr>
<tr class="memitem:a72a968a7f3f63b6472274f83a2f29b39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a72a968a7f3f63b6472274f83a2f29b39">make_transformed_const_span</a> (Cont &amp;cont, Op &amp;&amp;op)</td></tr>
<tr class="separator:a72a968a7f3f63b6472274f83a2f29b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C++ standard library customization for user-defined classes.</div></td></tr>
<tr class="memitem:ga3bb735c2329d4f88fa7e771cd92f8bdf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3bb735c2329d4f88fa7e771cd92f8bdf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga3bb735c2329d4f88fa7e771cd92f8bdf">to_string</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:ga3bb735c2329d4f88fa7e771cd92f8bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::to_string</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga3bb735c2329d4f88fa7e771cd92f8bdf">More...</a><br/></td></tr>
<tr class="separator:ga3bb735c2329d4f88fa7e771cd92f8bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624a6c8d8a7c2d3746a644f8cc1c1efe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga624a6c8d8a7c2d3746a644f8cc1c1efe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">begin</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:ga624a6c8d8a7c2d3746a644f8cc1c1efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::begin</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">More...</a><br/></td></tr>
<tr class="separator:ga624a6c8d8a7c2d3746a644f8cc1c1efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d0cd0cbac37bc1ca4c84daf5343973"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1d0cd0cbac37bc1ca4c84daf5343973"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">end</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:gaa1d0cd0cbac37bc1ca4c84daf5343973"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::end</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">More...</a><br/></td></tr>
<tr class="separator:gaa1d0cd0cbac37bc1ca4c84daf5343973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86323ba217da6394bf4e5dae37db1bb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga86323ba217da6394bf4e5dae37db1bb5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga86323ba217da6394bf4e5dae37db1bb5">cbegin</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:ga86323ba217da6394bf4e5dae37db1bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::cbegin</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga86323ba217da6394bf4e5dae37db1bb5">More...</a><br/></td></tr>
<tr class="separator:ga86323ba217da6394bf4e5dae37db1bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4288f30cfde6d98d0f8faf9a386f86d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4288f30cfde6d98d0f8faf9a386f86d0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga4288f30cfde6d98d0f8faf9a386f86d0">cend</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:ga4288f30cfde6d98d0f8faf9a386f86d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::cend</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga4288f30cfde6d98d0f8faf9a386f86d0">More...</a><br/></td></tr>
<tr class="separator:ga4288f30cfde6d98d0f8faf9a386f86d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac583f06256b912500def4d6394b53add"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac583f06256b912500def4d6394b53add"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gac583f06256b912500def4d6394b53add">size</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:gac583f06256b912500def4d6394b53add"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::size</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gac583f06256b912500def4d6394b53add">More...</a><br/></td></tr>
<tr class="separator:gac583f06256b912500def4d6394b53add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b966025fd64bc06286a275664d957"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e3b966025fd64bc06286a275664d957"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga4e3b966025fd64bc06286a275664d957">empty</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:ga4e3b966025fd64bc06286a275664d957"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-aware version of <code>std::empty</code>.  <a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga4e3b966025fd64bc06286a275664d957">More...</a><br/></td></tr>
<tr class="separator:ga4e3b966025fd64bc06286a275664d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bec3c9c2816248e4c948861817ed0f"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:ga99bec3c9c2816248e4c948861817ed0f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga99bec3c9c2816248e4c948861817ed0f">get</a> (T &amp;&amp;obj)</td></tr>
<tr class="separator:ga99bec3c9c2816248e4c948861817ed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel iterations</div></td></tr>
<tr class="memitem:a3efdd3910e740873b4247e10e9884cf5"><td class="memTemplParams" colspan="2">template&lt;std::size_t Lead, typename... Iterables&gt; </td></tr>
<tr class="memitem:a3efdd3910e740873b4247e10e9884cf5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5">zip</a> (Iterables &amp;&amp;...iterables)</td></tr>
<tr class="memdesc:a3efdd3910e740873b4247e10e9884cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range-for loop helper iterating across many collections at the same time.  <a href="#a3efdd3910e740873b4247e10e9884cf5">More...</a><br/></td></tr>
<tr class="separator:a3efdd3910e740873b4247e10e9884cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce414074cb3fa1f450751da2e8f871"><td class="memTemplParams" colspan="2">template&lt;typename... Iterables&gt; </td></tr>
<tr class="memitem:a3fce414074cb3fa1f450751da2e8f871"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3fce414074cb3fa1f450751da2e8f871">zip</a> (Iterables &amp;&amp;...iterables)</td></tr>
<tr class="memdesc:a3fce414074cb3fa1f450751da2e8f871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5" title="Range-for loop helper iterating across many collections at the same time. ">zip()</a></code> with first iterator implicitly leading the iteration.  <a href="#a3fce414074cb3fa1f450751da2e8f871">More...</a><br/></td></tr>
<tr class="separator:a3fce414074cb3fa1f450751da2e8f871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8befbb70f73d7daf0b3133365cf91447"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename D &gt; </td></tr>
<tr class="memitem:a8befbb70f73d7daf0b3133365cf91447"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a8befbb70f73d7daf0b3133365cf91447">CreateAssnD</a> (art::Event &amp;evt, art::Assns&lt; T, U, D &gt; &amp;assn, size_t first_index, size_t second_index, typename art::Assns&lt; T, U, D &gt;::data_t &amp;&amp;data)</td></tr>
<tr class="memdesc:a8befbb70f73d7daf0b3133365cf91447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single one-to-one association with associated data.  <a href="#a8befbb70f73d7daf0b3133365cf91447">More...</a><br/></td></tr>
<tr class="separator:a8befbb70f73d7daf0b3133365cf91447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d24ddf98f38f4c788b13084304736c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename D &gt; </td></tr>
<tr class="memitem:a3d24ddf98f38f4c788b13084304736c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3d24ddf98f38f4c788b13084304736c8">CreateAssnD</a> (art::Event &amp;evt, art::Assns&lt; T, U, D &gt; &amp;assn, size_t first_index, size_t second_index, typename art::Assns&lt; T, U, D &gt;::data_t const &amp;data)</td></tr>
<tr class="separator:a3d24ddf98f38f4c788b13084304736c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple mathematical functions</div></td></tr>
<tr class="memitem:a97e6c3458c743f7f13ec261c7c5fbd4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97e6c3458c743f7f13ec261c7c5fbd4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a97e6c3458c743f7f13ec261c7c5fbd4c">abs</a> (T v)</td></tr>
<tr class="memdesc:a97e6c3458c743f7f13ec261c7c5fbd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the argument.  <a href="#a97e6c3458c743f7f13ec261c7c5fbd4c">More...</a><br/></td></tr>
<tr class="separator:a97e6c3458c743f7f13ec261c7c5fbd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204cc1fffeab061e648e9d93b2488c44"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a204cc1fffeab061e648e9d93b2488c44"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a204cc1fffeab061e648e9d93b2488c44">sqr</a> (T <a class="el" href="../../d1/d01/singles_8fcl.html#aa2441c6f4af6ae1d48f43c716144deac">x</a>)</td></tr>
<tr class="memdesc:a204cc1fffeab061e648e9d93b2488c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">More efficient square function than pow(x,2)  <a href="#a204cc1fffeab061e648e9d93b2488c44">More...</a><br/></td></tr>
<tr class="separator:a204cc1fffeab061e648e9d93b2488c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e536f1d793a874fa1e25c4012cd071"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51e536f1d793a874fa1e25c4012cd071"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a51e536f1d793a874fa1e25c4012cd071">cube</a> (T <a class="el" href="../../d1/d01/singles_8fcl.html#aa2441c6f4af6ae1d48f43c716144deac">x</a>)</td></tr>
<tr class="memdesc:a51e536f1d793a874fa1e25c4012cd071"><td class="mdescLeft">&#160;</td><td class="mdescRight">More efficient cube function than pow(x,3)  <a href="#a51e536f1d793a874fa1e25c4012cd071">More...</a><br/></td></tr>
<tr class="separator:a51e536f1d793a874fa1e25c4012cd071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c558614ad447b70894ec6e7456f94ae"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c558614ad447b70894ec6e7456f94ae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a7c558614ad447b70894ec6e7456f94ae">ipow</a> (T <a class="el" href="../../d1/d01/singles_8fcl.html#aa2441c6f4af6ae1d48f43c716144deac">x</a>, unsigned int <a class="el" href="../../d0/d99/find__fhicl_8sh.html#a1bfbd78e0d8a2bc06df6cee466cca51a">n</a>)</td></tr>
<tr class="memdesc:a7c558614ad447b70894ec6e7456f94ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">More efficient exponentiation function than pow(x,n) for small n.  <a href="#a7c558614ad447b70894ec6e7456f94ae">More...</a><br/></td></tr>
<tr class="separator:a7c558614ad447b70894ec6e7456f94ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f636f1c380effa32255a286e631d4c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa2f636f1c380effa32255a286e631d4c">pythag</a> (double <a class="el" href="../../d1/d01/singles_8fcl.html#aa2441c6f4af6ae1d48f43c716144deac">x</a>, double <a class="el" href="../../d1/d01/singles_8fcl.html#ad222ca63c3622e98913907e4c7245cd6">y</a>)</td></tr>
<tr class="memdesc:aa2f636f1c380effa32255a286e631d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Euclidean distance  <a href="#aa2f636f1c380effa32255a286e631d4c">More...</a><br/></td></tr>
<tr class="separator:aa2f636f1c380effa32255a286e631d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095598055f1b9dd41c5b01d4fcad34a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a095598055f1b9dd41c5b01d4fcad34a4">pythag</a> (double <a class="el" href="../../d1/d01/singles_8fcl.html#aa2441c6f4af6ae1d48f43c716144deac">x</a>, double <a class="el" href="../../d1/d01/singles_8fcl.html#ad222ca63c3622e98913907e4c7245cd6">y</a>, double <a class="el" href="../../d1/d01/singles_8fcl.html#ab9ea0eaf08525541ae494ea6c1fe669b">z</a>)</td></tr>
<tr class="memdesc:a095598055f1b9dd41c5b01d4fcad34a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D Euclidean distance  <a href="#a095598055f1b9dd41c5b01d4fcad34a4">More...</a><br/></td></tr>
<tr class="separator:a095598055f1b9dd41c5b01d4fcad34a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Create and query associations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>see <a href="https://cdcvs.fnal.gov/redmine/projects/art/wiki/Inter-Product_References">https://cdcvs.fnal.gov/redmine/projects/art/wiki/Inter-Product_References</a> for information about using art::Assns </p>
</div></td></tr>
<tr class="memitem:ad13c097e1cf7b9ec11a25f6dc36827f1"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad13c097e1cf7b9ec11a25f6dc36827f1"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad13c097e1cf7b9ec11a25f6dc36827f1">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:ad13c097e1cf7b9ec11a25f6dc36827f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between a new product and one already in the event.  <a href="#ad13c097e1cf7b9ec11a25f6dc36827f1">More...</a><br/></td></tr>
<tr class="separator:ad13c097e1cf7b9ec11a25f6dc36827f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eb8f4c83e113df6bac4e7370895530"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac9eb8f4c83e113df6bac4e7370895530"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac9eb8f4c83e113df6bac4e7370895530">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t begin_indx, size_t end_indx, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:ac9eb8f4c83e113df6bac4e7370895530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between each of a series of new products and one already in the event.  <a href="#ac9eb8f4c83e113df6bac4e7370895530">More...</a><br/></td></tr>
<tr class="separator:ac9eb8f4c83e113df6bac4e7370895530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cc2145a351349f5c7de1af21f2d7f3"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac9cc2145a351349f5c7de1af21f2d7f3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac9cc2145a351349f5c7de1af21f2d7f3">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, art::Ptr&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn)</td></tr>
<tr class="memdesc:ac9cc2145a351349f5c7de1af21f2d7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between two products already in the event.  <a href="#ac9cc2145a351349f5c7de1af21f2d7f3">More...</a><br/></td></tr>
<tr class="separator:ac9cc2145a351349f5c7de1af21f2d7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71a585050655ac1927bb921c678153"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0e71a585050655ac1927bb921c678153"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a0e71a585050655ac1927bb921c678153">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::PtrVector&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:a0e71a585050655ac1927bb921c678153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between a new product and a PtrVector already in the event.  <a href="#a0e71a585050655ac1927bb921c678153">More...</a><br/></td></tr>
<tr class="separator:a0e71a585050655ac1927bb921c678153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ebbf3738beae652ad4ee3f01305b10"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a31ebbf3738beae652ad4ee3f01305b10"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a31ebbf3738beae652ad4ee3f01305b10">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, art::Ptr&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt; &gt; b, art::Assns&lt; T, U &gt; &amp;assn)</td></tr>
<tr class="memdesc:a31ebbf3738beae652ad4ee3f01305b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between products already in the event.  <a href="#a31ebbf3738beae652ad4ee3f01305b10">More...</a><br/></td></tr>
<tr class="separator:a31ebbf3738beae652ad4ee3f01305b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197d20756eac924c5edfc4b054c8eee9"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a197d20756eac924c5edfc4b054c8eee9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a197d20756eac924c5edfc4b054c8eee9">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt; &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:a197d20756eac924c5edfc4b054c8eee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between a new product and a vector of Ptrs already in the event.  <a href="#a197d20756eac924c5edfc4b054c8eee9">More...</a><br/></td></tr>
<tr class="separator:a197d20756eac924c5edfc4b054c8eee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59317fb6c0aea59a7fc1c56b3129fa0"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac59317fb6c0aea59a7fc1c56b3129fa0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac59317fb6c0aea59a7fc1c56b3129fa0">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; &amp;b, art::Assns&lt; T, U &gt; &amp;assn, size_t startU, size_t endU, size_t indx=UINT_MAX, std::string const &amp;instancea=std::string(), std::string const &amp;instanceb=std::string())</td></tr>
<tr class="memdesc:ac59317fb6c0aea59a7fc1c56b3129fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between new products.  <a href="#ac59317fb6c0aea59a7fc1c56b3129fa0">More...</a><br/></td></tr>
<tr class="separator:ac59317fb6c0aea59a7fc1c56b3129fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05a1cc60264b053f50b58da3f51e480"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab05a1cc60264b053f50b58da3f51e480"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ab05a1cc60264b053f50b58da3f51e480">CreateAssn</a> (art::EDProducer const &amp;prod, art::Event &amp;evt, art::Assns&lt; T, U &gt; &amp;assn, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; &amp;b, size_t indxb=UINT_MAX, size_t indxa=UINT_MAX, std::string const &amp;instancea=std::string(), std::string const &amp;instanceb=std::string())</td></tr>
<tr class="memdesc:ab05a1cc60264b053f50b58da3f51e480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 between new products.  <a href="#ab05a1cc60264b053f50b58da3f51e480">More...</a><br/></td></tr>
<tr class="separator:ab05a1cc60264b053f50b58da3f51e480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6518536abfa795b35343e7dfacb562dd"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6518536abfa795b35343e7dfacb562dd"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; const U * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a6518536abfa795b35343e7dfacb562dd">FindUNotAssociatedToT</a> (art::Handle&lt; U &gt; b, art::Event const &amp;evt, std::string const &amp;label)</td></tr>
<tr class="memdesc:a6518536abfa795b35343e7dfacb562dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all objects of type U that are not associated to objects of type T.  <a href="#a6518536abfa795b35343e7dfacb562dd">More...</a><br/></td></tr>
<tr class="separator:a6518536abfa795b35343e7dfacb562dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ff0b72833fe019616c133817474d2b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac6ff0b72833fe019616c133817474d2b"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac6ff0b72833fe019616c133817474d2b">FindUNotAssociatedToTP</a> (art::Handle&lt; U &gt; b, art::Event const &amp;evt, std::string const &amp;label)</td></tr>
<tr class="memdesc:ac6ff0b72833fe019616c133817474d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all objects of type U that are not associated to objects of type T.  <a href="#ac6ff0b72833fe019616c133817474d2b">More...</a><br/></td></tr>
<tr class="separator:ac6ff0b72833fe019616c133817474d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f954b6e1387f04d37853f5d28d1ad4"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae4f954b6e1387f04d37853f5d28d1ad4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ae4f954b6e1387f04d37853f5d28d1ad4">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:ae4f954b6e1387f04d37853f5d28d1ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between a new product and one already in the event.  <a href="#ae4f954b6e1387f04d37853f5d28d1ad4">More...</a><br/></td></tr>
<tr class="separator:ae4f954b6e1387f04d37853f5d28d1ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64121ddfe053b75a7563b6fd6cdc05a8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a64121ddfe053b75a7563b6fd6cdc05a8"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a64121ddfe053b75a7563b6fd6cdc05a8">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t begin_indx, size_t end_indx, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:a64121ddfe053b75a7563b6fd6cdc05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between each of a series of new products and one already in the event.  <a href="#a64121ddfe053b75a7563b6fd6cdc05a8">More...</a><br/></td></tr>
<tr class="separator:a64121ddfe053b75a7563b6fd6cdc05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1443e17d916ca75562ccc169be8be1"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aab1443e17d916ca75562ccc169be8be1"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aab1443e17d916ca75562ccc169be8be1">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, art::Ptr&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::Ptr&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn)</td></tr>
<tr class="memdesc:aab1443e17d916ca75562ccc169be8be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 association between two products already in the event.  <a href="#aab1443e17d916ca75562ccc169be8be1">More...</a><br/></td></tr>
<tr class="separator:aab1443e17d916ca75562ccc169be8be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d64ae04c7c483ba9ba988ea6b54ad"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aee7d64ae04c7c483ba9ba988ea6b54ad"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aee7d64ae04c7c483ba9ba988ea6b54ad">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, art::PtrVector&lt; U &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:aee7d64ae04c7c483ba9ba988ea6b54ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between a new product and a PtrVector already in the event.  <a href="#aee7d64ae04c7c483ba9ba988ea6b54ad">More...</a><br/></td></tr>
<tr class="separator:aee7d64ae04c7c483ba9ba988ea6b54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4fa012a16b97e7dd57bc92a25166fc"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a7b4fa012a16b97e7dd57bc92a25166fc"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a7b4fa012a16b97e7dd57bc92a25166fc">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, art::Ptr&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt; &gt; b, art::Assns&lt; T, U &gt; &amp;assn)</td></tr>
<tr class="memdesc:a7b4fa012a16b97e7dd57bc92a25166fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between products already in the event.  <a href="#a7b4fa012a16b97e7dd57bc92a25166fc">More...</a><br/></td></tr>
<tr class="separator:a7b4fa012a16b97e7dd57bc92a25166fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c5c22c3452dd45a9573f909e2d26f8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a03c5c22c3452dd45a9573f909e2d26f8"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a03c5c22c3452dd45a9573f909e2d26f8">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; art::Ptr&lt; U &gt; &gt; b, art::Assns&lt; T, U &gt; &amp;assn, size_t indx=UINT_MAX, std::string const &amp;<a class="el" href="../../d4/d97/BlipMaker__module_8cc.html#a8b8f5c7804b8eb6cd2f4a20f9ef30d41">instance</a>=std::string())</td></tr>
<tr class="memdesc:a03c5c22c3452dd45a9573f909e2d26f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between a new product and a vector of Ptrs already in the event.  <a href="#a03c5c22c3452dd45a9573f909e2d26f8">More...</a><br/></td></tr>
<tr class="separator:a03c5c22c3452dd45a9573f909e2d26f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f4e842bd95578d29f8e0a17cf12acd"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad0f4e842bd95578d29f8e0a17cf12acd"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad0f4e842bd95578d29f8e0a17cf12acd">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; &amp;b, art::Assns&lt; T, U &gt; &amp;assn, size_t startU, size_t endU, size_t indx=UINT_MAX, std::string const &amp;instancea=std::string(), std::string const &amp;instanceb=std::string())</td></tr>
<tr class="memdesc:ad0f4e842bd95578d29f8e0a17cf12acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to many association between new products.  <a href="#ad0f4e842bd95578d29f8e0a17cf12acd">More...</a><br/></td></tr>
<tr class="separator:ad0f4e842bd95578d29f8e0a17cf12acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1778565e1c5c9e755cd8c80581ffbccf"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1778565e1c5c9e755cd8c80581ffbccf"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a1778565e1c5c9e755cd8c80581ffbccf">CreateAssn</a> (art::EDFilter const &amp;prod, art::Event &amp;evt, art::Assns&lt; T, U &gt; &amp;assn, std::vector&lt; T &gt; &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, std::vector&lt; U &gt; &amp;b, size_t indxb=UINT_MAX, size_t indxa=UINT_MAX, std::string const &amp;instancea=std::string(), std::string const &amp;instanceb=std::string())</td></tr>
<tr class="memdesc:a1778565e1c5c9e755cd8c80581ffbccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1 to 1 between new products.  <a href="#a1778565e1c5c9e755cd8c80581ffbccf">More...</a><br/></td></tr>
<tr class="separator:a1778565e1c5c9e755cd8c80581ffbccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a538eae3ddf11b9a4165269e6caae47d6"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename Func , typename UntilFunc &gt; </td></tr>
<tr class="memitem:a538eae3ddf11b9a4165269e6caae47d6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a538eae3ddf11b9a4165269e6caae47d6">SampledFunction&lt; XType, XType &gt;</a></td></tr>
<tr class="separator:a538eae3ddf11b9a4165269e6caae47d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dcc69829d516683281c361980940922"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ga7dcc69829d516683281c361980940922"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922">always_false_v</a> = false</td></tr>
<tr class="memdesc:ga7dcc69829d516683281c361980940922"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated constant, always false.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922">More...</a><br/></td></tr>
<tr class="separator:ga7dcc69829d516683281c361980940922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4d0dfc8abee84fd9607cf5fc251412d8">always_true_v</a> = <a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#af8bc618309fb2d0f55f7f5ae0760b466">true</a></td></tr>
<tr class="memdesc:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template constant always true.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga4d0dfc8abee84fd9607cf5fc251412d8">More...</a><br/></td></tr>
<tr class="separator:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t StartFrom, typename... Types&gt; </td></tr>
<tr class="memitem:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga07ab55a3a8bc171ede71bf7aac7528be">find_next_type_v</a> = <a class="el" href="../../d9/d02/structutil_1_1find__next__type.html">find_next_type</a>&lt;T, StartFrom, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccd6e233deec6493f880ceefe42ecca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gaaccd6e233deec6493f880ceefe42ecca"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaaccd6e233deec6493f880ceefe42ecca">find_type_v</a> = <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668">find_type</a>&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:gaaccd6e233deec6493f880ceefe42ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c1cae81194565fb7be9409851d661a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga1c1cae81194565fb7be9409851d661a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga1c1cae81194565fb7be9409851d661a5">is_any_of_v</a> = <a class="el" href="../../d7/d95/structutil_1_1is__any__of.html">is_any_of</a>&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:ga1c1cae81194565fb7be9409851d661a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <code>T</code> is among the specified <code>Types</code> (see <code><a class="el" href="../../d7/d95/structutil_1_1is__any__of.html" title="Trait: whether T is among the specified Types. ">util::is_any_of</a></code>).  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga1c1cae81194565fb7be9409851d661a5">More...</a><br/></td></tr>
<tr class="separator:ga1c1cae81194565fb7be9409851d661a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gace903934bdebaf7027a4a0c3e4fb974f">is_same_decay_v</a> = std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</td></tr>
<tr class="memdesc:gace903934bdebaf7027a4a0c3e4fb974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <code>T</code> and <code>U</code> are the same type, after being applied <code>std::decay</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#gace903934bdebaf7027a4a0c3e4fb974f">More...</a><br/></td></tr>
<tr class="separator:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a962e29ff7d7c204c0780bef45bf38"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; typename Template, typename T &gt; </td></tr>
<tr class="memitem:ga50a962e29ff7d7c204c0780bef45bf38"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga50a962e29ff7d7c204c0780bef45bf38">is_instance_of_v</a> = <a class="el" href="../../de/d21/structutil_1_1is__instance__of.html">is_instance_of</a>&lt;Template, T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:ga50a962e29ff7d7c204c0780bef45bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab303181a8753278066bdfddb08ff1241"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab303181a8753278066bdfddb08ff1241"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gab303181a8753278066bdfddb08ff1241">is_STLarray_v</a> = <a class="el" href="../../df/d87/structutil_1_1is__STLarray.html">is_STLarray</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:gab303181a8753278066bdfddb08ff1241"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant describing whether the specified type is a STL array.  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gab303181a8753278066bdfddb08ff1241">More...</a><br/></td></tr>
<tr class="separator:gab303181a8753278066bdfddb08ff1241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd112d73ac3e66df48cc1d2b003281c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd112d73ac3e66df48cc1d2b003281c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gacd112d73ac3e66df48cc1d2b003281c3">is_reference_wrapper_v</a> = <a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga9947403b20eeda8700f1c8dcc075a2f4">is_reference_wrapper</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:gacd112d73ac3e66df48cc1d2b003281c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant describing whether the specified type is a <code>std::reference_wrapper</code>.  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gacd112d73ac3e66df48cc1d2b003281c3">More...</a><br/></td></tr>
<tr class="separator:gacd112d73ac3e66df48cc1d2b003281c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce4e3f3a8cdfc0e4169a0796b2f902e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0ce4e3f3a8cdfc0e4169a0796b2f902e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga0ce4e3f3a8cdfc0e4169a0796b2f902e">is_unique_ptr_v</a> = <a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga5b435defed53818920121ade83c2d8fd">is_unique_ptr</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:ga0ce4e3f3a8cdfc0e4169a0796b2f902e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant describing whether the specified type is a <code>std::unique_ptr</code>.  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga0ce4e3f3a8cdfc0e4169a0796b2f902e">More...</a><br/></td></tr>
<tr class="separator:ga0ce4e3f3a8cdfc0e4169a0796b2f902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5326e8ae43fbc097f8bdcd00f080a7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf5326e8ae43fbc097f8bdcd00f080a7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gaf5326e8ae43fbc097f8bdcd00f080a7e">is_character_type_v</a> = <a class="el" href="../../d0/d12/structutil_1_1is__character__type.html">is_character_type</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:gaf5326e8ae43fbc097f8bdcd00f080a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether type <code>T</code> is a character type (see <code><a class="el" href="../../d0/d12/structutil_1_1is__character__type.html" title="Trait: whether type T is a character type. ">util::is_character_type</a></code>).  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#gaf5326e8ae43fbc097f8bdcd00f080a7e">More...</a><br/></td></tr>
<tr class="separator:gaf5326e8ae43fbc097f8bdcd00f080a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f99eddc2363dbe0a000f161275a5f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga80f99eddc2363dbe0a000f161275a5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga80f99eddc2363dbe0a000f161275a5f9">is_string_type_v</a> = <a class="el" href="../../d6/def/structutil_1_1is__string__type.html">is_string_type</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:ga80f99eddc2363dbe0a000f161275a5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether type <code>T</code> is a character string type (see <code><a class="el" href="../../d6/def/structutil_1_1is__string__type.html" title="Trait: whether type T is a character string type. ">util::is_string_type</a></code>).  <a href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga80f99eddc2363dbe0a000f161275a5f9">More...</a><br/></td></tr>
<tr class="separator:ga80f99eddc2363dbe0a000f161275a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289097258cc694c349c8370fa79674f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga289097258cc694c349c8370fa79674f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga289097258cc694c349c8370fa79674f1">is_basic_string_type_v</a> = <a class="el" href="../../d1/d54/structutil_1_1is__basic__string__type.html">is_basic_string_type</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:ga289097258cc694c349c8370fa79674f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ec33128ccff5f4002c22f47ac0e85b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga45ec33128ccff5f4002c22f47ac0e85b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d66/group__MetaprogrammingTypeIdentification.html#ga45ec33128ccff5f4002c22f47ac0e85b">is_basic_string_view_type_v</a> = <a class="el" href="../../d8/d01/structutil_1_1is__basic__string__view__type.html">is_basic_string_view_type</a>&lt;T&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:ga45ec33128ccff5f4002c22f47ac0e85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51462247f4e85aa4c2c9bb66f0c0b1c"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac51462247f4e85aa4c2c9bb66f0c0b1c">kGeVToElectrons</a> = 4.237e7</td></tr>
<tr class="memdesc:ac51462247f4e85aa4c2c9bb66f0c0b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">23.6eV per ion pair, 1e9 eV/GeV  <a href="#ac51462247f4e85aa4c2c9bb66f0c0b1c">More...</a><br/></td></tr>
<tr class="separator:ac51462247f4e85aa4c2c9bb66f0c0b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5741235f9443139fb6ca5063a34551b7"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5741235f9443139fb6ca5063a34551b7">kc</a> = 29.9792458</td></tr>
<tr class="memdesc:a5741235f9443139fb6ca5063a34551b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speed of light in vacuum in LArSoft units [cm/ns].  <a href="#a5741235f9443139fb6ca5063a34551b7">More...</a><br/></td></tr>
<tr class="separator:a5741235f9443139fb6ca5063a34551b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce2950cacd9c941568cc2a8ac1a1554"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a7ce2950cacd9c941568cc2a8ac1a1554">kMeterToCentimeter</a> = 1.e2</td></tr>
<tr class="memdesc:a7ce2950cacd9c941568cc2a8ac1a1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 m = 100 cm  <a href="#a7ce2950cacd9c941568cc2a8ac1a1554">More...</a><br/></td></tr>
<tr class="separator:a7ce2950cacd9c941568cc2a8ac1a1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d408b27c811066b7b0ea4446b01fac9"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a6d408b27c811066b7b0ea4446b01fac9">kCentimeterToMeter</a> = 1./<a class="el" href="../../d6/d72/namespaceutil.html#a7ce2950cacd9c941568cc2a8ac1a1554">kMeterToCentimeter</a></td></tr>
<tr class="separator:a6d408b27c811066b7b0ea4446b01fac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f215c30f5cda82c16d0f017ff610716"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a1f215c30f5cda82c16d0f017ff610716">kMeterToKilometer</a> = 1.<a class="el" href="../../d9/dd2/selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>-3</td></tr>
<tr class="memdesc:a1f215c30f5cda82c16d0f017ff610716"><td class="mdescLeft">&#160;</td><td class="mdescRight">1000 m = 1 km  <a href="#a1f215c30f5cda82c16d0f017ff610716">More...</a><br/></td></tr>
<tr class="separator:a1f215c30f5cda82c16d0f017ff610716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758fc2ccbefd8219b384e1d6554bfb26"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a758fc2ccbefd8219b384e1d6554bfb26">kKilometerToMeter</a> = 1./<a class="el" href="../../d6/d72/namespaceutil.html#a1f215c30f5cda82c16d0f017ff610716">kMeterToKilometer</a></td></tr>
<tr class="separator:a758fc2ccbefd8219b384e1d6554bfb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1068ce8202a308d53b640e04501ffbc"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#aa1068ce8202a308d53b640e04501ffbc">keVToMeV</a> = 1.<a class="el" href="../../d9/dd2/selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>-6</td></tr>
<tr class="memdesc:aa1068ce8202a308d53b640e04501ffbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">1e6 eV = 1 MeV  <a href="#aa1068ce8202a308d53b640e04501ffbc">More...</a><br/></td></tr>
<tr class="separator:aa1068ce8202a308d53b640e04501ffbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc85ed7d1d7f6afbd18965a1750f51c"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a5bc85ed7d1d7f6afbd18965a1750f51c">kMeVToeV</a> = 1./<a class="el" href="../../d6/d72/namespaceutil.html#aa1068ce8202a308d53b640e04501ffbc">keVToMeV</a></td></tr>
<tr class="separator:a5bc85ed7d1d7f6afbd18965a1750f51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85007be2ce41bf247364673c302f8a5b"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a85007be2ce41bf247364673c302f8a5b">kBogusD</a> = -999.</td></tr>
<tr class="memdesc:a85007be2ce41bf247364673c302f8a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">obviously bogus double value  <a href="#a85007be2ce41bf247364673c302f8a5b">More...</a><br/></td></tr>
<tr class="separator:a85007be2ce41bf247364673c302f8a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c76e948783adbe3ad07166d4d5996"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a182c76e948783adbe3ad07166d4d5996">kBogusI</a> = -999</td></tr>
<tr class="memdesc:a182c76e948783adbe3ad07166d4d5996"><td class="mdescLeft">&#160;</td><td class="mdescRight">obviously bogus integer value  <a href="#a182c76e948783adbe3ad07166d4d5996">More...</a><br/></td></tr>
<tr class="separator:a182c76e948783adbe3ad07166d4d5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0796054a3befe89ee1c27998155957f"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ab0796054a3befe89ee1c27998155957f">kBogusF</a> = -999.</td></tr>
<tr class="memdesc:ab0796054a3befe89ee1c27998155957f"><td class="mdescLeft">&#160;</td><td class="mdescRight">obviously bogus float value  <a href="#ab0796054a3befe89ee1c27998155957f">More...</a><br/></td></tr>
<tr class="separator:ab0796054a3befe89ee1c27998155957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9765743fc3591aa3b7952363ed71e13"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ad9765743fc3591aa3b7952363ed71e13">quietCompiler</a> = <a class="el" href="../../d6/d72/namespaceutil.html#a85007be2ce41bf247364673c302f8a5b">kBogusD</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a182c76e948783adbe3ad07166d4d5996">kBogusI</a>*<a class="el" href="../../d6/d72/namespaceutil.html#ab0796054a3befe89ee1c27998155957f">kBogusF</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a4b8026403bd9c925808117559ae3f6f5">kRecombA</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a899d2fb7f1f3de8da07bdae7431db42e">kRecombk</a>*<a class="el" href="../../d6/d72/namespaceutil.html#ac51462247f4e85aa4c2c9bb66f0c0b1c">kGeVToElectrons</a></td></tr>
<tr class="separator:ad9765743fc3591aa3b7952363ed71e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8116a4e104ed8d7ea509f41c63090"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a09c8116a4e104ed8d7ea509f41c63090">kINVALID_DOUBLE</a> = std::numeric_limits&lt;Double_t&gt;::max()</td></tr>
<tr class="separator:a09c8116a4e104ed8d7ea509f41c63090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2ce9dc82a9f5dc3fbb59ea5583e30"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/d72/structutil_1_1RangeForWrapperTag.html">RangeForWrapperTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">range_for</a></td></tr>
<tr class="separator:a90a2ce9dc82a9f5dc3fbb59ea5583e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25797fa292a1c406715a11f5935d6571"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga25797fa292a1c406715a11f5935d6571"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga25797fa292a1c406715a11f5935d6571">index_of_extracted_type_v</a> = <a class="el" href="../../d9/d32/structutil_1_1index__of__extracted__type.html">index_of_extracted_type</a>&lt;Extractor, Target, Tuple&gt;()</td></tr>
<tr class="memdesc:ga25797fa292a1c406715a11f5935d6571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code><a class="el" href="../../d9/d32/structutil_1_1index__of__extracted__type.html" title="Returns the index of the element in Tuple with the specified type. ">index_of_extracted_type</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga25797fa292a1c406715a11f5935d6571">More...</a><br/></td></tr>
<tr class="separator:ga25797fa292a1c406715a11f5935d6571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40203ab7eca2c27d91e4efb23bd7863"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:gaa40203ab7eca2c27d91e4efb23bd7863"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gaa40203ab7eca2c27d91e4efb23bd7863">index_of_type_v</a> = <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga5ad61220544ced8dd6c9295a8a5c8fb9">index_of_type</a>&lt;Target, Tuple&gt;()</td></tr>
<tr class="memdesc:gaa40203ab7eca2c27d91e4efb23bd7863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>index_of_type</code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gaa40203ab7eca2c27d91e4efb23bd7863">More...</a><br/></td></tr>
<tr class="separator:gaa40203ab7eca2c27d91e4efb23bd7863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19bcf9e0e6c564b8beb6d525c8ff042f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga19bcf9e0e6c564b8beb6d525c8ff042f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga19bcf9e0e6c564b8beb6d525c8ff042f">has_extracted_type_v</a> = <a class="el" href="../../dc/d2a/structutil_1_1has__extracted__type.html">has_extracted_type</a>&lt;Extractor, Target, Tuple&gt;()</td></tr>
<tr class="memdesc:ga19bcf9e0e6c564b8beb6d525c8ff042f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code><a class="el" href="../../dc/d2a/structutil_1_1has__extracted__type.html" title="Trait holding whether an element in Tuple type contains Target. ">has_extracted_type</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga19bcf9e0e6c564b8beb6d525c8ff042f">More...</a><br/></td></tr>
<tr class="separator:ga19bcf9e0e6c564b8beb6d525c8ff042f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf242cb4aeb18d219ac61b45c08b65d"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:gabdf242cb4aeb18d219ac61b45c08b65d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gabdf242cb4aeb18d219ac61b45c08b65d">has_type_v</a> = <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gad5212f210676e5a04fc33b4883d15a4c">has_type</a>&lt;Target, Tuple&gt;()</td></tr>
<tr class="memdesc:gabdf242cb4aeb18d219ac61b45c08b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_type</code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gabdf242cb4aeb18d219ac61b45c08b65d">More...</a><br/></td></tr>
<tr class="separator:gabdf242cb4aeb18d219ac61b45c08b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f44ab9c4f103e4d1516a78f62fc023"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Tuple &gt; </td></tr>
<tr class="memitem:gab1f44ab9c4f103e4d1516a78f62fc023"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gab1f44ab9c4f103e4d1516a78f62fc023">has_duplicate_extracted_types_v</a> = <a class="el" href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html">has_duplicate_extracted_types</a>&lt;Extractor, Tuple&gt;()</td></tr>
<tr class="memdesc:gab1f44ab9c4f103e4d1516a78f62fc023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code><a class="el" href="../../dd/de4/structutil_1_1has__duplicate__extracted__types.html" title="Traits holding whether elements of Tuple have duplicate types. ">has_duplicate_extracted_types</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gab1f44ab9c4f103e4d1516a78f62fc023">More...</a><br/></td></tr>
<tr class="separator:gab1f44ab9c4f103e4d1516a78f62fc023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80722a45535e4446a6082cd224d1c6a9"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga80722a45535e4446a6082cd224d1c6a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga80722a45535e4446a6082cd224d1c6a9">has_duplicate_types_v</a> = <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gab049559e46e277472c3bb4455994fe8e">has_duplicate_types</a>&lt;Tuple&gt;()</td></tr>
<tr class="memdesc:ga80722a45535e4446a6082cd224d1c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_duplicate_types</code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga80722a45535e4446a6082cd224d1c6a9">More...</a><br/></td></tr>
<tr class="separator:ga80722a45535e4446a6082cd224d1c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb34785a91a8f6d743a47e5fd5b44ea7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename...&gt; class Extractor, typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:gadb34785a91a8f6d743a47e5fd5b44ea7"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#gadb34785a91a8f6d743a47e5fd5b44ea7">count_extracted_types_v</a> = <a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html">count_extracted_types</a>&lt;Extractor, Target, Tuple&gt;()</td></tr>
<tr class="memdesc:gadb34785a91a8f6d743a47e5fd5b44ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code><a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html" title="Counts the elements of a tuple-like type containing a Target type. ">count_extracted_types</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#gadb34785a91a8f6d743a47e5fd5b44ea7">More...</a><br/></td></tr>
<tr class="separator:gadb34785a91a8f6d743a47e5fd5b44ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160d39b276b1168e10f48795ef074e0b"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Tuple &gt; </td></tr>
<tr class="memitem:ga160d39b276b1168e10f48795ef074e0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga160d39b276b1168e10f48795ef074e0b">count_types_v</a> = <a class="el" href="../../d2/d70/group__MetaprogrammingGeneral.html#ga94e61d6541b80ca8c4484761a639fd5f">count_types</a>&lt;Target, Tuple&gt;()</td></tr>
<tr class="memdesc:ga160d39b276b1168e10f48795ef074e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code><a class="el" href="../../d8/dd0/structutil_1_1count__extracted__types.html" title="Counts the elements of a tuple-like type containing a Target type. ">count_extracted_types</a></code>.  <a href="../../d2/d70/group__MetaprogrammingGeneral.html#ga160d39b276b1168e10f48795ef074e0b">More...</a><br/></td></tr>
<tr class="separator:ga160d39b276b1168e10f48795ef074e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga162f35f1d3fd56f6b36c16df6f35befc">index_of_tag_v</a> = <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388">index_of_tag</a>&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>index_of_tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga162f35f1d3fd56f6b36c16df6f35befc">More...</a><br/></td></tr>
<tr class="separator:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa82c6620743044d07b345ac498a8a0"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga7fa82c6620743044d07b345ac498a8a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga7fa82c6620743044d07b345ac498a8a0">has_tag_v</a> = <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f">has_tag</a>&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga7fa82c6620743044d07b345ac498a8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_tag</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga7fa82c6620743044d07b345ac498a8a0">More...</a><br/></td></tr>
<tr class="separator:ga7fa82c6620743044d07b345ac498a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12189386f08f62432634a62d649e2ed8"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga12189386f08f62432634a62d649e2ed8"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga12189386f08f62432634a62d649e2ed8">count_tags_v</a> = <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324">count_tags</a>&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga12189386f08f62432634a62d649e2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>count_tags</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga12189386f08f62432634a62d649e2ed8">More...</a><br/></td></tr>
<tr class="separator:ga12189386f08f62432634a62d649e2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga1b44306c24204dd46c99e1fe8a02ad89">has_duplicate_tags_v</a> = <a class="el" href="../../d7/d1f/group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585">has_duplicate_tags</a>&lt;Tuple&gt;()</td></tr>
<tr class="memdesc:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_duplicate_tags</code>.  <a href="../../d7/d1f/group__MetaprogrammingTagged.html#ga1b44306c24204dd46c99e1fe8a02ad89">More...</a><br/></td></tr>
<tr class="separator:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad425aacbd8188919f73375b333a3db"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a3ad425aacbd8188919f73375b333a3db">SQRT_TWO_PI</a> = 2.506628</td></tr>
<tr class="separator:a3ad425aacbd8188919f73375b333a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recombination factor coefficients (NIM).</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See Also</dt><dd>sim::ISCalculationSeparate::CalculateIonizationAndScintillation()</dd></dl>
<p>Recombination factor coefficients come from Nucl.Instrum.Meth.A523:275-286,2004</p>
<ul>
<li><img class="formulaInl" alt="$ dE/dx $" src="../../form_58.png"/> is given by the voxel energy deposition, but have to convert it to MeV/cm from GeV/voxel width</li>
<li>electric field: <img class="formulaInl" alt="$ E $" src="../../form_59.png"/> in kV/cm</li>
<li><img class="formulaInl" alt="$ R = A/(1 + (dE/dx)*k/E) $" src="../../form_60.png"/></li>
<li><img class="formulaInl" alt="$ A = 0.800 \pm 0.003 $" src="../../form_61.png"/></li>
<li><img class="formulaInl" alt="$ k = 0.0486 $" src="../../form_62.png"/> needs to be scaled with Electric field </li>
</ul>
</div></td></tr>
<tr class="memitem:a4b8026403bd9c925808117559ae3f6f5"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a4b8026403bd9c925808117559ae3f6f5">kRecombA</a> = 0.800</td></tr>
<tr class="memdesc:a4b8026403bd9c925808117559ae3f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>A</em> constant.  <a href="#a4b8026403bd9c925808117559ae3f6f5">More...</a><br/></td></tr>
<tr class="separator:a4b8026403bd9c925808117559ae3f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899d2fb7f1f3de8da07bdae7431db42e"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a899d2fb7f1f3de8da07bdae7431db42e">kRecombk</a> = 0.0486</td></tr>
<tr class="separator:a899d2fb7f1f3de8da07bdae7431db42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recombination factor coefficients (modified box, ArguNeuT JINST).</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See Also</dt><dd>sim::ISCalculationSeparate::CalculateIonizationAndScintillation()</dd></dl>
<p>Recombination factor coefficients come from Nucl.Instrum.Meth.A523:275-286,2004</p>
<ul>
<li><img class="formulaInl" alt="$ dE/dx $" src="../../form_58.png"/> is given by the voxel energy deposition, but have to convert it to MeV/cm from GeV/voxel width</li>
<li>electric field: <img class="formulaInl" alt="$ E $" src="../../form_59.png"/> in kV/cm</li>
<li><code>kModBoxB</code> needs to be scaled with the electric field. </li>
</ul>
</div></td></tr>
<tr class="memitem:ac62a2089f10277d70b97c7a396295d32"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#ac62a2089f10277d70b97c7a396295d32">kModBoxA</a> = 0.930</td></tr>
<tr class="memdesc:ac62a2089f10277d70b97c7a396295d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Box Alpha.  <a href="#ac62a2089f10277d70b97c7a396295d32">More...</a><br/></td></tr>
<tr class="separator:ac62a2089f10277d70b97c7a396295d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb09ee269c7c503de7fd8f5313e6267"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d72/namespaceutil.html#a0cb09ee269c7c503de7fd8f5313e6267">kModBoxB</a> = 0.212</td></tr>
<tr class="memdesc:a0cb09ee269c7c503de7fd8f5313e6267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Box Beta in g/(MeV cm)*kV/cm.  <a href="#a0cb09ee269c7c503de7fd8f5313e6267">More...</a><br/></td></tr>
<tr class="separator:a0cb09ee269c7c503de7fd8f5313e6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaa3ef7a171041e419c0e85ce62bd866a9">count_type_in_list</a> = <a class="el" href="../../d1/d10/structutil_1_1details_1_1count__type__in__list__impl.html">details::count_type_in_list_impl</a>&lt; Target, T...&gt;</td></tr>
<tr class="memdesc:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many of the types in <code>T</code> exactly match <code>Target</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#gaa3ef7a171041e419c0e85ce62bd866a9">More...</a><br/></td></tr>
<tr class="separator:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename... T&gt; </td></tr>
<tr class="memitem:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga429c66f884b21f2b6b22c37e8a2769ec">typelist_element_type</a> = std::tuple_element&lt; <a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, std::tuple&lt; T...&gt;&gt;</td></tr>
<tr class="memdesc:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>N</code> type of the type list.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga429c66f884b21f2b6b22c37e8a2769ec">More...</a><br/></td></tr>
<tr class="separator:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876132317188329a32c1f27018f408e8"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename... T&gt; </td></tr>
<tr class="memitem:ga876132317188329a32c1f27018f408e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga876132317188329a32c1f27018f408e8">typelist_element_t</a> = typename <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga429c66f884b21f2b6b22c37e8a2769ec">typelist_element_type</a>&lt; <a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, T...&gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga876132317188329a32c1f27018f408e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>typelist_element_type</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga876132317188329a32c1f27018f408e8">More...</a><br/></td></tr>
<tr class="separator:ga876132317188329a32c1f27018f408e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga830eb5fc4da7eae3e964208f6da0b1ea">type_is_in</a> = <a class="el" href="../../d3/d35/structutil_1_1details_1_1type__is__in__impl.html">details::type_is_in_impl</a>&lt; Target, T...&gt;</td></tr>
<tr class="memdesc:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds whether the <code>Target</code> type is among the ones in the <code>T</code> pack.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga830eb5fc4da7eae3e964208f6da0b1ea">More...</a><br/></td></tr>
<tr class="separator:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad333eee614fb8d78d61393c5a4271f3d"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:gad333eee614fb8d78d61393c5a4271f3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gad333eee614fb8d78d61393c5a4271f3d">count_type_in_list_v</a> = <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaa3ef7a171041e419c0e85ce62bd866a9">count_type_in_list</a>&lt;Target, T...&gt;()</td></tr>
<tr class="memdesc:gad333eee614fb8d78d61393c5a4271f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>count_type_in_list</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#gad333eee614fb8d78d61393c5a4271f3d">More...</a><br/></td></tr>
<tr class="separator:gad333eee614fb8d78d61393c5a4271f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4ecd3b0bc852eef6da2a9e0615ab987f">type_is_in_v</a> = <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga830eb5fc4da7eae3e964208f6da0b1ea">type_is_in</a>&lt;Target, T...&gt;()</td></tr>
<tr class="memdesc:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>type_is_in</code>.  <a href="../../d0/dcf/group__MetaprogrammingBase.html#ga4ecd3b0bc852eef6da2a9e0615ab987f">More...</a><br/></td></tr>
<tr class="separator:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for general, non-LArSoft-specific utilities. </p>
<p>Namespace for general, not LArSoft-specific utilities.</p>
<p>General LArSoft Utilities.</p>
<p>Generic namespace of utility functions generally independent of LArSoft.</p>
<p>Some physical constants are also included here. As a reminder, the "standard" units in LArSoft are:</p>
<ul>
<li>energy: GeV</li>
<li>time: ns</li>
<li>space: cm</li>
</ul>
<p><a class="el" href="../../d6/d57/classutil_1_1SumSecondFunction.html">SumSecondFunction</a> 28-Jul-2009 William Seligman <a href="#" onclick="location.href='mai'+'lto:'+'sel'+'ig'+'man'+'@n'+'evi'+'s.'+'col'+'um'+'bia'+'.e'+'du'; return false;">selig<span style="display: none;">.nosp@m.</span>man@<span style="display: none;">.nosp@m.</span>nevis<span style="display: none;">.nosp@m.</span>.col<span style="display: none;">.nosp@m.</span>umbia<span style="display: none;">.nosp@m.</span>.edu</a> When using STL, maps, and the std::accumulate function, there's one function I keep coding over and over again: accumulate the second member of a pair.</p>
<p>To save myself time (and others who know and use STL), here's a complete STL-compatible implementation of that function. To use it, assume you have an object:</p>
<p>std::map&lt;K,V&gt; myMap;</p>
<p>To sum all the V's in the map:</p>
<p>V sum = std::accumulate( <a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">myMap.begin()</a>,<a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">myMap.end()</a>,<a class="el" href="../../d2/dbd/trackfinderalgorithms_8fcl.html#a7171bc20f34cc335ec48c7f2e2615e6f">V()</a>,SumSecondFunction&lt;K,V&gt;() );</p>
<p>(Yes, I know there are other, better ways to do this, if one has access to BOOST. Unfortunately, we're not supposed to use BOOST in LArSoft, since as of Jul-2009 it's not universally installed on FNAL machines.)</p>
<p><a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a> 17-Apr-2008 William Seligman <a href="#" onclick="location.href='mai'+'lto:'+'sel'+'ig'+'man'+'@n'+'evi'+'s.'+'col'+'um'+'bia'+'.e'+'du'; return false;">selig<span style="display: none;">.nosp@m.</span>man@<span style="display: none;">.nosp@m.</span>nevis<span style="display: none;">.nosp@m.</span>.col<span style="display: none;">.nosp@m.</span>umbia<span style="display: none;">.nosp@m.</span>.edu</a></p>
<p>This class is an implementation of a concept discussion in "Effective STL" by Scott Meyers:</p>
<p>STL maps are useful because their contents are always sorted, so they're effective for fast searches. However, in almost every other respect vectors are superior: They take up less space, and they use random-access iterators.</p>
<p>This class implements "sorted vector maps," that is, an STL-style map implemented as a sorted STL vector of pairs. I've done my best to implement all aspects of the std::map interface in this class, with some additions; if you've defined the following:</p>
<p>VectorMap&lt;key_type, data_type&gt; svm;</p>
<ul>
<li>svm(i) will return the "i-th" value in the map; that is, "i" is a numeric index instead of a key. (Note the use of parenthesis instead of square brackets.) This is a boon to physicists, most of whom couldn't tell an iterator from a hole in the wall.</li>
<li>svm.Key(i) will return the "i-th" key in the map.</li>
<li>svm.Data(i) will return the same result as svm(i).</li>
<li>svm[key_type] will now return the corresponding data_type in both const and non-const contexts. However, if you ask for svm[key] and the key isn't in the map, and you're in a const context, the routine will throw an out-of-range exception.</li>
</ul>
<p>INCREDIBLY IMPORTANT NOTE: The "key type" of a <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a> cannot be a "const" type (unlike maps); it won't even compile. When you do an insert, the underlying vector has to move things around within its list, and it uses the assignment operator=() (or "vector{i+1)=vector(i)" if you like). You can't do that if either the key or the data is const.</p>
<p>As with a map, there's no way to insert items at a specific location in a <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a>. The insertion methods (including operator[]) all operate on a sorted sequence according to the key. Because of this, insertions take a long time.</p>
<p>However, for our processing, this doesn't matter much; for almost all our maps, we typically have:</p>
<ul>
<li>Initialization, where the time doesn't matter (e.g., tracks in a Monte Carlo).</li>
<li>Access, where efficient or "simple" access to the map's contents are important. In general, we access a map many, many more times that we create one.</li>
<li>After we create/initialize a map, we never change its contents.</li>
</ul>
<p>For this usage, a sorted vector is generally superior to a map.</p>
<p>This class just implements the equivalent of an STL map, not a multimap, set, nor a multiset. If there's a need, I may create additional classes.</p>
<p>Is there any map feature that's not implemented? Yes:</p>
<ul>
<li>equal_range in a const context (which causes some weird <a class="el" href="../../da/d98/namespaceutil_1_1ROOT.html">ROOT</a> dictionary problem); this isn't likely to be used for a map anyway (multimaps or multisets would be a different story).</li>
</ul>
<p>Advanced implementation note: Depending on the application, it might be possible to speed up this class by using "lazy
evaluation"; that is, we wouldn't actually sort the vector until the user actually tries to access its contents. I'm not going to do this, because:</p>
<p>A) I don't think my programming skills are up to the task.</p>
<p>B) In the primary application for which I plan to use this class (Monte-Carlo particle tracks), we're performing at least one search after every insert; lazy evaluation wouldn't be much of a speed improvement.</p>
<p>Feb-2011 WGS: <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html">VectorMap</a> mostly looks like a map, but there are some memory-management issues that relate to it being a vector. Include the vector-based routines reserve() and capacity().</p>
<p>Title: <a class="el" href="../../de/d95/classutil_1_1GaussianEliminationAlg.html">GaussianEliminationAlg</a> Class Author: Wes Ketchum (<a href="#" onclick="location.href='mai'+'lto:'+'wke'+'tc'+'hum'+'@l'+'anl'+'.g'+'ov'; return false;">wketc<span style="display: none;">.nosp@m.</span>hum@<span style="display: none;">.nosp@m.</span>lanl.<span style="display: none;">.nosp@m.</span>gov</a>)</p>
<p>Description: Class that solves system of linear equations via Gaussian Elimination. Intended for use with RFFHitFitter </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ada5647082a33c085c6cd4556712066bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#ada5647082a33c085c6cd4556712066bb">util::ArtHandleData_t</a> = typedef typename Handle::element_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of data in a <em>art</em> handle to vector data product. </p>

<p>Definition at line <a class="el" href="../../de/d0a/DataProductPointerMap_8h_source.html#l00042">42</a> of file <a class="el" href="../../de/d0a/DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1de93ae9853deac245708c89676409c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#af1de93ae9853deac245708c89676409c">util::DataProductPointerMap_t</a> = typedef <a class="el" href="../../de/df8/namespaceutil_1_1details.html#ac66982acdadafd712181850d760caa93">details::DataProductPointerMap_t</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of map for data product pointers to <em>art</em> pointers. </p>

<p>Definition at line <a class="el" href="../../de/d0a/DataProductPointerMap_8h_source.html#l00046">46</a> of file <a class="el" href="../../de/d0a/DataProductPointerMap_8h_source.html">DataProductPointerMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a379847876f76e55ce72f99edcc9d7cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATUM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#a379847876f76e55ce72f99edcc9d7cee">util::GridContainer2D</a> = typedef <a class="el" href="../../d6/d8e/classutil_1_1GridContainerBase2D.html">GridContainerBase2D</a>&lt;DATUM, <a class="el" href="../../d6/d72/namespaceutil.html#aab557de18370e4a773f005e37285b439">GridContainer2DIndices</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container allowing 2D indexing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATUM</td><td>type of contained data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d6/d72/namespaceutil.html#aab557de18370e4a773f005e37285b439" title="Index manager for a container of data arranged on a 2D grid. ">GridContainer2DIndices</a></dd></dl>
<p>This is an alias for <a class="el" href="../../d6/d8e/classutil_1_1GridContainerBase2D.html" title="Base class for a container of data arranged on a 2D-grid. ">GridContainerBase2D</a>, with a proper index manager. See the documentation of <a class="el" href="../../d6/d8e/classutil_1_1GridContainerBase2D.html" title="Base class for a container of data arranged on a 2D-grid. ">GridContainerBase2D</a>. </p>

<p>Definition at line <a class="el" href="../../d1/daa/GridContainers_8h_source.html#l00267">267</a> of file <a class="el" href="../../d1/daa/GridContainers_8h_source.html">GridContainers.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab557de18370e4a773f005e37285b439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#aab557de18370e4a773f005e37285b439">util::GridContainer2DIndices</a> = typedef <a class="el" href="../../d9/d70/classutil_1_1GridContainerIndicesBase2D.html">GridContainerIndicesBase2D</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index manager for a container of data arranged on a 2D grid. </p>

<p>Definition at line <a class="el" href="../../d0/d7a/GridContainerIndices_8h_source.html#l00181">181</a> of file <a class="el" href="../../d0/d7a/GridContainerIndices_8h_source.html">GridContainerIndices.h</a>.</p>

</div>
</div>
<a class="anchor" id="a503302a79d6be4def6577e2c86bc11be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATUM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#a503302a79d6be4def6577e2c86bc11be">util::GridContainer3D</a> = typedef <a class="el" href="../../d9/d07/classutil_1_1GridContainerBase3D.html">GridContainerBase3D</a>&lt;DATUM, <a class="el" href="../../d6/d72/namespaceutil.html#abac25b5d7b5d55ecd725a92e86750744">GridContainer3DIndices</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container allowing 3D indexing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATUM</td><td>type of contained data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d6/d72/namespaceutil.html#abac25b5d7b5d55ecd725a92e86750744" title="Index manager for a container of data arranged on a 3D grid. ">GridContainer3DIndices</a></dd></dl>
<p>This is an alias for <a class="el" href="../../d9/d07/classutil_1_1GridContainerBase3D.html" title="Base class for a container of data arranged on a 3D-grid. ">GridContainerBase3D</a>, with a proper index manager. See the documentation of <a class="el" href="../../d9/d07/classutil_1_1GridContainerBase3D.html" title="Base class for a container of data arranged on a 3D-grid. ">GridContainerBase3D</a>. </p>

<p>Definition at line <a class="el" href="../../d1/daa/GridContainers_8h_source.html#l00279">279</a> of file <a class="el" href="../../d1/daa/GridContainers_8h_source.html">GridContainers.h</a>.</p>

</div>
</div>
<a class="anchor" id="abac25b5d7b5d55ecd725a92e86750744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#abac25b5d7b5d55ecd725a92e86750744">util::GridContainer3DIndices</a> = typedef <a class="el" href="../../d6/da6/classutil_1_1GridContainerIndicesBase3D.html">GridContainerIndicesBase3D</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index manager for a container of data arranged on a 3D grid. </p>

<p>Definition at line <a class="el" href="../../d0/d7a/GridContainerIndices_8h_source.html#l00184">184</a> of file <a class="el" href="../../d0/d7a/GridContainerIndices_8h_source.html">GridContainerIndices.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4166e03c037e92995c75f98c98dc488d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d72/namespaceutil.html#a4166e03c037e92995c75f98c98dc488d">util::MatrixIndices</a> = typedef <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html">TensorIndices</a>&lt;2U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for indexing a 2D-tensor (matrix) </p>

<p>Definition at line <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html#l00551">551</a> of file <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html">TensorIndices.h</a>.</p>

</div>
</div>
<a class="anchor" id="a097740c1c11a734156bf86e85b210e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; <a class="el" href="../../db/d71/classutil_1_1UBDaqID.html">UBDaqID</a>, <a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">UBLArSoftCh_t</a> &gt; <a class="el" href="../../d6/d72/namespaceutil.html#a097740c1c11a734156bf86e85b210e1b">util::UBChannelMap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html#l00048">48</a> of file <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html">DatabaseUtil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a212740e3c13bae3ed850ef0310bbb62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; <a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">UBLArSoftCh_t</a>, <a class="el" href="../../db/d71/classutil_1_1UBDaqID.html">UBDaqID</a> &gt; <a class="el" href="../../d6/d72/namespaceutil.html#a212740e3c13bae3ed850ef0310bbb62e">util::UBChannelReverseMap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html#l00049">49</a> of file <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html">DatabaseUtil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1e47d8bc8d524a05f14f786e25af2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="../../d6/d72/namespaceutil.html#a5e1e47d8bc8d524a05f14f786e25af2e">util::UBLArSoftCh_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html#l00046">46</a> of file <a class="el" href="../../db/d6a/DatabaseUtil_8h_source.html">DatabaseUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a97e6c3458c743f7f13ec261c7c5fbd4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of the argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>value to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of v</dd></dl>
<p>If the value <code>v</code> is negative, its opposite is returned. Note that this implementation does not work with data types that are not comparable (like <code>std::complex</code>).</p>
<h2>Requirements </h2>
<ul>
<li>constexpr construction of a <code>T</code> value from the literal <code>0</code></li>
<li><code>operator- (T) constexpr</code></li>
<li><code>operator&lt; (T, T) constexpr</code> convertible to <code>bool</code> </li>
</ul>

<p>Definition at line <a class="el" href="../../df/df6/constexpr__math_8h_source.html#l00040">40</a> of file <a class="el" href="../../df/df6/constexpr__math_8h_source.html">constexpr_math.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;{ <span class="keywordflow">return</span> (-T(0) &lt; v)? v: -v; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaae39c2a7066e6a24ff172e5471939ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::absDiff </td>
          <td>(</td>
          <td class="paramtype">A const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of the difference between two values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>type of the first value </td></tr>
    <tr><td class="paramname">B</td><td>type of the second value (<em>must</em> actually be as <code>A</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference between the largest and the smallest of <code>a</code> and <code>b</code></dd></dl>
<p>The pecularity of this implementation is that it always avoids taking the difference between the smallest and the largest of <code>a</code> and <code>b</code>. An equivalent implementation is: </p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> std::max(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, b) - std::min(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, b);</div>
</div><!-- fragment --><p>It still assumes that the difference is representable in <code>A</code>; for example, this assumption will fail for <code>int</code> types with <code>a</code> a very large number and <code>b</code> a very small (i.e. negative) number.</p>
<p>Requirements:</p>
<ul>
<li><code>A</code> and <code>B</code> must be the same type </li>
</ul>

<p>Definition at line <a class="el" href="../../da/d16/NumericUtils_8h_source.html#l00043">43</a> of file <a class="el" href="../../da/d16/NumericUtils_8h_source.html">NumericUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      static_assert(</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        std::is_same&lt;std::decay_t&lt;A&gt;, std::decay_t&lt;B&gt;&gt;(),</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="stringliteral">&quot;Arguments of util::absDiff() have to be of the same type.&quot;</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        );</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      <span class="keywordflow">return</span> (b &gt; <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>)? (b - <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>): (<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> - b);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a66a267ed8783b05b951db1b985e4f057"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::associated_groups </td>
          <td>(</td>
          <td class="paramtype">A const &amp;&#160;</td>
          <td class="paramname"><em>assns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions to access associations in order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>type of association being read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assns</td><td>the association being read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d6/d72/namespaceutil.html#a19cc23cf942017f81281aeee4c7ba4c1" title="Helper functions to access associations in order. ">for_each_associated_group()</a></dd></dl>
<p>This function provides a functionality equivalent to <code>art::for_each_group()</code>, but it grants the caller additional control on the external loop and on the function.</p>
<p>Example: assuming that a module with input tag stored in <code>fTrackTag</code> has created associations of each track to its hits, the total charge for each track can be extracted by: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> assns = art::getValidHandle&lt;art::Assns&lt;recob::Track, recob::Hit&gt;&gt;</div>
<div class="line">  (fTrackTag);</div>
<div class="line"></div>
<div class="line">std::vector&lt;double&gt; totalCharge;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; hits: <a class="code" href="../../d6/d72/namespaceutil.html#a66a267ed8783b05b951db1b985e4f057">util::associated_groups</a>(*assns)) {</div>
<div class="line">  <span class="keywordtype">double</span> total = 0.;</div>
<div class="line">  <span class="keywordflow">for</span> (art::Ptr&lt;recob::Hit&gt; <span class="keyword">const</span>&amp; <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#abf2e819dbf4c327e098bebd4b2dc0597">hit</a>: hits)</div>
<div class="line">    total += <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#abf2e819dbf4c327e098bebd4b2dc0597">hit</a>-&gt;Integral();</div>
<div class="line">  totalCharge.push_back(total);</div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> A number of important points need to be realised about this example:</p>
<ul>
<li>the requirements of this function on its input association are the same as for <code>art::for_each_group()</code></li>
<li>we can code the action on each group of hits directly in a loop, if like in this case the code is succinct</li>
<li>again, there is one outer loop iteration for every track;</li>
<li>the value of <code>hits</code> is an object representing a range of <em>art</em> pointers (<code>art::Ptr&lt;<a class="el" href="../../db/d4e/classrecob_1_1Hit.html" title="2D representation of charge deposited in the TDC/wire plane ">recob::Hit</a>&gt;</code>) which can be navigated with the <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a></code>/<code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a></code> free functions, or in a range-for loop;</li>
<li>on each iteration, the information of which track the hits are associated to is not available; if that is also needed, use <code><a class="el" href="../../d6/d72/namespaceutil.html#a1593f344a06d605cbc7ecafcf1636e99" title="Helper functions to access associations in order, also with key. ">util::associated_groups_with_left()</a></code> instead. </li>
</ul>

<p>Definition at line <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html#l00094">94</a> of file <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html">ForEachAssociatedGroup.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                                          {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;     <span class="keywordflow">return</span> assns |</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            ranges::views::all |</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            ranges::views::group_by([](<span class="keyword">auto</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a>, <span class="keyword">auto</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a>) { <span class="keywordflow">return</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a>.first == <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a>.first;}) |</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">ranges::views::transform</a>([] (<span class="keyword">auto</span> pairs) {<span class="keywordflow">return</span> pairs | <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#a5db4217e69ac7c2d95856da42b13f8e5">ranges::views::values</a> | <a class="code" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a>;}) |</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <a class="code" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            ;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  } <span class="comment">// associated_groups()</span></div>
<div class="ttc" id="namespaceicarus_1_1waveform__operations_1_1details_html_ae295d3f6cb2f9181dccdf0e3492d44e0"><div class="ttname"><a href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">icarus::waveform_operations::details::transform</a></div><div class="ttdeci">static constexpr Sample_t transform(Sample_t sample)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d8e/WaveformOperations_8h_source.html#l00145">WaveformOperations.h:145</a></div></div>
<div class="ttc" id="HoughBaseAlg_8cxx_html_aa3fd046b2956875cf908d73a51a96b42"><div class="ttname"><a href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a></div><div class="ttdeci">#define a2</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dee/HoughBaseAlg_8cxx_source.html#l00064">HoughBaseAlg.cxx:64</a></div></div>
<div class="ttc" id="namespaceutil_html_a90a2ce9dc82a9f5dc3fbb59ea5583e30"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a></div><div class="ttdeci">constexpr RangeForWrapperTag range_for</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d45/RangeForWrapper_8h_source.html#l00438">RangeForWrapper.h:438</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_a5db4217e69ac7c2d95856da42b13f8e5"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#a5db4217e69ac7c2d95856da42b13f8e5">channelDBConverter.values</a></div><div class="ttdeci">list values</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00248">channelDBConverter.py:248</a></div></div>
<div class="ttc" id="HoughBaseAlg_8cxx_html_ab89a77e63a7226fffaecb2e2c2ab5219"><div class="ttname"><a href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a></div><div class="ttdeci">#define a1</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dee/HoughBaseAlg_8cxx_source.html#l00063">HoughBaseAlg.cxx:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1593f344a06d605cbc7ecafcf1636e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::associated_groups_with_left </td>
          <td>(</td>
          <td class="paramtype">A const &amp;&#160;</td>
          <td class="paramname"><em>assns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions to access associations in order, also with key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>type of association being read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assns</td><td>the association being read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d6/d72/namespaceutil.html#a19cc23cf942017f81281aeee4c7ba4c1" title="Helper functions to access associations in order. ">for_each_associated_group()</a></dd></dl>
<p>This function provides a functionality equivalent to <code>art::for_each_group_with_left()</code>, but it grants the caller additional control on the external loop and on the function.</p>
<p>Example: assuming that a module with input tag stored in <code>fTrackTag</code> has created associations of each track to its hits, the total charge for each track can be extracted by: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> assns = art::getValidHandle&lt;art::Assns&lt;recob::Track, recob::Hit&gt;&gt;</div>
<div class="line">  (fTrackTag);</div>
<div class="line"></div>
<div class="line">std::map&lt;int, double&gt; totalCharge;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; trackWithHits: <a class="code" href="../../d6/d72/namespaceutil.html#a1593f344a06d605cbc7ecafcf1636e99">util::associated_groups_with_left</a>(*assns))</div>
<div class="line">{</div>
<div class="line">  art::Ptr&lt;recob::Track&gt; <span class="keyword">const</span>&amp; <a class="code" href="../../df/df2/standard__reco_8fcl.html#a8e7c4631bab825a68b0a82d8223c2ec2">track</a> = trackWithHits.first;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; hits = trackWithHits.second;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (totalCharge.count(track-&gt;ID()) &gt; 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> art::Exception(art::errors::LogicError)</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;Multiple tracks have ID &quot;</span> &lt;&lt; track-&gt;ID() &lt;&lt; <span class="stringliteral">&quot;!\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">double</span>&amp; total = totalCharge[track-&gt;ID()];</div>
<div class="line">  total = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> (art::Ptr&lt;recob::Hit&gt; <span class="keyword">const</span>&amp; <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#abf2e819dbf4c327e098bebd4b2dc0597">hit</a>: hits)</div>
<div class="line">    total += <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#abf2e819dbf4c327e098bebd4b2dc0597">hit</a>-&gt;Integral();</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> A number of important points need to be realised about this example:</p>
<ul>
<li>the requirements of this function on its input association are the same as for <code>art::for_each_group_with_left()</code></li>
<li>we can code the action on each group of hits directly in a loop, if like in this case the code is succinct</li>
<li>again, there is one outer loop iteration for every track;</li>
<li>the value of <code>hits</code> is an object representing a range of <em>art</em> pointers (<code>art::Ptr&lt;<a class="el" href="../../db/d4e/classrecob_1_1Hit.html" title="2D representation of charge deposited in the TDC/wire plane ">recob::Hit</a>&gt;</code>) which can be navigated with the <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a></code>/<code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a></code> free functions, or in a range-for loop. </li>
</ul>

<p>Definition at line <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html#l00152">152</a> of file <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html">ForEachAssociatedGroup.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                                                    {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;     <span class="keywordflow">return</span> assns</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        | ranges::views::all</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        | ranges::views::group_by([](<span class="keyword">auto</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a>, <span class="keyword">auto</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a>) { <span class="keywordflow">return</span> <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a>.first == <a class="code" href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a>.first;})</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        | <a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">ranges::views::transform</a>([] (<span class="keyword">auto</span> pairs)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;           {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;             <span class="keywordflow">return</span> std::make_pair(</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;               pairs.front().first, <span class="comment">// assuming they&#39;re all the same, pick first</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;               pairs | <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#a5db4217e69ac7c2d95856da42b13f8e5">ranges::views::values</a> | <a class="code" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;               );</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;           })</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        | <a class="code" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        ;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  } <span class="comment">// associated_groups_with_left()</span></div>
<div class="ttc" id="namespaceicarus_1_1waveform__operations_1_1details_html_ae295d3f6cb2f9181dccdf0e3492d44e0"><div class="ttname"><a href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">icarus::waveform_operations::details::transform</a></div><div class="ttdeci">static constexpr Sample_t transform(Sample_t sample)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d8e/WaveformOperations_8h_source.html#l00145">WaveformOperations.h:145</a></div></div>
<div class="ttc" id="HoughBaseAlg_8cxx_html_aa3fd046b2956875cf908d73a51a96b42"><div class="ttname"><a href="../../d3/dee/HoughBaseAlg_8cxx.html#aa3fd046b2956875cf908d73a51a96b42">a2</a></div><div class="ttdeci">#define a2</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dee/HoughBaseAlg_8cxx_source.html#l00064">HoughBaseAlg.cxx:64</a></div></div>
<div class="ttc" id="namespaceutil_html_a90a2ce9dc82a9f5dc3fbb59ea5583e30"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a></div><div class="ttdeci">constexpr RangeForWrapperTag range_for</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d45/RangeForWrapper_8h_source.html#l00438">RangeForWrapper.h:438</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_a5db4217e69ac7c2d95856da42b13f8e5"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#a5db4217e69ac7c2d95856da42b13f8e5">channelDBConverter.values</a></div><div class="ttdeci">list values</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00248">channelDBConverter.py:248</a></div></div>
<div class="ttc" id="HoughBaseAlg_8cxx_html_ab89a77e63a7226fffaecb2e2c2ab5219"><div class="ttname"><a href="../../d3/dee/HoughBaseAlg_8cxx.html#ab89a77e63a7226fffaecb2e2c2ab5219">a1</a></div><div class="ttdeci">#define a1</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dee/HoughBaseAlg_8cxx_source.html#l00063">HoughBaseAlg.cxx:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfa5684872204728adc89bc973f65b91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename KeyOp , typename CmpOp , typename RefOp , typename KeySortOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::clusterBy </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyOp&#160;</td>
          <td class="paramname"><em>keyFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmpOp&#160;</td>
          <td class="paramname"><em>sameGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RefOp&#160;</td>
          <td class="paramname"><em>objRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySortOp&#160;</td>
          <td class="paramname"><em>keySort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a simple clustering. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection of objects to cluster </td></tr>
    <tr><td class="paramname">KeyOp</td><td>type of operation extracting the relevant key for clustering </td></tr>
    <tr><td class="paramname">CmpOp</td><td>type of operation determining if object belongs to a cluster </td></tr>
    <tr><td class="paramname">RefOp</td><td>type of operation extracting the object to store in cluster </td></tr>
    <tr><td class="paramname">KeySortOp</td><td>type of operation sorting the clustering keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>collection of objects to cluster </td></tr>
    <tr><td class="paramname">keyFunc</td><td>operation extracting the relevant key for clustering </td></tr>
    <tr><td class="paramname">sameGroup</td><td>operation determining if an object belongs to a cluster </td></tr>
    <tr><td class="paramname">objRef</td><td>operation extracting the object to store in the cluster </td></tr>
    <tr><td class="paramname">keySort</td><td>operation sorting the clustering keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a STL vector of clusters of object "references"</dd></dl>
<p>The algorithm clusters objects whose key is compatible. The key must be sortable (<code>keySort</code>). Each cluster is assigned a key value, and all the unclustered objects whose key (<code>keyFunc</code>) is compatible (<code>sameGroup</code>) with that cluster key are added to that cluster. The objects from <code>coll</code> are considered in order of key value, with the order being defined by <code>keySort</code>. Each cluster contains a derivative of the original object (<code>objRef</code>), which may be for example a pointer to the original object, a copy of it, or in fact anything <code>objRef</code> returns.</p>
<p>The return value is in the form of a <code>std::vector</code> in which each element represents a cluster. Each of these clusters is a <code>std::vector</code> of the derivative objects.</p>
<h2>Requirements </h2>
<ul>
<li><code>Coll</code>: an iterable collection of objects of type <code>Object_t</code>;</li>
<li><code>KeyOp</code>: a functor returning the key of an object, like <code>Key_t keyFunc(Object_t const&amp;)</code>;</li>
<li><code>KeySortOp</code>: a functor like <code>bool keySort(Key_t a, Key_t b)</code> returning strict ordering between key values <code>a</code> and <code>b</code>;</li>
<li><code>CmpOp</code>: a functor like <code>bool keySort(Key_t a, Key_t b)</code> returning if an object with key <code>b</code> should belong to a cluster with key <code>a</code>;</li>
<li><code>RefOp</code>: a functor returning the object to store in the cluster starting from an object in the original collection: <code>ObjRef_t objRef(Object_t)</code>; note that the result should probably <em>not</em> be a C++ reference since they don't go along well with containers. </li>
</ul>

<p>Definition at line <a class="el" href="../../de/d39/icarusalg_2icarusalg_2Utilities_2SimpleClustering_8h_source.html#l00118">118</a> of file <a class="el" href="../../de/d39/icarusalg_2icarusalg_2Utilities_2SimpleClustering_8h_source.html">icarusalg/icarusalg/Utilities/SimpleClustering.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">   * 1. create a list of object key (`keyFunc`) and object reference (`objRef`)</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">   * 2. sort that list by key (`keySort`)</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">   * 3. cluster object references with nearby keys (`sameGroup`)</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">   *</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">   * A new cluster is started every time for a new object `sameGroup` return</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">   * `false` when applied on the key of the first object in the current cluster</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">   * and the key of the new object.</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">   *</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="comment">// some definitions</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="keyword">using</span> Object_t = <span class="keyword">typename</span> Coll::value_type;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="keyword">using</span> ObjectRef_t = std::decay_t&lt;decltype(objRef(std::declval&lt;Object_t&gt;()))&gt;;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keyword">using</span> Cluster_t = std::vector&lt;ObjectRef_t&gt;;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="keyword">using</span> Clusters_t = std::vector&lt;Cluster_t&gt;;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keyword">auto</span> makeKeyAndObjRef = [keyFunc, objRef](<span class="keyword">auto</span>&amp;&amp; obj)</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    { <span class="keywordflow">return</span> std::make_pair(keyFunc(obj), objRef(obj)); };</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keyword">using</span> KeyAndObjRef_t = decltype(makeKeyAndObjRef(*(<a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">util::begin</a>(objs))));</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// working data: &quot;map&quot; of objects by key</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  std::vector&lt;KeyAndObjRef_t&gt; KeysAndObjRefs;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  KeysAndObjRefs.reserve(objs.size());</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a>(</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">util::begin</a>(objs), <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">util::end</a>(objs), std::back_inserter(KeysAndObjRefs),</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    makeKeyAndObjRef</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    );</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="comment">// sort the map by key</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  std::sort(</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">util::begin</a>(KeysAndObjRefs), <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">util::end</a>(KeysAndObjRefs),</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    details::makeTupleElementOp&lt;0U&gt;(keySort)</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    );</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// cluster the objects in the map by key proximity</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  Clusters_t clusters;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="keywordflow">if</span> (KeysAndObjRefs.empty()) <span class="keywordflow">return</span> clusters;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="keyword">auto</span> iKeyAndObjRef = <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">util::begin</a>(KeysAndObjRefs);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a> = <a class="code" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">util::end</a>(KeysAndObjRefs);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keyword">auto</span> startCluster = [](<span class="keyword">auto</span>&amp; keyAndObjRef)</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <span class="keywordflow">return</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        std::make_pair(keyAndObjRef.first, Cluster_t{ keyAndObjRef.second });</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    };</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keyword">auto</span> addToCluster = [](<span class="keyword">auto</span>&amp; <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#afac1ac7b61385644c993fbb774a1922f">cluster</a>, <span class="keyword">auto</span>&amp; keyAndObjRef)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    { <a class="code" href="../../d2/d36/cheaterreco_8fcl.html#afac1ac7b61385644c993fbb774a1922f">cluster</a>.second.push_back(std::move(keyAndObjRef.second)); };</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="keyword">auto</span> currentCluster = startCluster(*iKeyAndObjRef);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keywordflow">while</span>(++iKeyAndObjRef != <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>) {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span> (sameGroup(iKeyAndObjRef-&gt;first, currentCluster.first)) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      addToCluster(currentCluster, *iKeyAndObjRef);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      clusters.push_back(std::move(currentCluster.second));</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      currentCluster = startCluster(*iKeyAndObjRef);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  clusters.push_back(std::move(currentCluster.second));</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">return</span> clusters;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;} <span class="comment">// util::clusterBy(Coll, KeyOp, CmpOp, RefOp, KeySortOp)</span></div>
<div class="ttc" id="namespaceicarus_1_1waveform__operations_1_1details_html_ae295d3f6cb2f9181dccdf0e3492d44e0"><div class="ttname"><a href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">icarus::waveform_operations::details::transform</a></div><div class="ttdeci">static constexpr Sample_t transform(Sample_t sample)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d8e/WaveformOperations_8h_source.html#l00145">WaveformOperations.h:145</a></div></div>
<div class="ttc" id="cheaterreco_8fcl_html_afac1ac7b61385644c993fbb774a1922f"><div class="ttname"><a href="../../d2/d36/cheaterreco_8fcl.html#afac1ac7b61385644c993fbb774a1922f">cluster</a></div><div class="ttdeci">process_name cluster</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d36/cheaterreco_8fcl_source.html#l00051">cheaterreco.fcl:51</a></div></div>
<div class="ttc" id="group__LArSoft__CoreUtils__StdUtils_html_gaa1d0cd0cbac37bc1ca4c84daf5343973"><div class="ttname"><a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973">util::end</a></div><div class="ttdeci">decltype(auto) constexpr end(T &amp;&amp;obj)</div><div class="ttdoc">ADL-aware version of std::end. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/de2/StdUtils_8h_source.html#l00077">StdUtils.h:77</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="group__LArSoft__CoreUtils__StdUtils_html_ga624a6c8d8a7c2d3746a644f8cc1c1efe"><div class="ttname"><a href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe">util::begin</a></div><div class="ttdeci">decltype(auto) constexpr begin(T &amp;&amp;obj)</div><div class="ttdoc">ADL-aware version of std::begin. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/de2/StdUtils_8h_source.html#l00072">StdUtils.h:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99fd61a6b4d7f9f81c6a42a296d2b81b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename KeyOp , typename CmpOp , typename KeySortOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::clusterBy </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyOp&#160;</td>
          <td class="paramname"><em>keyFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmpOp&#160;</td>
          <td class="paramname"><em>sameGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySortOp&#160;</td>
          <td class="paramname"><em>keySort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of <code><a class="el" href="../../d6/d72/namespaceutil.html#adfa5684872204728adc89bc973f65b91" title="Performs a simple clustering. ">clusterBy()</a></code> storing a copy of each object as "reference". </p>

<p>Definition at line <a class="el" href="../../de/d39/icarusalg_2icarusalg_2Utilities_2SimpleClustering_8h_source.html#l00202">202</a> of file <a class="el" href="../../de/d39/icarusalg_2icarusalg_2Utilities_2SimpleClustering_8h_source.html">icarusalg/icarusalg/Utilities/SimpleClustering.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#adfa5684872204728adc89bc973f65b91">clusterBy</a>(objs,</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    std::move(keyFunc), std::move(sameGroup),</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; obj){ <span class="keywordflow">return</span> obj; },</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    std::move(keySort)</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    );</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;} <span class="comment">// util::clusterBy(Coll, KeyOp, CmpOp, KeySortOp)</span></div>
<div class="ttc" id="namespaceutil_html_adfa5684872204728adc89bc973f65b91"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#adfa5684872204728adc89bc973f65b91">util::clusterBy</a></div><div class="ttdeci">auto clusterBy(Coll const &amp;objs, KeyOp keyFunc, CmpOp sameGroup, RefOp objRef, KeySortOp keySort)</div><div class="ttdoc">Performs a simple clustering. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/d39/icarusalg_2icarusalg_2Utilities_2SimpleClustering_8h_source.html#l00118">icarusalg/icarusalg/Utilities/SimpleClustering.h:118</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78763547f615316fc4a54ad5a473789a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.comma_separated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00287">287</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a78763547f615316fc4a54ad5a473789a">  287</a></span>&#160;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a78763547f615316fc4a54ad5a473789a">comma_separated</a>(inp):</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">return</span> inp.split(<span class="stringliteral">&quot;,&quot;</span>)</div>
</div>
<div class="ttc" id="namespaceutil_html_a78763547f615316fc4a54ad5a473789a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a78763547f615316fc4a54ad5a473789a">util.comma_separated</a></div><div class="ttdeci">def comma_separated</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00287">util.py:287</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aac4707f84c6dc5c269f147302722611f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::const_values </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper iterating across the constant values of the specified collection. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4" title="Range-for loop helper iterating across the values of the specified collection. ">util::values()</a></code></dd></dl>
<p>This function is equivalent to <code><a class="el" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4" title="Range-for loop helper iterating across the values of the specified collection. ">util::values()</a></code> but the values are extracted as if the specified collection were constant. </p>

</div>
</div>
<a class="anchor" id="aefa47a1a36712e98d450e2e6fe3fc1f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::ContainedLength </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../db/d54/classgeo_1_1BoxBoundedGeo.html">geo::BoxBoundedGeo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate length between two points contained in a list of (non-overlapping) volumes. Units are abitrary, but must be consistent between the three inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>The first point </td></tr>
    <tr><td class="paramname">v1</td><td>The second point </td></tr>
    <tr><td class="paramname">boxes</td><td>A list of non-overlapping boxes through which the contained length will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contained length in units of the inputs </dd></dl>

<p>Definition at line <a class="el" href="../../da/daa/Interaction_8cxx_source.html#l00028">28</a> of file <a class="el" href="../../da/daa/Interaction_8cxx_source.html">Interaction.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                                                 {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="comment">// if points are the same, return 0</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keywordflow">if</span> ((v0 - v1).Mag() &lt; 1<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>-6) <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="keywordtype">double</span> length = 0;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="comment">// total contained length is sum of lengths in all boxes</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// assuming they are non-overlapping</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;box: boxes) {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordtype">int</span> n_contained = box.ContainsPosition(v0) + box.ContainsPosition(v1);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="comment">// both points contained -- length is total length (also can break out of loop)</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">if</span> (n_contained == 2) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      length = (v1 - v0).Mag();</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// one contained -- have to find intersection point (which must exist)</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n_contained == 1) {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      std::vector&lt;TVector3&gt; intersections = box.GetIntersections(v0, v1); </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;      assert(intersections.size() == 1); <span class="comment">// should only have one intersection point</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;      <span class="comment">// get the length</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      length += ( box.ContainsPosition(v0) ? (v0 - intersections[0]).Mag() : (v1 -  intersections[0]).Mag() );</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n_contained == 0) {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      std::vector&lt;TVector3&gt; intersections = box.GetIntersections(v0, v1); </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      <span class="comment">// should have 0 or 2</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <span class="keywordflow">if</span> (intersections.size() == 2) {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        length += (intersections[0] - intersections[1]).Mag();</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;      <span class="keywordflow">else</span> assert(intersections.size() == 0);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">else</span> assert(<span class="keyword">false</span>); <span class="comment">// bad</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">return</span> length;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9462a726cd010ab8ada5eead879a4b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::counter </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an object to iterate values from <code>begin</code> to <code>end</code> in a range-for loop. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of counter value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a control object for range-for loop </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../db/d23/classutil_1_1count__iterator.html" title="An iterator dereferencing to a counter value. ">util::count_iterator</a></code></dd></dl>
<p>An example of usage: </p>
<div class="fragment"><div class="line">std::vector&lt;std::size_t&gt; data;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i: <a class="code" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f">util::counter</a>(4, 8)) {</div>
<div class="line">  data.push_back(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p> will insert in <code>data</code> the numbers from <code>4</code> to <code>7</code>, just like: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t i = 4; i &lt; 8; ++i) {</div>
<div class="line">  data.push_back(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p> would. </p>

<p>Definition at line <a class="el" href="../../d7/da2/counter_8h_source.html#l00285">285</a> of file <a class="el" href="../../d7/da2/counter_8h_source.html">counter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="../../d5/d70/structutil_1_1span.html">util::span</a>(count_iterator(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>), count_iterator(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>)); }</div>
<div class="ttc" id="structutil_1_1span_html"><div class="ttname"><a href="../../d5/d70/structutil_1_1span.html">util::span</a></div><div class="ttdoc">Simple class with a begin and an end. </div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00125">span.h:125</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa2b9b82160a0ba48b6993899ed07d613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::counter </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Version of <code><a class="el" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f" title="Returns an object to iterate values from begin to end in a range-for loop. ">util::counter()</a></code> starting at default-constructed <code>T</code> (usually some form of <code>0</code>). </p>

<p>Definition at line <a class="el" href="../../d7/da2/counter_8h_source.html#l00184">184</a> of file <a class="el" href="../../d7/da2/counter_8h_source.html">counter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f">counter</a>(T{}, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>); }</div>
<div class="ttc" id="namespaceutil_html_a9462a726cd010ab8ada5eead879a4b9f"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f">util::counter</a></div><div class="ttdeci">auto counter(T begin, T end)</div><div class="ttdoc">Returns an object to iterate values from begin to end in a range-for loop. </div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da2/counter_8h_source.html#l00285">counter.h:285</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad13c097e1cf7b9ec11a25f6dc36827f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between a new product and one already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The product already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9eb8f4c83e113df6bac4e7370895530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between each of a series of new products and one already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The product already in the event </td></tr>
    <tr><td class="paramname">begin_indx</td><td>Which element of <em>a</em> to associate first. </td></tr>
    <tr><td class="paramname">end_indx</td><td>One more than the index of the last element to associate </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9cc2145a351349f5c7de1af21f2d7f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between two products already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A product already in the event </td></tr>
    <tr><td class="paramname">b</td><td>Another product already in the event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e71a585050655ac1927bb921c678153"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::PtrVector&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between a new product and a PtrVector already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The products already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31ebbf3738beae652ad4ee3f01305b10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between products already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A product already in the event </td></tr>
    <tr><td class="paramname">b</td><td>A vector of products already in the event (the many) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a197d20756eac924c5edfc4b054c8eee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between a new product and a vector of Ptrs already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The products already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac59317fb6c0aea59a7fc1c56b3129fa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instancea</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instanceb</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between new products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>Another collection about to be added to the event </td></tr>
    <tr><td class="paramname">startU</td><td>The first element of <em>b</em> to associate </td></tr>
    <tr><td class="paramname">endU</td><td>The last element of <em>b</em> to associate +1 (like STL <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a> and <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a>) </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instancea</td><td>instance label for product a, defaulted to be an empty string </td></tr>
    <tr><td class="paramname">instanceb</td><td>instance label for product b, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab05a1cc60264b053f50b58da3f51e480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDProducer const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxb</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxa</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instancea</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instanceb</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 between new products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>Another collection about to be added to the event </td></tr>
    <tr><td class="paramname">indxb</td><td>Which element of <em>b</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">indxa</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instancea</td><td>instance label for product a, defaulted to be an empty string </td></tr>
    <tr><td class="paramname">instanceb</td><td>instance label for product b, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac016dc123242a7f1d5c81594de910717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; U, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>a_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-one association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the object already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>art::Ptr to the (new) object to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">a_instance</td><td>name of the instance that will be used for a in evt </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>As example of usage: create a wire/raw digit association. This code should live in the art::EDProduce::produce() method. The <a class="el" href="../../d7/d64/classraw_1_1RawDigit.html" title="Collection of charge vs time digitized from a single readout channel. ">raw::RawDigit</a> product was created already by a DigitModuleLabel module. The code is supposed to produce one <a class="el" href="../../d2/db7/classrecob_1_1Wire.html" title="Class holding the regions of interest of signal from a channel. ">recob::Wire</a> for each existing <a class="el" href="../../d7/d64/classraw_1_1RawDigit.html" title="Collection of charge vs time digitized from a single readout channel. ">raw::RawDigit</a>, and contextually associate the new wire to the source digit. We are also assuming that there might be different RawDigit sets produced by the same producer: we identify the one we care of by the string spill_name and we create wires and associations with the same label for convenience. </p>
<pre class="fragment">// this is the original list of digits, thawed from the event
art::Handle&lt; std::vector&lt;raw::RawDigit&gt;&gt; digitVecHandle;
evt.getByLabel(DigitModuleLabel, spill_name, digitVecHandle);

// the collection of wires that will be written as data product
std::unique_ptr&lt;std::vector&lt;recob::Wire&gt;&gt; wirecol(new std::vector&lt;recob::Wire&gt;);
// ... and an association set
std::unique_ptr&lt;art::Assns&lt;raw::RawDigit,recob::Wire&gt;&gt; WireDigitAssn
  (new art::Assns&lt;raw::RawDigit,recob::Wire&gt;);

for(size_t iDigit = 0; iDigit &lt; digitVecHandle-&gt;size(); ++iDigit) {
  // turn the digit into a art::Ptr:
  art::Ptr&lt;raw::RawDigit&gt; digit_ptr(digitVecHandle, iDigit);

  // store the wire in its final position in the data product;
  // the new wire is currently the last of the list
  wirecol-&gt;push_back(std::move(wire));

  // add an association between the last object in wirecol
  // (that we just inserted) and digit_ptr
  if (!util::CreateAssn(*this, evt, *wirecol, digit_ptr, *WireDigitAssn, spill_name)) {
    throw art::Exception(art::errors::ProductRegistrationFailure)
      &lt;&lt; "Can't associate wire #" &lt;&lt; (wirecol-&gt;size() - 1)
      &lt;&lt; " with raw digit #" &lt;&lt; digit_ptr.key();
  } // if failed to add association

} // for digits

evt.put(std::move(wirecol), spill_name);
evt.put(std::move(WireDigitAssn), spill_name);</pre> 
<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00586">586</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;{</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  <span class="keywordflow">if</span> (index == UINT_MAX) index = a.size()-1;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    assn.addSingle(b, art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>, a_instance}(index));</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;  }</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  }</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;} <span class="comment">// util::CreateAssn() [01]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4f954b6e1387f04d37853f5d28d1ad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between a new product and one already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The product already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64121ddfe053b75a7563b6fd6cdc05a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between each of a series of new products and one already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The product already in the event </td></tr>
    <tr><td class="paramname">begin_indx</td><td>Which element of <em>a</em> to associate first. </td></tr>
    <tr><td class="paramname">end_indx</td><td>One more than the index of the last element to associate </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6afc8c0b9fe1897a99b07acb8eda03ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; U, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a single one-to-one association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the object already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>art::Ptr to the (new) object to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>The instance name of the product a will be in is assumed empty. Example of usage: </p>
<pre class="fragment">// this is the original list of digits, thawed from the event
art::Handle&lt; std::vector&lt;raw::RawDigit&gt;&gt; digitVecHandle;
evt.getByLabel(DigitModuleLabel, digitVecHandle);

// the collection of wires that will be written as data product
std::unique_ptr&lt;std::vector&lt;recob::Wire&gt;&gt; wirecol(new std::vector&lt;recob::Wire&gt;);
// ... and an association set
std::unique_ptr&lt;art::Assns&lt;raw::RawDigit,recob::Wire&gt;&gt; WireDigitAssn
  (new art::Assns&lt;raw::RawDigit,recob::Wire&gt;);

for(size_t iDigit = 0; iDigit &lt; digitVecHandle-&gt;size(); ++iDigit) {
  // turn the digit into a art::Ptr:
  art::Ptr&lt;raw::RawDigit&gt; digit_ptr(digitVecHandle, iDigit);

  // store the wire in its final position in the data product;
  // the new wire is currently the last of the list
  wirecol-&gt;push_back(std::move(wire));

  // add an association between the last object in wirecol
  // (that we just inserted) and digit_ptr
  if (!util::CreateAssn(*this, evt, *wirecol, digit_ptr, *WireDigitAssn)) {
    throw art::Exception(art::errors::ProductRegistrationFailure)
      &lt;&lt; "Can't associate wire #" &lt;&lt; (wirecol-&gt;size() - 1)
      &lt;&lt; " with raw digit #" &lt;&lt; digit_ptr.key();
  } // if failed to add association

} // for digits

evt.put(std::move(wirecol));
evt.put(std::move(WireDigitAssn));</pre> 
<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00214">214</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ac016dc123242a7f1d5c81594de910717">CreateAssn</a>(<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>, a, b, assn, std::string(), index); }</div>
<div class="ttc" id="namespaceutil_html_ac016dc123242a7f1d5c81594de910717"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ac016dc123242a7f1d5c81594de910717">util::CreateAssn</a></div><div class="ttdeci">bool CreateAssn(art::Event &amp;evt, std::vector&lt; T &gt; const &amp;a, art::Ptr&lt; U &gt; const &amp;b, art::Assns&lt; U, T &gt; &amp;assn, std::string a_instance, size_t index=UINT_MAX)</div><div class="ttdoc">Creates a single one-to-one association. </div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00586">lardata/lardata/Utilities/AssociationUtil.h:586</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab1443e17d916ca75562ccc169be8be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 association between two products already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A product already in the event </td></tr>
    <tr><td class="paramname">b</td><td>Another product already in the event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee7d64ae04c7c483ba9ba988ea6b54ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::PtrVector&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between a new product and a PtrVector already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The products already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc8a93d9952eeece1172eadc00924165"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; U, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-one association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of one object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the other object to associate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>art::Ptr to the first object in the association </td></tr>
    <tr><td class="paramname">b</td><td>art::Ptr to the object to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>This is the simplest way ever. Neither the event not the producer references are used. </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00613">613</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;  {</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    assn.addSingle(b, <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>);</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  }</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  }</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;} <span class="comment">// util::CreateAssn() [03]</span></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b4fa012a16b97e7dd57bc92a25166fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between products already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A product already in the event </td></tr>
    <tr><td class="paramname">b</td><td>A vector of products already in the event (the many) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03c5c22c3452dd45a9573f909e2d26f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt; &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between a new product and a vector of Ptrs already in the event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>The products already in the event </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instance</td><td>instance label for product, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c681859826ad7b4f471365cbbd1abc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::PtrVector&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>art::PtrVector to the (new) objects to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with all the ones in b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist). </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00636">636</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  {</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keywordflow">if</span>(index == UINT_MAX) index = a.size() - 1;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> aptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(index);</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    <span class="keywordflow">for</span>(art::Ptr&lt;U&gt; <span class="keyword">const</span>&amp; b_item: b) assn.addSingle(aptr, b_item);</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  }</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;} <span class="comment">// util::CreateAssn() [04]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad0f4e842bd95578d29f8e0a17cf12acd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indx</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instancea</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instanceb</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to many association between new products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>Another collection about to be added to the event </td></tr>
    <tr><td class="paramname">startU</td><td>The first element of <em>b</em> to associate </td></tr>
    <tr><td class="paramname">endU</td><td>The last element of <em>b</em> to associate +1 (like STL <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a> and <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a>) </td></tr>
    <tr><td class="paramname">indx</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instancea</td><td>instance label for product a, defaulted to be an empty string </td></tr>
    <tr><td class="paramname">instanceb</td><td>instance label for product b, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1778565e1c5c9e755cd8c80581ffbccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::EDFilter const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxb</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxa</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instancea</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instanceb</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1 to 1 between new products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A collection about to be added to the event </td></tr>
    <tr><td class="paramname">b</td><td>Another collection about to be added to the event </td></tr>
    <tr><td class="paramname">indxb</td><td>Which element of <em>b</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">indxa</td><td>Which element of <em>a</em> to associate. By default the last one. </td></tr>
    <tr><td class="paramname">instancea</td><td>instance label for product a, defaulted to be an empty string </td></tr>
    <tr><td class="paramname">instanceb</td><td>instance label for product b, defaulted to be an empty string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94a92868911ae6540a306c33c3f92e0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>art::Ptr to the item to be associated with many </td></tr>
    <tr><td class="paramname">b</td><td>vector to art::Ptr to the (new) objects to be associated to a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist). </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00661">661</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  {</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keywordflow">for</span> (art::Ptr&lt;U&gt; <span class="keyword">const</span>&amp; b_item: b) assn.addSingle(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, b_item);</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  }</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  <span class="keywordflow">catch</span>(cet::exception <span class="keyword">const</span>&amp; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  }</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;} <span class="comment">// util::CreateAssn() [05]</span></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a901e9bb0c43ca9f79cf6b227b0783ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; U &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>vector to art::Ptr to the (new) objects to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with all the ones in b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist). </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00683">683</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  {</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;  <span class="keywordflow">if</span> (index == UINT_MAX) index = a.size() - 1;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> aptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(index);</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    <span class="keywordflow">for</span> (art::Ptr&lt;U&gt; <span class="keyword">const</span>&amp; b_item: b) assn.addSingle(aptr, b_item);</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  }</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  }</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;} <span class="comment">// util::CreateAssn() [06]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae28abf414a9cc74066cdc86008e13da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>vector of the (new) objects to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">startU</td><td>index in b of the first element to be associated to the one in a </td></tr>
    <tr><td class="paramname">endU</td><td>index in b after the last element to be associated to the one in a </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with all the ones in b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>Use this when the objects in b are not yet stored in the event and are in a std::vector collection instead.</p>
<p>The method gets the product id for those as well as for the element in a. Also specify the range of entries to use from the std::vector collection of U objects.</p>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist). </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00709">709</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  {</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  <span class="keywordflow">if</span>(index == UINT_MAX) index = a.size() - 1;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> aptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(index);</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    art::PtrMaker&lt;U&gt; <span class="keyword">const</span> make_bptr{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>};</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = startU; i &lt; endU; ++i){</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;      assn.addSingle(aptr, make_bptr(i));</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    }</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  }</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  }</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;} <span class="comment">// util::CreateAssn() [07]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e926d6e3d7cbd5ee0171147dd12c848"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">a</td><td>vector of data products that are in, or will be put into, evt </td></tr>
    <tr><td class="paramname">b</td><td>vector of the (new) objects to be associated to the one in a </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">indices</td><td>indices of the elements in b to be associated to the one in a </td></tr>
    <tr><td class="paramname">index</td><td>index of the element in a to be associated with all the ones in b (default: the last element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>Use this when the objects in b are not yet stored in the event and are in a std::vector collection instead.</p>
<p>The method gets the product id for those as well as for the element in a. Also specify the entries to use from the std::vector collection of U objects.</p>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist). </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00740">740</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;  {</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  <span class="keywordflow">if</span>(index == UINT_MAX) index = a.size() - 1;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> aptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(index);</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    art::PtrMaker&lt;U&gt; <span class="keyword">const</span> make_bptr{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>};</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> index: indices){</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;      assn.addSingle(aptr, make_bptr(index));</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    }</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  }</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  }</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;} <span class="comment">// util::CreateAssn() [07a]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a570d47e6280798ded3546b84ad103fb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>from_second_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>to_second_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-many association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
    <tr><td class="paramname">Iter</td><td>iterator to size_t-compatible elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">first_index</td><td>index of the object of type T to be associated to all the others </td></tr>
    <tr><td class="paramname">from_second_index</td><td>iterator pointing to the first of the indices of U type objects to be associated to the one of the first type </td></tr>
    <tr><td class="paramname">to_second_index</td><td>iterator pointing after the last of the indices of U type objects to be associated to the one of the first type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>A "one-to-many" association is actually a number of one-to-one associations. If you want to keep the information of the order of the many, you may have to use an association with a data member (the third template parameter that we pretent not to exist).</p>
<p>Use this if the objects that have to be associated to the one of type T are sparse, spread across a to-be-data-product, but you have a list of the indices in the data product of the elements to associate to the one of type T. In other words, given that you have a data product "a" of type <code>std::vector&lt;T&gt;</code> and a data product "b" of type <code>std::vector&lt;U&gt;</code>, this <code>method creates an association between</code>a[first_index]<code>and </code>b[*(from_second_index)], another between <code>a[first_index]</code> and <code>b[*(from_second_index + 1)]</code>, etc.</p>
<p>The surprising concept here is that you don't need to specify neither of the collections of T or U elements. The data product is uniquely defined by its type, producer, process and product label. Here we assume that the type of the products are <code>std::vector&lt;T&gt;</code> and <code>std::vector&lt;U&gt;</code>, and that the products have empty product labels, and that the producer is prod for both of them. </p>

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00770">770</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  {</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    <span class="comment">// we declare here that we want to associate the element first_index of the</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    <span class="comment">// (only) data product of type std::vector&lt;T&gt; with other objects.</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    <span class="comment">// This is the pointer to that element:</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> first_ptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(first_index);</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    <span class="comment">// we are going to associate that element in a with a number of elements</span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    <span class="comment">// of the only data product of type std::vector&lt;U&gt;</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    art::PtrMaker&lt;U&gt; <span class="keyword">const</span> make_second_ptr{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>};</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    <span class="keywordflow">for</span> (; from_second_index != to_second_index; ++from_second_index) {</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      assn.addSingle(first_ptr, make_second_ptr(*from_second_index));</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    } <span class="comment">// while</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;  }</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;  }</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;} <span class="comment">// util::CreateAssn() [08]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a61245df67af7b4e7f877f713e51991f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Producer , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of_v&lt;art::EDProducer, Producer&gt;, bool&gt; util::CreateAssn </td>
          <td>(</td>
          <td class="paramtype">Producer const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00973">973</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                                              {</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ac016dc123242a7f1d5c81594de910717">CreateAssn</a>(std::forward&lt;Args&gt;(<a class="code" href="../../dc/d08/namespaceICARUSservices.html#a79d6f2aec6b1f718280ca90904e29b38">args</a>)...);</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  }</div>
<div class="ttc" id="namespaceICARUSservices_html_a79d6f2aec6b1f718280ca90904e29b38"><div class="ttname"><a href="../../dc/d08/namespaceICARUSservices.html#a79d6f2aec6b1f718280ca90904e29b38">ICARUSservices.args</a></div><div class="ttdeci">tuple args</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d23/ICARUSservices_8py_source.html#l00129">ICARUSservices.py:129</a></div></div>
<div class="ttc" id="namespaceutil_html_ac016dc123242a7f1d5c81594de910717"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ac016dc123242a7f1d5c81594de910717">util::CreateAssn</a></div><div class="ttdeci">bool CreateAssn(art::Event &amp;evt, std::vector&lt; T &gt; const &amp;a, art::Ptr&lt; U &gt; const &amp;b, art::Assns&lt; U, T &gt; &amp;assn, std::string a_instance, size_t index=UINT_MAX)</div><div class="ttdoc">Creates a single one-to-one association. </div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00586">lardata/lardata/Utilities/AssociationUtil.h:586</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8befbb70f73d7daf0b3133365cf91447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssnD </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename art::Assns&lt; T, U, D &gt;::data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single one-to-one association with associated data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the new object to associate </td></tr>
    <tr><td class="paramname">U</td><td>type of the many objects already in the data product or art::Ptr </td></tr>
    <tr><td class="paramname">D</td><td>type of the "metadata" coupled to this pair association </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>reference to the current event </td></tr>
    <tr><td class="paramname">assn</td><td>reference to association object where the new one will be put </td></tr>
    <tr><td class="paramname">first_index</td><td>index of the object of type T to be associated </td></tr>
    <tr><td class="paramname">second_index</td><td>index of the object of type U to be associated </td></tr>
    <tr><td class="paramname">data</td><td>"metadata" to be store in this association </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the operation was successful (can it ever fail??)</dd></dl>
<p>Use this if you want some metadata to travel together with the association. An example may be the order of the second element within a list: </p>
<pre class="fragment">size_t a_index = 2;
std::vector&lt;size_t&gt; b_indices{ 6, 9, 18, 12 };
for (size_t i = 0; i &lt; b_indices.size(); ++i)
  CreateAssn(prod, evt, assn, a_index, b_index[i], i);
</pre><p>In this way, the association between the element #2 of "a" (a vector that is not specified &ndash; nor needed &ndash; in this snippet of code) and the element #18 will be remembered as being the third (metadata value of 2). In this example metadata is of type <code>size_t</code> the association would be declared as <code>art::Assn&lt;A, B, size_t&gt;</code>. A FindMany query of that association might look like: </p>
<pre class="fragment">art::Handle&lt;std::vector&lt;A&gt;&gt; a_list; // read this from the event

art::FindMany&lt;B, size_t&gt; Query(a_list, event, ModuleLabel);

// search for the last of the objects associated to the third element:
size_t a_index = 2; // this means third element

std::vector&lt;size_t const*&gt; const&amp; metadata = Query.data(a_index);
size_t largest_index = 0, last_item = 0;
for (size_t iB = 0; iB &lt; metadata.size(); ++iB) {
  if (largest_index &gt;= *(metadata[iB])) continue;
  largest_index = *(metadata[iB]);
  last_item = iB;
} // for iB
B const&amp; lastB = Query.at(last_item);
</pre><p>In alternative, the elements and their metadata can be fetched simultaneously with: </p>
<pre class="fragment">std::vector&lt;art::Ptr&lt;B&gt;&gt; const&amp; Bs;
std::vector&lt;size_t const*&gt; const&amp; metadata;

size_t a_index = 2; // this means third element
size_t nMatches = Query.get(a_index, Bs, metadata);</pre> 
<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00804">804</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  {</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    <span class="comment">// we declare here that we want to associate the element first_index of the</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    <span class="comment">// (only) data product of type std::vector&lt;T&gt; with the other object</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> first_ptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(first_index);</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    <span class="comment">// the same to associate the element second_index of the (only)</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;    <span class="comment">// data product of type std::vector&lt;U&gt; with the first object.</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> second_ptr = art::PtrMaker&lt;U&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(second_index);</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    assn.addSingle(first_ptr, second_ptr, std::move(data));</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;  }</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  }</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;} <span class="comment">// util::CreateAssnD() [01a]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3d24ddf98f38f4c788b13084304736c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::CreateAssnD </td>
          <td>(</td>
          <td class="paramtype">art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; T, U, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>assn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename art::Assns&lt; T, U, D &gt;::data_t const &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00833">833</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;  {</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;  <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    <span class="comment">// we declare here that we want to associate the element first_index of the</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    <span class="comment">// (only) data product of type std::vector&lt;T&gt; with the other object</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> first_ptr = art::PtrMaker&lt;T&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(first_index);</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;    <span class="comment">// the same to associate the element second_index of the (only)</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    <span class="comment">// data product of type std::vector&lt;U&gt; with the first object.</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> second_ptr = art::PtrMaker&lt;U&gt;{<a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>}(second_index);</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    assn.addSingle(first_ptr, second_ptr, data);</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;  }</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  <span class="keywordflow">catch</span>(cet::exception &amp;<a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>){</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    mf::LogWarning(<span class="stringliteral">&quot;AssociationUtil&quot;</span>)</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;unable to create requested art:Assns, exception thrown: &quot;</span> &lt;&lt; <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  }</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;} <span class="comment">// util::CreateAssnD() [01b]</span></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3e6b8551ef84e353098384562a972b9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Producer , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of_v&lt;art::EDProducer, Producer&gt;, bool&gt; util::CreateAssnD </td>
          <td>(</td>
          <td class="paramtype">Producer const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00979">979</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                                               {</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a8befbb70f73d7daf0b3133365cf91447">CreateAssnD</a>(std::forward&lt;Args&gt;(<a class="code" href="../../dc/d08/namespaceICARUSservices.html#a79d6f2aec6b1f718280ca90904e29b38">args</a>)...);</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;  }</div>
<div class="ttc" id="namespaceICARUSservices_html_a79d6f2aec6b1f718280ca90904e29b38"><div class="ttname"><a href="../../dc/d08/namespaceICARUSservices.html#a79d6f2aec6b1f718280ca90904e29b38">ICARUSservices.args</a></div><div class="ttdeci">tuple args</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d23/ICARUSservices_8py_source.html#l00129">ICARUSservices.py:129</a></div></div>
<div class="ttc" id="namespaceutil_html_a8befbb70f73d7daf0b3133365cf91447"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a8befbb70f73d7daf0b3133365cf91447">util::CreateAssnD</a></div><div class="ttdeci">bool CreateAssnD(art::Event &amp;evt, art::Assns&lt; T, U, D &gt; &amp;assn, size_t first_index, size_t second_index, typename art::Assns&lt; T, U, D &gt;::data_t &amp;&amp;data)</div><div class="ttdoc">Creates a single one-to-one association with associated data. </div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00804">lardata/lardata/Utilities/AssociationUtil.h:804</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a51e536f1d793a874fa1e25c4012cd071"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T util::cube </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>More efficient cube function than pow(x,3) </p>

<p>Definition at line <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00026">26</a> of file <a class="el" href="../../d4/d5b/MathUtil_8h_source.html">MathUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>*<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>*<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>;}</div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a6673f03521899f7844189bcfd8ee5941"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a></div><div class="ttdeci">process_name opflash particleana ie x</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00090">run_opflash_electron.fcl:90</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac56bf9ebfc74bda03a0eadc58d57e54d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T util::DegreesToRadians </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the argument angle from degrees into radians. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00084">84</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a> / 180 * pi&lt;T&gt;(); }</div>
<div class="ttc" id="trackfinderalgorithms_8fcl_html_abfae2e504dfa44c403614b6cd601f99e"><div class="ttname"><a href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a></div><div class="ttdeci">finds tracks best matching by angle</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dbd/trackfinderalgorithms_8fcl_source.html#l00064">trackfinderalgorithms.fcl:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aed27837049c72a2cd23c980fc4472fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::dereference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a functor that returns <code>*ptr</code> of its argument <code>ptr</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d3/de2/structutil_1_1Dereferencer.html" title="Functor dereferencing the operand. ">util::Dereferencer</a></code></dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4">values</a>(ptrs.size());</div>
<div class="line"><a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a></div>
<div class="line">  (ptrs.cbegin(), ptrs.cend(), <a class="code" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4">values</a>.begin(), <a class="code" href="../../d6/d72/namespaceutil.html#aed27837049c72a2cd23c980fc4472fef">util::dereference</a>());</div>
</div><!-- fragment --><p> will fill the vector <code>values</code> with the values pointed by the elements in <code>ptrs</code>. </p>

<p>Definition at line <a class="el" href="../../da/d4f/operations_8h_source.html#l00125">125</a> of file <a class="el" href="../../da/d4f/operations_8h_source.html">operations.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;{ <span class="keywordflow">return</span> Dereferencer(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d84ba76bb5b6b9c6e915e1da6a3e25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.draw_iclabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00305">305</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00305"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a9d84ba76bb5b6b9c6e915e1da6a3e25e">  305</a></span>&#160;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a9d84ba76bb5b6b9c6e915e1da6a3e25e">draw_iclabel</a>():</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    exp = ROOT.TLatex(0.22,0.91,<span class="stringliteral">&quot;ICARUS Sample&quot;</span>)</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    exp.SetNDC()</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    exp.SetTextSize(18)</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    exp.SetTextAlign(12)</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    exp.Draw()</div>
</div>
<div class="ttc" id="namespaceutil_html_a9d84ba76bb5b6b9c6e915e1da6a3e25e"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a9d84ba76bb5b6b9c6e915e1da6a3e25e">util.draw_iclabel</a></div><div class="ttdeci">def draw_iclabel</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00305">util.py:305</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a01494a9fa792a5164f54d978be3fc541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.draw_potlabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00290">290</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00290"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a01494a9fa792a5164f54d978be3fc541">  290</a></span>&#160;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a01494a9fa792a5164f54d978be3fc541">draw_potlabel</a>():</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    pot = ROOT.TLatex(0.925,0.88,<span class="stringliteral">&quot;1x10^{20} POT normalized&quot;</span>)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    pot.SetNDC()</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    pot.SetTextSize(18)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    pot.SetTextAlign(32)</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    pot.Draw()</div>
</div>
<div class="ttc" id="namespaceutil_html_a01494a9fa792a5164f54d978be3fc541"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a01494a9fa792a5164f54d978be3fc541">util.draw_potlabel</a></div><div class="ttdeci">def draw_potlabel</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00290">util.py:290</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acf86b37b7f27dd8e26cb35a61b566398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.draw_sbndlabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00312">312</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00312"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#acf86b37b7f27dd8e26cb35a61b566398">  312</a></span>&#160;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#acf86b37b7f27dd8e26cb35a61b566398">draw_sbndlabel</a>():</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    exp = ROOT.TLatex(0.22,0.91,<span class="stringliteral">&quot;SBND Sample&quot;</span>)</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    exp.SetNDC()</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    exp.SetTextSize(18)</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    exp.SetTextAlign(12)</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    exp.Draw()</div>
 </div>
<div class="ttc" id="namespaceutil_html_acf86b37b7f27dd8e26cb35a61b566398"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#acf86b37b7f27dd8e26cb35a61b566398">util.draw_sbndlabel</a></div><div class="ttdeci">def draw_sbndlabel</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00312">util.py:312</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acf4b571c6292afe0dab16baeff0d07f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.draw_sbnlabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00297">297</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#acf4b571c6292afe0dab16baeff0d07f2">  297</a></span>&#160;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#acf4b571c6292afe0dab16baeff0d07f2">draw_sbnlabel</a>():</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    sbn = ROOT.TLatex(.95, .92, <span class="stringliteral">&quot;SBN Simulation&quot;</span>)</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    sbn.SetTextColor(kGray+1)</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    sbn.SetNDC()</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    sbn.SetTextSize(20)</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    sbn.SetTextAlign(32)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    sbn.Draw()</div>
</div>
<div class="ttc" id="namespaceutil_html_acf4b571c6292afe0dab16baeff0d07f2"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#acf4b571c6292afe0dab16baeff0d07f2">util.draw_sbnlabel</a></div><div class="ttdeci">def draw_sbnlabel</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00297">util.py:297</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a83f617446509643ca091b521d5c618c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.draw_text </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00062">62</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a83f617446509643ca091b521d5c618c2">   62</a></span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a83f617446509643ca091b521d5c618c2">draw_text</a>(args):</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    textbox = <span class="keywordtype">None</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">if</span> args.text:</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        textbox = ROOT.TPaveText(*[float(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> args.text_position])</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        textbox.SetOption(<span class="stringliteral">&quot;NDC&quot;</span>)</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordflow">for</span> text <span class="keywordflow">in</span> args.text:</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            textbox.AddText(text)</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        textbox.SetMargin(0)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        textbox.SetBorderSize(0)</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        textbox.SetTextFont(args.text_font)</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        textbox.SetTextSize(args.text_size)</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        textbox.SetTextColor(args.text_color)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        textbox.SetFillStyle(0)</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        textbox.Draw()</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">return</span> textbox</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        </div>
</div>
<div class="ttc" id="namespaceutil_html_a83f617446509643ca091b521d5c618c2"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a83f617446509643ca091b521d5c618c2">util.draw_text</a></div><div class="ttdeci">def draw_text</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00062">util.py:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a343cf786ba234efafdb427e1f148ab79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Left , typename Right , typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::DumpAssociationsIntro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Assns&lt; Left, Right, <a class="el" href="../../d4/ddc/structData.html">Data</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>assns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps a short introduction about specified association. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>type of output stream </td></tr>
    <tr><td class="paramname">Left</td><td>first type in the association </td></tr>
    <tr><td class="paramname">Right</td><td>second type in the association </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d4/ddc/structData.html">Data</a></td><td>metadata type in the association </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">assns</td><td>the associations to be dumped </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d0e/DumpAssociations_8h_source.html#l00033">33</a> of file <a class="el" href="../../df/d0e/DumpAssociations_8h_source.html">DumpAssociations.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    out &lt;&lt; <span class="stringliteral">&quot;Association between &#39;&quot;</span> &lt;&lt; cet::demangle_symbol(<span class="keyword">typeid</span>(Left).<a class="code" href="../../d6/d30/sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a>())</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;&#39; and &#39;&quot;</span> &lt;&lt; cet::demangle_symbol(<span class="keyword">typeid</span>(Right).<a class="code" href="../../d6/d30/sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a>()) &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">if</span> (std::is_same&lt;Data, void&gt;()) {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      out &lt;&lt; <span class="stringliteral">&quot; with &#39;&quot;</span> &lt;&lt; cet::demangle_symbol(<span class="keyword">typeid</span>(<a class="code" href="../../d4/ddc/structData.html">Data</a>).<a class="code" href="../../d6/d30/sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a>())</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;&#39; metadata&quot;</span>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">if</span> (assns.size() &gt; 0) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      out &lt;&lt; <span class="stringliteral">&quot; contains &quot;</span> &lt;&lt; assns.size() &lt;&lt; <span class="stringliteral">&quot; relations&quot;</span>;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      out &lt;&lt; <span class="stringliteral">&quot; is empty&quot;</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    }</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  } <span class="comment">// DumpAssociationsIntro&lt;Data&gt;()</span></div>
<div class="ttc" id="structData_html"><div class="ttname"><a href="../../d4/ddc/structData.html">Data</a></div><div class="ttdef"><b>Definition:</b> <a href="../../d6/dd6/RangeForWrapper__test_8cc_source.html#l00073">RangeForWrapper_test.cc:73</a></div></div>
<div class="ttc" id="sbndpoms__genfclwithrunnumber__maker_8sh_html_a19dd16849ed641adb2aff777fdc4bd8b"><div class="ttname"><a href="../../d6/d30/sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a></div><div class="ttdeci">then echo fcl name</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d30/sbndpoms__genfclwithrunnumber__maker_8sh_source.html#l00220">sbndpoms_genfclwithrunnumber_maker.sh:220</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2b1b35c6340b6c133e6047946feee983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::ECCQE </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>l_momentum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l_energy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate CCQE energy from associated lepton information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_momentum</td><td>Lepton momentum (any units, used only to get angle info) </td></tr>
    <tr><td class="paramname">l_energy</td><td>Lepton energy in GeV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCQE energy in GeV. </dd></dl>

<p>Definition at line <a class="el" href="../../da/daa/Interaction_8cxx_source.html#l00007">7</a> of file <a class="el" href="../../da/daa/Interaction_8cxx_source.html">Interaction.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                                                          {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  <span class="comment">// Based on D. Kaleko, LowEnergyExcess LArLite module ECCQECalculator</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  <span class="keywordtype">double</span> M_n = 0.939565; <span class="comment">// GeV/c^2</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  <span class="keywordtype">double</span> M_p = 0.938272; <span class="comment">// GeV/c^2</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  <span class="keywordtype">double</span> M_e = 0.000511; <span class="comment">// GeV/c^2</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  <span class="keywordtype">double</span> bindingE = 0.0300; <span class="comment">// GeV</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  <span class="keywordtype">double</span> mp2 = M_p * M_p;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  <span class="keywordtype">double</span> me2 = M_e * M_e;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  <span class="keywordtype">double</span> mnb = M_n - bindingE;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  TVector3 v(l_momentum);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keywordtype">double</span> l_mom = sqrt(l_energy * l_energy - me2);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keywordtype">double</span> l_theta = \</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    acos(v.Pz() / sqrt(v.Px()*v.Px() + v.Py()*v.Py() + v.Pz()*v.Pz()));</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keywordtype">double</span> enu_top = mp2 - mnb*mnb - me2 + 2.0 * mnb * l_energy;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="keywordtype">double</span> enu_bot = 2.0 * (mnb - l_energy + l_mom * cos(l_theta));</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <span class="keywordflow">return</span> enu_top / enu_bot;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0615b7538ff948ea65d5206a23c84f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Lead, typename... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::enumerate </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper tracking the number of iteration. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lead</td><td>index of the parameter driving the start and end of the loop </td></tr>
    <tr><td class="paramname">Iterables</td><td>type of objects to be iterated together </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterables</td><td>all iterable objects to be iterated together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable for range-for loop</dd></dl>
<p>In the range-for loop, at each iteration this object yields a <code>tuple</code> of values, each of the type returned by dereferencing <code>begin(iterable)</code>. For example: </p>
<div class="fragment"><div class="line">constexpr std::size_t <a class="code" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a> = 4;</div>
<div class="line">std::array&lt;int, N&gt; twice;</div>
<div class="line">std::vector&lt;double&gt; thrice(N + 1);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [i, <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, b]: <a class="code" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">util::enumerate</a>(twice, thrice)) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> = 2 * i;</div>
<div class="line">  b = 3.0 * i;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> In this example, <code>N</code> iterations will be run because that is the size of the first iterable given to <code>enumerate</code>. If a different leading iterable is needed, that has to be specified as an argument. The following loop is completely equivalent to the former one: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [i, b, <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>]: util::enumerate&lt;1U&gt;(thrice, twice)) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> = 2 * i;</div>
<div class="line">  b = 3.0 * i;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> (the index is zero-based, so <code>1U</code> refers to the second argument). </p>

<p>Definition at line <a class="el" href="../../d5/d85/enumerate_8h_source.html#l00069">69</a> of file <a class="el" href="../../d5/d85/enumerate_8h_source.html">enumerate.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      <span class="keywordflow">return</span> zip&lt;Lead + 1&gt;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        (<a class="code" href="../../d6/d72/namespaceutil.html#a938e50ab383cb5972d782bc7e3814a83">infinite_counter</a>(), std::forward&lt;Iterables&gt;(iterables)...);</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
<div class="ttc" id="namespaceutil_html_a938e50ab383cb5972d782bc7e3814a83"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a938e50ab383cb5972d782bc7e3814a83">util::infinite_counter</a></div><div class="ttdeci">auto infinite_counter(T begin=T{})</div><div class="ttdoc">Version of util::counter() starting at begin and never ending. </div><div class="ttdef"><b>Definition:</b> <a href="../../d7/da2/counter_8h_source.html#l00291">counter.h:291</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af7661a52749ed0bcd221f86b51f9607a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::enumerate </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <code>enumerate</code> implicitly uses the first iterable as lead. </p>

<p>Definition at line <a class="el" href="../../d5/d85/enumerate_8h_source.html#l00077">77</a> of file <a class="el" href="../../d5/d85/enumerate_8h_source.html">enumerate.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    { <span class="keywordflow">return</span> enumerate&lt;0U&gt;(std::forward&lt;Iterables&gt;(iterables)...); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb71489058a2dd4620fb7264fa19e4c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.filespec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00040">40</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#abb71489058a2dd4620fb7264fa19e4c8">   40</a></span>&#160;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#abb71489058a2dd4620fb7264fa19e4c8">filespec</a>(inp):</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    split = inp.split(<span class="stringliteral">&quot;:&quot;</span>)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">if</span> len(split) == 1:</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">return</span> (<span class="stringliteral">&quot;input&quot;</span>, ROOT.TFile(split[0]))</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">return</span> (split[0], ROOT.TFile(split[1]))</div>
</div>
<div class="ttc" id="namespaceutil_html_abb71489058a2dd4620fb7264fa19e4c8"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#abb71489058a2dd4620fb7264fa19e4c8">util.filespec</a></div><div class="ttdeci">def filespec</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00040">util.py:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae2377386e81dcf37ed9492c880ab7527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.fillcolors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00272">272</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00272"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ae2377386e81dcf37ed9492c880ab7527">  272</a></span>&#160;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ae2377386e81dcf37ed9492c880ab7527">fillcolors</a>(index):</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    colors = [ROOT.kRed, ROOT.kGreen]</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">return</span> colors[index]</div>
</div>
<div class="ttc" id="namespaceutil_html_ae2377386e81dcf37ed9492c880ab7527"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae2377386e81dcf37ed9492c880ab7527">util.fillcolors</a></div><div class="ttdeci">def fillcolors</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00272">util.py:272</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa62da271458feca9cb29c496feea8f72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::filterRangeFor </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides iteration only through elements passing a condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">Range</a></td><td>the data to be iterated </td></tr>
    <tr><td class="paramname">Pred</td><td>the type of the predicate to be fulfilled </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the data to be iterated through </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable to be used in a range-for loop</dd></dl>
<p>This adapter makes the range for loop iterate only through the elements of <code>range</code> which fulfil the predicate <code>pred</code>.</p>
<p>This example will print: "0 3 6 9 ": </p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; data = { 0, 1, 2, 3, 4, 5, 6 ,7, 8, 9 };</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> v: <a class="code" href="../../d6/d72/namespaceutil.html#aa62da271458feca9cb29c496feea8f72">util::filterRangeFor</a>(data, [](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v % 3 == 0; })) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="../../d8/df5/messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
<div class="line"><a class="code" href="../../d8/df5/messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Note that <code>pred</code> may be copied (<code>range</code> will not be).</p>
<h2>Requirements </h2>
<ul>
<li><p class="startli"><code><a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">Range</a></code> is an object which can itself go through a range-for:</p>
<p class="startli">for (auto&amp;&amp; v: range);</p>
<p class="startli">is valid</p>
</li>
<li><code>Pred</code> is a copiable unary function type, whose single argument can be converted from the value type of <code><a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">Range</a></code>, and whose return value can be converted into a <code>bool</code> vaule </li>
</ul>

<p>Definition at line <a class="el" href="../../dd/ddd/filterRangeFor_8h_source.html#l00137">137</a> of file <a class="el" href="../../dd/ddd/filterRangeFor_8h_source.html">filterRangeFor.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    {</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      <span class="keywordflow">return</span> details::FilterRangeForStruct&lt;Range, Pred&gt;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        (std::forward&lt;Range&gt;(range), std::forward&lt;Pred&gt;(pred));</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6518536abfa795b35343e7dfacb562dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;const U*&gt; util::FindUNotAssociatedToT </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all objects of type U that are not associated to objects of type T. </p>
<p>Label is the module label that would have produced the associations and likely the objects of type T this method assumes there is a one to many relationship between T and U for example if you want to get all rb::CellHits that are not associated to rb::Clusters std::vector&lt;const rb::CellHit*&gt; hits = FindUNotAssociatedToU&lt;rb::Cluster&gt;(art::Handle&lt;rb::CellHit&gt;, ...); </p>

</div>
</div>
<a class="anchor" id="ae34b9d1584810132b1c34642fe0c2c64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const U * &gt; util::FindUNotAssociatedToT </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00864">864</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;{</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;  <span class="comment">// Do a FindOne for type T for each object of type U</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;  <span class="comment">// If the FindOne returns an invalid maybe ref, add the pointer</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;  <span class="comment">// of object type U to the return vector</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;  std::vector&lt;const U*&gt; notAssociated;</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;  art::FindOne&lt;T&gt; <span class="keyword">const</span> fa(b, <a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>, label);</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> u = 0; u &lt; b-&gt;size(); ++u){</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    cet::maybe_ref&lt;T const&gt; t(fa.at(u));</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    <span class="keywordflow">if</span>( !t.isValid() ){</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      art::Ptr&lt;U&gt; ptr(b, u);</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;      notAssociated.push_back(ptr.get());</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    }</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;  }</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;  <span class="keywordflow">return</span> notAssociated;</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;}</div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6ff0b72833fe019616c133817474d2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; art::Ptr&lt;U&gt; &gt; util::FindUNotAssociatedToTP </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all objects of type U that are not associated to objects of type T. </p>
<p>Label is the module label that would have produced the associations and likely the objects of type T this method assumes there is a one to many relationship between T and U for example if you want to get all rb::CellHits that are not associated to rb::Clusters std::vector&lt;art::Ptr&lt;rb::CellHit&gt; &gt; hits = <a class="el" href="../../d6/d72/namespaceutil.html#a5bf1b63829a628c891afea555a5da720">FindUNotAssociatedToTP&lt;rb::Cluster&gt;</a>(art::Handle&lt;rb::CellHit&gt;, ...); </p>

</div>
</div>
<a class="anchor" id="a5bf1b63829a628c891afea555a5da720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; art::Ptr&lt; U &gt; &gt; util::FindUNotAssociatedToTP </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; U &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00890">890</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;{</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="comment">// Do a FindOneP for type T for each object of type U</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;  <span class="comment">// If the FindOne returns an invalid maybe ref, add the pointer</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  <span class="comment">// of object type U to the return vector</span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  std::vector&lt; art::Ptr&lt;U&gt; &gt; notAssociated;</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  art::FindOneP&lt;T&gt; <span class="keyword">const</span> fa(b, <a class="code" href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">evt</a>, label);</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> u = 0; u &lt; b-&gt;size(); ++u){</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    cet::maybe_ref&lt;T const&gt; t(fa.at(u));</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="keywordflow">if</span>( !t.isValid() ){</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;      notAssociated.emplace_back(b, u);</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    }</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;  }</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;  <span class="keywordflow">return</span> notAssociated;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;}</div>
<div class="ttc" id="namespacetca_html_a3bc30aeace71ea50324b602afa2155f2"><div class="ttname"><a href="../../de/d0f/namespacetca.html#a3bc30aeace71ea50324b602afa2155f2">tca::evt</a></div><div class="ttdeci">TCEvent evt</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d0a/DataStructs_8cxx_source.html#l00008">DataStructs.cxx:8</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a19cc23cf942017f81281aeee4c7ba4c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::for_each_associated_group </td>
          <td>(</td>
          <td class="paramtype">A const &amp;&#160;</td>
          <td class="paramname"><em>assns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/daf/sbnana_2sbnana_2CAFAna_2Analysis_2Surface_8cxx.html#a2c3bf28add4b70497e6fd9070cd7dfc9">F</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions to access associations in order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>type of association being read </td></tr>
    <tr><td class="paramname">F</td><td>type of functor to be called on each associated group </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assns</td><td>the association being read </td></tr>
    <tr><td class="paramname">func</td><td>functor to be called on each associated group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d6/d72/namespaceutil.html#a66a267ed8783b05b951db1b985e4f057" title="Helper functions to access associations in order. ">associated_groups()</a> art::for_each_group()</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Moved into <em>canvas</em>: <code>art::for_each_group()</code>. </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html#l00049">49</a> of file <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html">ForEachAssociatedGroup.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;     { art::for_each_group(assns, func); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c01229293476942473afa9469a21638"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Indices, typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::get_const_elements </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper iterating across the constant values of the specified collection. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4" title="Range-for loop helper iterating across the values of the specified collection. ">util::values()</a></code></dd></dl>
<p>This function is equivalent to <code><a class="el" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4" title="Range-for loop helper iterating across the values of the specified collection. ">util::values()</a></code> but the values are extracted as if the specified collection were constant. </p>

</div>
</div>
<a class="anchor" id="a86614a681b6e3194af2c27467c922e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Indices, typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::get_elements </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper iterating across some of the element of each value in the specified collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Indices</td><td>indices of the elements to extract </td></tr>
    <tr><td class="paramname">Coll</td><td>type of the collection to iterate through </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>the collection to iterate through </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable for range-for loop </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a6c01229293476942473afa9469a21638" title="Range-for loop helper iterating across the constant values of the specified collection. ">util::get_const_elements()</a></code></dd></dl>
<p>This function enables range-for loops with a selection of elements from a container of <code>tuple</code> (or anything responding to <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga99bec3c9c2816248e4c948861817ed0f">util::get()</a></code>).</p>
<p>The following example fills a map using as key the first element (<code>0U</code>) of a tuple and as value the third element (<code>2U</code>): </p>
<div class="fragment"><div class="line">std::vector&lt;std::tuple&lt;char, int, float&gt;&gt; data</div>
<div class="line">  { { <span class="charliteral">&#39;z&#39;</span>, 0, 1.0F }, { <span class="charliteral">&#39;o&#39;</span>, 1, 3.0F }, { <span class="charliteral">&#39;t&#39;</span>, 2, 9.0F } };</div>
<div class="line">std::map&lt;char, double&gt; factors;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [ letter, factor ]: util::get_elements&lt;0U, 2U&gt;(data)) {</div>
<div class="line">  factors.emplace(letter, factor);</div>
<div class="line">}</div>
</div><!-- fragment --><p> If only one index is specified, the loop will not use structured binding, but rather a simple variable: </p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; exponents;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> exponent: util::get_elements&lt;1U&gt;(data)) {</div>
<div class="line">  exponents.push_back(exponent);</div>
<div class="line">}</div>
</div><!-- fragment --><p>While the examples do not demonstrate changing the values in the <code>data</code> collection, that is also supported.</p>
<dl class="section note"><dt>Note</dt><dd>This function also works with associative containers based on <code>std::pair</code> (<code>std::map</code> and the likes). </dd></dl>

</div>
</div>
<a class="anchor" id="ae95e22f641fc311d452e4b0ab6f97b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.get_tobject </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00047">47</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ae95e22f641fc311d452e4b0ab6f97b9a">   47</a></span>&#160;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ae95e22f641fc311d452e4b0ab6f97b9a">get_tobject</a>(args, name):</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">if</span> <span class="stringliteral">&quot;:&quot;</span> <span class="keywordflow">in</span> name:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        fname = name.split(<span class="stringliteral">&quot;:&quot;</span>)[0]</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        fname = <span class="stringliteral">&quot;input&quot;</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">return</span> getattr(args, fname).Get(name.split(<span class="stringliteral">&quot;:&quot;</span>)[-1])</div>
</div>
<div class="ttc" id="namespaceutil_html_ae95e22f641fc311d452e4b0ab6f97b9a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae95e22f641fc311d452e4b0ab6f97b9a">util.get_tobject</a></div><div class="ttdeci">def get_tobject</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00047">util.py:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaad77dda9b06a4598bea92f328bc7e76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; size_t &gt; &gt; util::GetAssociatedVectorManyI </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; art::Assns&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Handle&lt; std::vector&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>index_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00938">938</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;{</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;  std::vector&lt; std::vector&lt;size_t&gt; &gt; associated_indices(index_p-&gt;size());</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pair : *<a class="code" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>)</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    associated_indices.at(pair.first.key()).push_back(pair.second.key());</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;  <span class="keywordflow">return</span> associated_indices;</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;}</div>
<div class="ttc" id="getStatistics_8sh_html_a04d4c2131ccb24cc78386597e8a21c5b"><div class="ttname"><a href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a></div><div class="ttdeci">while getopts h</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/de2/getStatistics_8sh_source.html#l00013">getStatistics.sh:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23324fc3481d806fa12b9ced6f904c08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; const U * &gt; &gt; util::GetAssociatedVectorManyP </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; art::Assns&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Handle&lt; std::vector&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>index_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00949">949</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;{</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;  std::vector&lt; std::vector&lt;const U*&gt; &gt; associated_pointers(index_p-&gt;size());</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pair : *<a class="code" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>)</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;    associated_pointers.at(pair.first.key()).push_back( &amp;(*(pair.second)) );</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;  <span class="keywordflow">return</span> associated_pointers;</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;}</div>
<div class="ttc" id="getStatistics_8sh_html_a04d4c2131ccb24cc78386597e8a21c5b"><div class="ttname"><a href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a></div><div class="ttdeci">while getopts h</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/de2/getStatistics_8sh_source.html#l00013">getStatistics.sh:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a24ab92d0904f321db37740cd35c427fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; util::GetAssociatedVectorOneI </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; art::Assns&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Handle&lt; std::vector&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>index_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00916">916</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;{</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  std::vector&lt;size_t&gt; associated_index(index_p-&gt;size());</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pair : *<a class="code" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>)</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    associated_index.at(pair.first.key()) = pair.second.key();</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;  <span class="keywordflow">return</span> associated_index;</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;}</div>
<div class="ttc" id="getStatistics_8sh_html_a04d4c2131ccb24cc78386597e8a21c5b"><div class="ttname"><a href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a></div><div class="ttdeci">while getopts h</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/de2/getStatistics_8sh_source.html#l00013">getStatistics.sh:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa9e14dfb9470b263283607c381695bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const U * &gt; util::GetAssociatedVectorOneP </td>
          <td>(</td>
          <td class="paramtype">art::Handle&lt; art::Assns&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Handle&lt; std::vector&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>index_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html#l00927">927</a> of file <a class="el" href="../../d5/d9c/lardata_2lardata_2Utilities_2AssociationUtil_8h_source.html">lardata/lardata/Utilities/AssociationUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;{</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  std::vector&lt;const U*&gt; associated_pointer(index_p-&gt;size());</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pair : *<a class="code" href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a>)</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    associated_pointer.at(pair.first.key()) = &amp;(*(pair.second));</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  <span class="keywordflow">return</span> associated_pointer;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;}</div>
<div class="ttc" id="getStatistics_8sh_html_a04d4c2131ccb24cc78386597e8a21c5b"><div class="ttname"><a href="../../dd/de2/getStatistics_8sh.html#a04d4c2131ccb24cc78386597e8a21c5b">h</a></div><div class="ttdeci">while getopts h</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/de2/getStatistics_8sh_source.html#l00013">getStatistics.sh:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99fdd67e7ecbab0d50595428482dbfd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Groups &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::groupByIndex </td>
          <td>(</td>
          <td class="paramtype">Groups &amp;&amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the group within <code>groups</code> with the specified index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Groups</td><td>the type of collection of groups </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>the collection of all groups </td></tr>
    <tr><td class="paramname">index</td><td>the index of the group to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group with specified index (may be a reference) </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a66a267ed8783b05b951db1b985e4f057" title="Helper functions to access associations in order. ">associated_groups()</a></code></dd></dl>
<p>The <code>groups</code> argument is expected to be the one returned by <code>associated_groups</code>. </p>

<p>Definition at line <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html#l00180">180</a> of file <a class="el" href="../../d3/d6b/ForEachAssociatedGroup_8h_source.html">ForEachAssociatedGroup.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    { <span class="keywordflow">return</span> *(std::next(groups.begin(), index)); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a460884f7c7be5ebcb68581fd3910e59b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.histo_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00331">331</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a460884f7c7be5ebcb68581fd3910e59b">  331</a></span>&#160;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a460884f7c7be5ebcb68581fd3910e59b">histo_list</a>(inp):</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    inp = inp.split(<span class="stringliteral">&quot;,&quot;</span>)</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    in_parens = <span class="keyword">False</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    out = []</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> inp:</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">if</span> name.startswith(<span class="stringliteral">&quot;(&quot;</span>):</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            assert(<span class="keywordflow">not</span> in_parens)</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            in_parens = <span class="keyword">True</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            name = name.lstrip(<span class="stringliteral">&quot;(&quot;</span>)</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            out.append([name])</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordflow">elif</span> name.endswith(<span class="stringliteral">&quot;)&quot;</span>):</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            assert(in_parens)</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            in_parens = <span class="keyword">False</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            name = name.rstrip(<span class="stringliteral">&quot;)&quot;</span>)</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            out[-1].append(name)</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">elif</span> in_parens:</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;            out[-1].append(name)</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            out.append([name])</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">return</span> out</div>
</div>
<div class="ttc" id="namespaceutil_html_a460884f7c7be5ebcb68581fd3910e59b"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a460884f7c7be5ebcb68581fd3910e59b">util.histo_list</a></div><div class="ttdeci">def histo_list</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00331">util.py:331</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a938e50ab383cb5972d782bc7e3814a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::infinite_counter </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>begin</em> = <code>T{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <code><a class="el" href="../../d6/d72/namespaceutil.html#a9462a726cd010ab8ada5eead879a4b9f" title="Returns an object to iterate values from begin to end in a range-for loop. ">util::counter()</a></code> starting at <code>begin</code> and never ending. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of counter value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the count to start from (default-constructed, usually some form of <code>0</code>, by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a control object for range-for loop</dd></dl>
<p>An example of usage: </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned char&gt; data;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> ch: util::infinite_counter&lt;unsigned char&gt;()) {</div>
<div class="line">  <span class="keywordflow">if</span> (data.size() &gt;= 512U) <span class="keywordflow">break</span>;</div>
<div class="line">  data.push_back(ch);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This loop runs through the full range of a character (8 bits, supposedly) twice before being broken. </p>

<p>Definition at line <a class="el" href="../../d7/da2/counter_8h_source.html#l00291">291</a> of file <a class="el" href="../../d7/da2/counter_8h_source.html">counter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;{</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d5/d70/structutil_1_1span.html">util::span</a></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    (count_iterator(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>), details::infinite_endcount_iterator&lt;T&gt;());</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;} <span class="comment">// util::infinite_counter()</span></div>
<div class="ttc" id="structutil_1_1span_html"><div class="ttname"><a href="../../d5/d70/structutil_1_1span.html">util::span</a></div><div class="ttdoc">Simple class with a begin and an end. </div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00125">span.h:125</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a34dfade21c61885697d926440f77118a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">art::InputTag util::inputTagOf </td>
          <td>(</td>
          <td class="paramtype">Event const &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::ProductID const &amp;&#160;</td>
          <td class="paramname"><em>productID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the input tag of the producer of <code>productID</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event</td><td>type of event to read data from (<code>art::Event</code> interface) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>event to read data products from </td></tr>
    <tr><td class="paramname">productID</td><td>reference data product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input tag of the producer of <code>productID</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">art::Exception</td><td>(error code: <code>art::errors::ProductNotFound</code>) if no input tag could be found</td></tr>
  </table>
  </dd>
</dl>
<p>This utility facilitates the traversal of associations. Assuming that a pointer to a data product element is available, we may need to read another data product from the same producer (e.g. from a pointer to a <code><a class="el" href="../../d9/dca/classrecob_1_1Track.html" title="Track from a non-cascading particle.A recob::Track consists of a recob::TrackTrajectory, plus additional members relevant for a &quot;fitted&quot; track: ">recob::Track</a></code> from a collection, we want to learn the associations of that track to <code><a class="el" href="../../db/d4e/classrecob_1_1Hit.html" title="2D representation of charge deposited in the TDC/wire plane ">recob::Hit</a></code>, assuming that the same module that produced the tracks also produced their associations to hit). This is trivial if the input tag of the data product element is known, but it's not if that data product is instead known only by a pointer/association. In that case, this function discovers the needed input tag. Example: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; assns</div>
<div class="line">  = <span class="keyword">event</span>.getProduct&lt;std::vector&lt;recob::Hit&gt;&gt;(<a class="code" href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">inputTagOf</a>(trackPtr.id()));</div>
</div><!-- fragment --><p> where <code>trackPtr</code> is a <code>art::Ptr&lt;<a class="el" href="../../d9/dca/classrecob_1_1Track.html" title="Track from a non-cascading particle.A recob::Track consists of a recob::TrackTrajectory, plus additional members relevant for a &quot;fitted&quot; track: ">recob::Track</a>&gt;</code> that may come for example from a <code><a class="el" href="../../dc/d21/classrecob_1_1PFParticle.html" title="Hierarchical representation of particle flow. ">recob::PFParticle</a></code>/<code><a class="el" href="../../d9/dca/classrecob_1_1Track.html" title="Track from a non-cascading particle.A recob::Track consists of a recob::TrackTrajectory, plus additional members relevant for a &quot;fitted&quot; track: ">recob::Track</a></code> association. </p>

<p>Definition at line <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html#l00108">108</a> of file <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html">CanvasUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;{</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  cet::exempt_ptr&lt;art::BranchDescription const&gt; metaDescr</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    = <span class="keyword">event</span>.getProductDescription(productID);</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordflow">if</span> (metaDescr) <span class="keywordflow">return</span> metaDescr-&gt;inputTag();</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="keywordflow">throw</span> art::Exception(art::errors::ProductNotFound)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    &lt;&lt; <span class="stringliteral">&quot;Branch (and input tag) not found for product ID &quot;</span> &lt;&lt; productID;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;} <span class="comment">// util::inputTagOf()</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a48b3baf272be38961453b208e3f8cd44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_void_v&lt;std::void_t&lt;typename Handle::HandleTag&gt; &gt;, art::InputTag &gt; util::inputTagOf </td>
          <td>(</td>
          <td class="paramtype">Event const &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle const &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the input tag of the product with the specified <code>handle</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event</td><td>type of event to read data from (<code>art::Event</code> interface) </td></tr>
    <tr><td class="paramname">Handle</td><td>type of handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>event to read data products from </td></tr>
    <tr><td class="paramname">handle</td><td>data product handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input tag of the producer of data product at <code>handle</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">art::Exception</td><td>(error code: <code>art::errors::ProductNotFound</code>) if no input tag could be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code>inputTag(Event const&amp;, art::ProductID const&amp;)</code></dd></dl>
<p>This utility is a wrapper of the version working on product ID. </p>

<p>Definition at line <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html#l00075">75</a> of file <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html">CanvasUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">inputTagOf</a>(event, handle.id()); }</div>
<div class="ttc" id="namespaceutil_html_a34dfade21c61885697d926440f77118a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">util::inputTagOf</a></div><div class="ttdeci">art::InputTag inputTagOf(Event const &amp;event, art::ProductID const &amp;productID)</div><div class="ttdoc">Reads and returns the input tag of the producer of productID. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dc2/CanvasUtils_8h_source.html#l00108">CanvasUtils.h:108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae1164888fe44fc72dd6690011fbf1fc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">art::InputTag util::inputTagOf </td>
          <td>(</td>
          <td class="paramtype">Event const &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::Ptr&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the input tag of the product <code>ptr</code> points to. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event</td><td>type of event to read data from (<code>art::Event</code> interface) </td></tr>
    <tr><td class="paramname">T</td><td>type of the datum pointed by the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>event to read data products from </td></tr>
    <tr><td class="paramname">ptr</td><td><em>art</em> pointer to the data product element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input tag of the producer of data product of <code>ptr</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">art::Exception</td><td>(error code: <code>art::errors::ProductNotFound</code>) if no input tag could be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code>inputTag(Event const&amp;, art::ProductID const&amp;)</code></dd></dl>
<p>This utility is a wrapper of the version working on product ID. </p>

<p>Definition at line <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html#l00093">93</a> of file <a class="el" href="../../dc/dc2/CanvasUtils_8h_source.html">CanvasUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">inputTagOf</a>(event, ptr.id()); }</div>
<div class="ttc" id="namespaceutil_html_a34dfade21c61885697d926440f77118a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a34dfade21c61885697d926440f77118a">util::inputTagOf</a></div><div class="ttdeci">art::InputTag inputTagOf(Event const &amp;event, art::ProductID const &amp;productID)</div><div class="ttdoc">Reads and returns the input tag of the producer of productID. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dc2/CanvasUtils_8h_source.html#l00108">CanvasUtils.h:108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ada4b435aac9795179f8e857019c76202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.int_pair </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00217">217</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ada4b435aac9795179f8e857019c76202">  217</a></span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ada4b435aac9795179f8e857019c76202">int_pair</a>(inp):</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">return</span> [int(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> inp.split(<span class="stringliteral">&quot;,&quot;</span>)][:2]</div>
</div>
<div class="ttc" id="namespaceutil_html_ada4b435aac9795179f8e857019c76202"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ada4b435aac9795179f8e857019c76202">util.int_pair</a></div><div class="ttdeci">def int_pair</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00217">util.py:217</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c558614ad447b70894ec6e7456f94ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T util::ipow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>More efficient exponentiation function than pow(x,n) for small n. </p>

<p>Definition at line <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00029">29</a> of file <a class="el" href="../../d4/d5b/MathUtil_8h_source.html">MathUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    T ret = 1; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">n</a> == 0) <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt;= <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">n</a>; ++i) ret *= <a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  }</div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a6673f03521899f7844189bcfd8ee5941"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a></div><div class="ttdeci">process_name opflash particleana ie x</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00090">run_opflash_electron.fcl:90</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_ab6cfbbcbb53c275375289d47dec67f46"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">channelDBConverter.n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00249">channelDBConverter.py:249</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad18509a1ee0c6aed41a4ffd6163a8842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.legend_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00319">319</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ad18509a1ee0c6aed41a4ffd6163a8842">  319</a></span>&#160;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ad18509a1ee0c6aed41a4ffd6163a8842">legend_position</a>(inp):</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">if</span> inp == <span class="stringliteral">&quot;</span><span class="stringliteral">ur&quot;:</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="stringliteral">        </span><span class="keywordflow">return</span> [0.75,0.75,0.95,0.95]</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keywordflow">elif</span> inp == <span class="stringliteral">&quot;ul&quot;</span>:</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">return</span> [0.35,0.75,0.15,0.95]</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">elif</span> inp == <span class="stringliteral">&quot;um&quot;</span>:</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keywordflow">return</span> [0.4, 0.69, 0.6, 0.89]</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="keywordflow">elif</span> inp == <span class="stringliteral">&quot;lr&quot;</span>:</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keywordflow">return</span> [0.75,0.15,0.95,0.35]</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">return</span> [float(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> inp.split(<span class="stringliteral">&quot;,&quot;</span>)][:4]</div>
</div>
<div class="ttc" id="namespaceutil_html_ad18509a1ee0c6aed41a4ffd6163a8842"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ad18509a1ee0c6aed41a4ffd6163a8842">util.legend_position</a></div><div class="ttdeci">def legend_position</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00319">util.py:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a51696cc45fda3ac2b4336f39639d6685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Adaptor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_adapted_const_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Adaptor &amp;&amp;&#160;</td>
          <td class="paramname"><em>adaptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates constant iteration span from specified collection via an adaptor. </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00269">269</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">make_adapted_span</a>(</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        span_base::get_cbegin(cont), span_base::get_cend(cont),</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        std::forward&lt;Adaptor&gt;(adaptor)</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        );</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    }</div>
<div class="ttc" id="namespaceutil_html_ab9b7f1582941ed1c7c4eaf5f5eb26903"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span</a></div><div class="ttdeci">auto make_adapted_span(BIter begin, EIter end, Adaptor &amp;&amp;adaptor)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00223">span.h:223</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9b7f1582941ed1c7c4eaf5f5eb26903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter , typename Adaptor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_adapted_span </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Adaptor &amp;&amp;&#160;</td>
          <td class="paramname"><em>adaptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a span from specified iterators via an adaptor. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a65416c3fa16554ba175c505293ea081f" title="Creates a span from specified collection via an adaptor. ">make_adapted_span(Cont&amp;, Adaptor&amp;&amp;)</a></code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00223">223</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d5/d70/structutil_1_1span.html">util::span</a>(adaptor(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>), adaptor(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>)); }</div>
<div class="ttc" id="structutil_1_1span_html"><div class="ttname"><a href="../../d5/d70/structutil_1_1span.html">util::span</a></div><div class="ttdoc">Simple class with a begin and an end. </div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00125">span.h:125</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65416c3fa16554ba175c505293ea081f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Adaptor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_adapted_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Adaptor &amp;&amp;&#160;</td>
          <td class="paramname"><em>adaptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span from specified collection via an adaptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>collection to be iterated through </td></tr>
    <tr><td class="paramname">adapter</td><td>iterator transformation to be applied on <code>cont</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="../../d5/d70/structutil_1_1span.html" title="Simple class with a begin and an end. ">util::span</a></code> object iterating via an adapter to <code>cont</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">make_adapted_span(BIter, EIter, Adaptor&amp;&amp;)</a></code>, <code>make_adapted_const_span(Cont, Adaptor&amp;&amp;)</code></dd></dl>
<p>This interface is just a little help on using <em>iterator</em> adapters. Note that <code>adapter</code> transforms the iterators of <code>cont</code>, not its values. The adapter needs to be written aside and it's in general not trivial. An example of iterating through a collection of objects (actually, just <code>float</code> for simplicity) stored as unique pointers in a collection: </p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> accumulate(<a class="code" href="../../db/dfa/namespacelar_1_1dump.html#a71d4403edbac4d265176f8677118194f">std::vector</a>&lt;std::unique_ptr&lt;float&gt;&gt; <span class="keyword">const</span>&amp; v) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> src_iterator = std::vector&lt;std::unique_ptr&lt;float&gt;&gt;::const_iterator;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> sum = 0.0F;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">float</span> v: <a class="code" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span</a>(v, boost::make_indirect_iterator&lt;src_iterator&gt;))</div>
<div class="line">    sum += v;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> sum;</div>
<div class="line">} <span class="comment">// accumulate()</span></div>
</div><!-- fragment --><p> This example shows the usage of <code><a class="el" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span()</a></code>. In the specific example, it would have been more explicit to use the constant counterpart, <code><a class="el" href="../../d6/d72/namespaceutil.html#a51696cc45fda3ac2b4336f39639d6685" title="Creates constant iteration span from specified collection via an adaptor. ">util::make_adapted_const_span()</a></code>. The adaptor helper <code>boost::make_indirect_iterator()</code> is provided in <code>boost/iterator/indirect_iterator.hpp</code>. </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00258">258</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">make_adapted_span</a>(</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        span_base::get_begin(cont), span_base::get_end(cont),</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        std::forward&lt;Adaptor&gt;(adaptor)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        );</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div>
<div class="ttc" id="namespaceutil_html_ab9b7f1582941ed1c7c4eaf5f5eb26903"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span</a></div><div class="ttdeci">auto make_adapted_span(BIter begin, EIter end, Adaptor &amp;&amp;adaptor)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00223">span.h:223</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9e70798d0a3cc7f9b4d294b2b616a8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_const_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span with constant iterator access from a container type. </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00206">206</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="keywordflow">return</span> span{ span_base::get_cbegin(cont), span_base::get_cend(cont) };</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72a30797c98a8c53b51848fcfd82700d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_span </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span from specified iterators (can use constructor instead). </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00197">197</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d5/d70/structutil_1_1span.html">util::span</a>(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>); }</div>
<div class="ttc" id="structutil_1_1span_html"><div class="ttname"><a href="../../d5/d70/structutil_1_1span.html">util::span</a></div><div class="ttdoc">Simple class with a begin and an end. </div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00125">span.h:125</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47bb447f8910e14763c8273cb72ca0a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span from a container type. </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00201">201</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    { <span class="keywordflow">return</span> span{ span_base::get_begin(cont), span_base::get_end(cont) }; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72a968a7f3f63b6472274f83a2f29b39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_transformed_const_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates constant iteration span from specified collection via a transformation <code>op</code>. </p>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00353">353</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">make_transformed_span</a>(std::as_const(cont), std::forward&lt;Op&gt;(op)); }</div>
<div class="ttc" id="namespaceutil_html_ad93ad1c533f5f788da7639764cb9518b"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">util::make_transformed_span</a></div><div class="ttdeci">auto make_transformed_span(BIter begin, EIter end, Op &amp;&amp;op)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00294">span.h:294</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad93ad1c533f5f788da7639764cb9518b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_transformed_span </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a span from specified iterators via an adaptor. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#aeae61d7c3bc5e105cd93d9c1f26113b2" title="Creates a span from specified collection via an adaptor. ">make_transformed_span(Cont&amp;, Op&amp;&amp;)</a></code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00294">294</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="keyword">auto</span> adaptor</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        = [&amp;op](<span class="keyword">auto</span> iter){ <span class="keywordflow">return</span> boost::make_transform_iterator(iter, op); };</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span</a>(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>, adaptor);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    }</div>
<div class="ttc" id="namespaceutil_html_ab9b7f1582941ed1c7c4eaf5f5eb26903"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">util::make_adapted_span</a></div><div class="ttdeci">auto make_adapted_span(BIter begin, EIter end, Adaptor &amp;&amp;adaptor)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00223">span.h:223</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeae61d7c3bc5e105cd93d9c1f26113b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::make_transformed_span </td>
          <td>(</td>
          <td class="paramtype">Cont &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a span from specified collection via an adaptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>collection to be iterated through </td></tr>
    <tr><td class="paramname">adapter</td><td>iterator transformation to be applied on <code>cont</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="../../d5/d70/structutil_1_1span.html" title="Simple class with a begin and an end. ">util::span</a></code> object iterating via an adapter to <code>cont</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">make_transformed_span(BIter, EIter, Op&amp;&amp;)</a></code>, <code>make_transformed_const_span(Cont, Op&amp;&amp;)</code>, <code><a class="el" href="../../d6/d72/namespaceutil.html#ab9b7f1582941ed1c7c4eaf5f5eb26903">make_adapted_span()</a></code>,</dd></dl>
<p>This function transforms as directed by the unary operation <code>op</code> the result of each iteration cycle, so that instead of <code>cont[i]</code>, a <code>op(cont[i])</code> is assigned to the iteration control variable. An example of iterating through a collection of objects (actually, just <code>float</code> for simplicity) stored as unique pointers in a collection: </p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> accumulate(<a class="code" href="../../db/dfa/namespacelar_1_1dump.html#a71d4403edbac4d265176f8677118194f">std::vector</a>&lt;std::unique_ptr&lt;float&gt;&gt; <span class="keyword">const</span>&amp; v) {</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> sum = 0.0F;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">float</span> v: <a class="code" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">util::make_transformed_span</a>(v, [](<span class="keyword">auto</span>&amp; ptr){ <span class="keywordflow">return</span> *ptr; }))</div>
<div class="line">    sum += v;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> sum;</div>
<div class="line">} <span class="comment">// accumulate()</span></div>
</div><!-- fragment --><p> This example shows the usage of <code><a class="el" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">util::make_transformed_span()</a></code>. In the specific example, it would have been more explicit to use the constant counterpart, <code><a class="el" href="../../d6/d72/namespaceutil.html#a72a968a7f3f63b6472274f83a2f29b39">util::make_transformed_const_span()</a></code>. Note that in the example the dereference result is <em>copied</em> into <code>v</code>. For have it by reference, the operation <code>op</code> must be properly written: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> scale(<a class="code" href="../../db/dfa/namespacelar_1_1dump.html#a71d4403edbac4d265176f8677118194f">std::vector</a>&lt;std::unique_ptr&lt;float&gt;&gt;&amp; v, <span class="keywordtype">float</span> factor) {</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">float</span>&amp; v: <a class="code" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">util::make_transformed_span</a>(v, [](<span class="keyword">auto</span>&amp; ptr) -&gt; <span class="keywordtype">float</span>&amp; { <span class="keywordflow">return</span> *ptr; }))</div>
<div class="line">    v *= factor;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// scale()</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="../../d4/d7a/span_8h_source.html#l00341">341</a> of file <a class="el" href="../../d4/d7a/span_8h_source.html">span.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    {</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">make_transformed_span</a>(</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        span_base::get_begin(cont), span_base::get_end(cont),</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        std::forward&lt;Op&gt;(op)</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        );</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    }</div>
<div class="ttc" id="namespaceutil_html_ad93ad1c533f5f788da7639764cb9518b"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ad93ad1c533f5f788da7639764cb9518b">util::make_transformed_span</a></div><div class="ttdeci">auto make_transformed_span(BIter begin, EIter end, Op &amp;&amp;op)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00294">span.h:294</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4eb96d0ec103986b67eaeda56792523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeIndented </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>firstIndent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an indented stream wrapper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>the type of stream being wrapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to wrap </td></tr>
    <tr><td class="paramname">indent</td><td>string inserted at the beginning of each new line </td></tr>
    <tr><td class="paramname">firstIndent</td><td>string inserted at the beginning of the first line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an indented stream wrapper </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>addIndent()</code></dd></dl>
<p>The use of the wrapper stream is explained in <code>addIndent()</code>.</p>
<p>This function wraps a stream <code>out</code>, stealing it if it's a temporary, and returns the wrapping object. This object can be used for indented output to <code>out</code> until it is destroyed (if <code>out</code> is referenced as opposed to stolen, <code>out</code> itself needs to stay valid).</p>
<p>If not specified, <code>firstIndent</code> is assigned to be the same as <code>indent</code>.</p>
<p>The equivalent two-line example of <code>addIndent()</code> becomes: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> out = <a class="code" href="../../d6/d72/namespaceutil.html#ae4eb96d0ec103986b67eaeda56792523">util::makeIndented</a>(<a class="code" href="../../d8/df5/messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a>, <span class="stringliteral">&quot;&gt; &quot;</span>, <span class="stringliteral">&quot;$ &quot;</span>);</div>
<div class="line">out &lt;&lt; <span class="stringliteral">&quot;First line: indented with &#39;$ &#39;.&quot;</span></div>
<div class="line">  &lt;&lt; <span class="stringliteral">&quot;\nSecond line: indented with &#39;&gt; &#39;.&quot;</span></div>
<div class="line">  ;</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html#l00176">176</a> of file <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html">StreamIndenter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;{</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">return</span> details::IndentAdder</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    { std::forward&lt;Stream&gt;(out), std::move(indent), std::move(firstIndent) };</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a299fa63cb45bbb0570165f3c779f0487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeIndented </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html#l00185">185</a> of file <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html">StreamIndenter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#ae4eb96d0ec103986b67eaeda56792523">makeIndented</a>(out, indent, indent); }</div>
<div class="ttc" id="namespaceutil_html_ae4eb96d0ec103986b67eaeda56792523"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae4eb96d0ec103986b67eaeda56792523">util::makeIndented</a></div><div class="ttdeci">auto makeIndented(Stream &amp;&amp;out, std::string indent, std::string firstIndent)</div><div class="ttdoc">Creates an indented stream wrapper. </div><div class="ttdef"><b>Definition:</b> <a href="../../d2/ddb/StreamIndenter_8h_source.html#l00176">StreamIndenter.h:176</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a38f3c0e9aaa9c0640cefeb60a7abeb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename KeyOf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; util::MakeIndex </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyOf&#160;</td>
          <td class="paramname"><em>key_of</em> = <code>KeyOf()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a map of indices from an existing collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of the collection </td></tr>
    <tr><td class="paramname">KeyOf</td><td>type of the extractor of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data collection </td></tr>
    <tr><td class="paramname">key_of</td><td>instance of a functor extracting a key value from a datum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with indices corresponding to the data keys</dd></dl>
<p>This function maps the index of the items in data to an integral key extracted from each item. For example, if the items are wires and the key_of function extracts their channel ID, the resulting vector will contain for each channel ID the index in data of the wire with that channel ID.</p>
<p>The key is converted into a unsigned integer (<code>size_t</code>). If multiple items have the same key, the outcome for that key is undefined. If no items has a specific key, the index of that key is assigned as </p>
<div class="fragment"><div class="line">std::numeric_limits&lt;size_t&gt;::max() </div>
</div><!-- fragment --><p>, i.e. an index larger than the size of the original data collection.</p>
<p>The returned vector is big enough to accommodate indices corresponding to the keys of all the items in data. It may contain "holes" (that is, some keys that have no corresponding items have a </p>
<div class="fragment"><div class="line">std::numeric_limits&lt;size_t&gt;::max() </div>
</div><!-- fragment --><p> value). The memory allocated for the vector may be larger than necessary (if that is a problem, <code>std::vector::shrink_to_fit()</code> can be used, but it may create more problems than it solves). </p>

<p>Definition at line <a class="el" href="../../db/d89/MakeIndex_8h_source.html#l00043">43</a> of file <a class="el" href="../../db/d89/MakeIndex_8h_source.html">MakeIndex.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                                                        {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="comment">// we start the index with the best guess that all the items will have</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="comment">// a unique key and they are contiguous:</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="comment">// the index would have the same size as the data</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    std::vector&lt;size_t&gt; Index(data.size(), std::numeric_limits&lt;size_t&gt;::max());</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordtype">size_t</span> min_size = 0; <span class="comment">// minimum size needed to hold all keys</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordtype">size_t</span> iDatum = 0;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; datum: data) {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <span class="keywordtype">size_t</span> key = size_t(key_of(datum));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      <span class="keywordflow">if</span> (key &gt;= min_size) min_size = key + 1;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      <span class="keywordflow">if</span> (Index.size() &lt;= key) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="comment">// make room for the entry: double the size</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        Index.resize(</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;          std::max(key + 1, Index.size() * 2),</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;          std::numeric_limits&lt;size_t&gt;::max()</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;          );</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      } <span class="comment">// if expand index</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      Index[key] = iDatum;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      ++iDatum;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    } <span class="comment">// for datum</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    Index.resize(min_size);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> Index;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  } <span class="comment">// MakeIndex()</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18642be0ec704376f3a90a55a6258587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename KeyOf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::MakeMap </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyOf&#160;</td>
          <td class="paramname"><em>key_of</em> = <code>KeyOf()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::vector&lt;decltype(key_of(*(<a class="el" href="../../df/db6/geo__vectors__utils__TVector_8h.html#abd762dc0ccf00b6ee7f81a289b7bd4f8">data.begin</a>()))) const*&gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a map of objects from an existing collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of the collection </td></tr>
    <tr><td class="paramname">KeyOf</td><td>type of the extractor of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data collection </td></tr>
    <tr><td class="paramname">key_of</td><td>instance of a functor extracting a key value from a datum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with pointers to data corresponding to their keys</dd></dl>
<p>This function maps the items in data to an integral key extracted from each of them. For example, if the items are wires and the key_of function extracts their channel ID, the resulting vector will contain for each channel ID the pointer to the wire with that channel ID.</p>
<p>The key is converted into a unsigned integer (<code>size_t</code>). If multiple items have the same key, the outcome for that key is undefined. If no items has a specific key, the index of that key is assigned a null pointer.</p>
<p>The returned vector is big enough to accommodate pointers corresponding to the keys of all the items in data. It may contain "holes" (that is, some keys that have no corresponding items have a null pointer value). The memory allocated for the vector may be larger than necessary (if that is a problem, <code>std::vector::shrink_to_fit()</code> can be used, but it may create more problems than it solves). </p>

<p>Definition at line <a class="el" href="../../db/d89/MakeIndex_8h_source.html#l00099">99</a> of file <a class="el" href="../../db/d89/MakeIndex_8h_source.html">MakeIndex.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keyword">using</span> Mapped_t = decltype(key_of(*(data.begin())));</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keyword">using</span> Ptr_t = Mapped_t <span class="keyword">const</span>*;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keyword">using</span> Map_t = std::vector&lt;Ptr_t&gt;;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="comment">// we start the index with the best guess that all the items will have</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// a unique key and they are contiguous:</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">// the index would have the same size as the data</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    Map_t Index(data.size(), <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordtype">size_t</span> min_size = 0; <span class="comment">// minimum size needed to hold all keys</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; datum: data) {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      <span class="keywordtype">size_t</span> key = size_t(key_of(datum));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      <span class="keywordflow">if</span> (key &gt;= min_size) min_size = key + 1;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="keywordflow">if</span> (Index.size() &lt;= key) {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="comment">// make room for the entry: double the size</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        Index.resize(std::max(key + 1, Index.size() * 2), <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      } <span class="comment">// if expand index</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;      Index[key] = &amp;datum;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    } <span class="comment">// for datum</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    Index.resize(min_size);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">return</span> Index;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  } <span class="comment">// MakeMap()</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae60c2dec3570d550a2aaf9402ca13ee6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makePointerVector </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a STL vector with pointers to data from another collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>data collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a STL vector with pointers to <code>coll</code> data elements, with same order </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d40/SortByPointers_8h_source.html#l00198">198</a> of file <a class="el" href="../../dc/d40/SortByPointers_8h_source.html">SortByPointers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  { <span class="keywordflow">return</span> details::PointerVectorMaker&lt;Coll&gt;::make(coll); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aec03781f4514c89c45f6451da830fb94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... DIMS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeTensorIndices </td>
          <td>(</td>
          <td class="paramtype">DIMS...&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html" title="Converts a tensor element specification into a linear index. ">TensorIndices</a> class with the specified dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DIMS</td><td>types for each of the arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>size of each of the dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html" title="Converts a tensor element specification into a linear index. ">TensorIndices</a> object with properly initialised dimensions</dd></dl>
<p>The rank of the tensor is determined by the number of arguments; example: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="../../d0/d8e/namespacegeo_1_1vect.html#a81b45a59e7128f35719a7ba55a0f8370">indices</a> = <a class="code" href="../../d6/d72/namespaceutil.html#aec03781f4514c89c45f6451da830fb94">util::makeTensorIndices</a>(3, 4);</div>
</div><!-- fragment --><p> will initialise a <code><a class="el" href="../../dc/de3/classutil_1_1TensorIndices.html" title="Converts a tensor element specification into a linear index. ">TensorIndices</a>&lt;2&gt;</code> (that's matrix indices), for a 3 x 4 (3 rows, 4 columns) disposition. </p>

<p>Definition at line <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html#l00543">543</a> of file <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html">TensorIndices.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      <span class="keywordflow">return</span> TensorIndices&lt;<span class="keyword">sizeof</span>...(DIMS)&gt;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        { TensorIndicesBasicTypes::DimSize_t(dims)... };</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adc1d3a95ec691bb7e21db6b8699c2540"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename Extractor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::makeValueIndex </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>coll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extractor&#160;</td>
          <td class="paramname"><em>getter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of value to index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of container </td></tr>
    <tr><td class="paramname">Extractor</td><td>type of value extraction function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>container to get the map of </td></tr>
    <tr><td class="paramname">getter</td><td>function applied to each element to extract the value for map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value-to-index associative container </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if multiple elements yield the same value</td></tr>
  </table>
  </dd>
</dl>
<p>The collection <code>coll</code> is navigated in sequence from <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a></code> to <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a></code>, and a map is created where to each key, <code>getter(coll[i])</code>, the index <code>i</code> is associated. The value returned by <code>getter()</code> is copied into the key. Therefore that value needs to satisfy all the requirements of the key of the STL associative container <code>std::map</code>. Duplicate values will trigger an exception.</p>
<h2>Requirements </h2>
<p>The collection type <code>Coll</code> must have:</p>
<ul>
<li><code>value_type</code> type defining the content of the container</li>
<li>support <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a></code> and <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a></code> free functions returning input iterators, that is support a ranged-for loop </li>
</ul>

</div>
</div>
<a class="anchor" id="ab5023638aa8f2849c0d1ea4981bdbf6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeValueIndex </td>
          <td>(</td>
          <td class="paramtype">Coll const &amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../df/d1c/makeValueIndex_8h_source.html#l00061">61</a> of file <a class="el" href="../../df/d1c/makeValueIndex_8h_source.html">makeValueIndex.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#adc1d3a95ec691bb7e21db6b8699c2540">makeValueIndex</a>(coll, <a class="code" href="../../da/d49/structutil_1_1pre__std_1_1identity.html">util::pre_std::identity</a>()); }</div>
<div class="ttc" id="structutil_1_1pre__std_1_1identity_html"><div class="ttname"><a href="../../da/d49/structutil_1_1pre__std_1_1identity.html">util::pre_std::identity</a></div><div class="ttdoc">Transparent functor that returns its argument just as passed. </div><div class="ttdef"><b>Definition:</b> <a href="../../df/d23/fromFutureImport_8h_source.html#l00039">fromFutureImport.h:39</a></div></div>
<div class="ttc" id="namespaceutil_html_adc1d3a95ec691bb7e21db6b8699c2540"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#adc1d3a95ec691bb7e21db6b8699c2540">util::makeValueIndex</a></div><div class="ttdeci">decltype(auto) makeValueIndex(Coll const &amp;coll, Extractor getter)</div><div class="ttdoc">Returns a map of value to index. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa41abde744908d25ab113abcd4e67dfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Mapping &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::mapContainer </td>
          <td>(</td>
          <td class="paramtype">Cont&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a container-like object mapping the content of <code>cont</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cont</td><td>type of the original container </td></tr>
    <tr><td class="paramname">Mapping</td><td>type of mapping object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>the container </td></tr>
    <tr><td class="paramname">mapping</td><td>the mapping to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html" title="A meta-container providing transparent mapping on top of another. ">util::MappedContainer</a></code> object transparently applying the mapping</dd></dl>
<p>See <code><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html" title="A meta-container providing transparent mapping on top of another. ">util::MappedContainer</a></code> for the details on the format of the mapping, the ownership of the container and the supported operations. </p>

<p>Definition at line <a class="el" href="../../d2/df5/MappedContainer_8h_source.html#l00441">441</a> of file <a class="el" href="../../d2/df5/MappedContainer_8h_source.html">MappedContainer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    { <span class="keywordflow">return</span> MappedContainer&lt;Cont, Mapping&gt;(cont, mapping); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a648066c28180a7cdfac53270a2b4a80d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d72/namespaceutil.html#af1de93ae9853deac245708c89676409c">DataProductPointerMap_t</a>&lt;<a class="el" href="../../d6/d72/namespaceutil.html#ada5647082a33c085c6cd4556712066bb">ArtHandleData_t</a>&lt;Handle&gt; &gt; util::mapDataProductPointers </td>
          <td>(</td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle const &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a map from address of data product element to <em>art</em> pointer to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle</td><td>type of handle to data product (e.g. <code>art::ValidHandle</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><em>art</em> handle to the data product </td></tr>
    <tr><td class="paramname">event</td><td>the <em>art</em> event the data product belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map from data product element pointer to <em>art</em> pointer</dd></dl>
<p>Returns a map from the address of any of the objects in the data product in <code>event</code> pointed by <code>handle</code> and the <em>art</em> pointer to those objects. Provided that the type in the data product is <code>T</code>, the returned map is an object guaranteed to have:</p>
<ul>
<li>standard mobility (copy and move constructors and assignment operators)</li>
<li>an unckecked access operator <code>operator[] (T const*) const</code> returning some form of <code>art::Ptr&lt;T&gt;</code> (<code>art::Ptr&lt;T&gt;</code>, <code>art::Ptr&lt;T&gt; const&amp;</code>...);</li>
<li>a checked access operator <code>at(T const*) const</code> similar to <code>operator[]</code> but throwing an exception derived from <code>std::out_of_range</code> if the element is not found;</li>
<li>an <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga4e3b966025fd64bc06286a275664d957" title="ADL-aware version of std::empty. ">empty()</a></code>, a <code><a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gac583f06256b912500def4d6394b53add" title="ADL-aware version of std::size. ">size()</a></code> and a <code>clear()</code> method.</li>
</ul>
<p>Example: with <code>event</code> a <code>art::Event</code> object and <code>waveformHandle</code> an handle to a <code>std::vector&lt;<a class="el" href="../../d0/d29/classraw_1_1OpDetWaveform.html">raw::OpDetWaveform</a>&gt;</code> data product in <code>event</code>: </p>
<div class="fragment"><div class="line">DataProductPointerMap_t&lt;raw::OpDetWaveform&gt; <span class="keyword">const</span>&amp; opDetWavePtrs</div>
<div class="line">  = <a class="code" href="../../d6/d72/namespaceutil.html#a648066c28180a7cdfac53270a2b4a80d">util::mapDataProductPointers</a>(event, waveformHandle);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="../../d0/d29/classraw_1_1OpDetWaveform.html">raw::OpDetWaveform</a> <span class="keyword">const</span>&amp; waveform: *waveformHandle) {</div>
<div class="line"></div>
<div class="line">  art::Ptr&lt;raw::OpDetWaveform&gt; <span class="keyword">const</span>&amp; ptr = opDetWavePtrs.at(&amp;waveform);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> in the loop the <code>art::Ptr</code> of each <code>waveform</code> is tracked without carrying around the index of the waveform in the original data product.</p>
<p>There are alternative approaches to this: one can rely on the contiguous memory model of <code>std::vector</code> and carry around the address of the first waveform, <code>&amp;(waveformHandle-&gt;<a class="el" href="../../d9/dd2/selectors_8fcl.html#a2602587bf9a1efd1e11d4fdeb2da110a">front()</a>)</code>, and a properly initialized <code>art::PtrMaker</code> which can then invoked as <code>ptrMaker(&amp;waveform - waveform0ptr)</code>; or work directly with <code>art::Ptr</code>. This approach is more factorised than the first alternative (knowledge of the event is not required any more during the iteration) and arguably faster than the second, where <em>art</em> pointer dereferencing always has a small overhead, but it uses more memory.</p>
<dl class="section note"><dt>Note</dt><dd>The returned object is currently a C++ STL data container. Optimizations are possible using a different data structure (for example, a vector-based container with index based on the difference described in the example above) and they may in future be implemented. Because of this reason, it is recommended that the produced map is stored in variables declared with an <code>auto const&amp;</code> type or as a <code>DataProductPointerMap_t</code> instance, rather than with the currently underlying data type. </dd></dl>

</div>
</div>
<a class="anchor" id="a552d34284b2fcf1991b777c08e9998a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::MCParticleContainedLength </td>
          <td>(</td>
          <td class="paramtype">const simb::MCParticle &amp;&#160;</td>
          <td class="paramname"><em>particle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../db/d54/classgeo_1_1BoxBoundedGeo.html">geo::BoxBoundedGeo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_volumes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculated length of an MCParticle trajectory through a list of (non-overlapping) volumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>The particle to calculate the length for </td></tr>
    <tr><td class="paramname">active_volumes</td><td>A list of non-overlapping volumes through which the contained length will be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the MCParticle trajectory contained in the active_volumes. Returns 0 if the list of volumes is empty or the particle does not contain trajectory points. </dd></dl>

<p>Definition at line <a class="el" href="../../da/daa/Interaction_8cxx_source.html#l00077">77</a> of file <a class="el" href="../../da/daa/Interaction_8cxx_source.html">Interaction.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                                                                                                    {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keywordtype">double</span> contained_length = 0;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordtype">bool</span> outside_AV = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  TVector3 start = particle.Position().Vect();</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// keep track of the containment position</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordtype">int</span> volume_index = -1;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// now check the active volumes</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; active_volumes.size(); i++) {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">if</span> (outside_AV &amp;&amp; active_volumes[i].ContainsPosition(start)) {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      outside_AV = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      volume_index = i;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  }</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// if outside AV, set length to 0</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">if</span> (outside_AV) <span class="keywordflow">return</span> 0.;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// keep track of the containment volume</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  std::vector&lt;geo::BoxBoundedGeo&gt; volume { active_volumes.at(volume_index) };</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  TVector3 last = start;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; particle.NumberTrajectoryPoints(); i++) {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    TVector3 current = particle.Position(i).Vect();</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span> (!volume[0].ContainsPosition(current)) {</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    contained_length += <a class="code" href="../../d6/d72/namespaceutil.html#aefa47a1a36712e98d450e2e6fe3fc1f2">ContainedLength</a>(last, current, volume);   </div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    last = current;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="keywordflow">return</span> contained_length;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div>
<div class="ttc" id="namespaceutil_html_aefa47a1a36712e98d450e2e6fe3fc1f2"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#aefa47a1a36712e98d450e2e6fe3fc1f2">util::ContainedLength</a></div><div class="ttdeci">double ContainedLength(const TVector3 &amp;v0, const TVector3 &amp;v1, const std::vector&lt; geo::BoxBoundedGeo &gt; &amp;boxes)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/daa/Interaction_8cxx_source.html#l00028">Interaction.cxx:28</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69ee679df3a620774f76771dc3b0a9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double util::MCParticleLength </td>
          <td>(</td>
          <td class="paramtype">const simb::MCParticle &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate length of an MCParticle trajectory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>the MCParticle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length travelled by the particle. Returns 0 if the particle does not contain trajectory points. </dd></dl>

<p>Definition at line <a class="el" href="../../da/daa/Interaction_8cxx_source.html#l00065">65</a> of file <a class="el" href="../../da/daa/Interaction_8cxx_source.html">Interaction.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                        {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="keywordtype">double</span> length = 0;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  TVector3 last = particle.Position().Vect();</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; particle.NumberTrajectoryPoints(); i++) {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    TVector3 current = particle.Position(i).Vect();</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    length += (current - last).Mag();</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    last = current;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  }</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="keywordflow">return</span> length;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6a68ff571825cfe2793a2645b8d64fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename PtrColl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::MoveFromPointers </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrColl &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the content from a collection of pointers to one of data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection of data </td></tr>
    <tr><td class="paramname">PtrColl</td><td>type of collection of pointers to data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>collection to be filled </td></tr>
    <tr><td class="paramname">src</td><td>collection with the pointers to data to be moved</td></tr>
  </table>
  </dd>
</dl>
<p>The data pointed from each pointer in <code>src</code> is moved into <code>dest</code>. The destination collection is cleared first, and <code>Coll</code> must support both <code>clear()</code> and <code>push_back()</code> </p>

<p>Definition at line <a class="el" href="../../dc/d40/SortByPointers_8h_source.html#l00061">61</a> of file <a class="el" href="../../dc/d40/SortByPointers_8h_source.html">SortByPointers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    { details::MoveFromPointersImpl&lt;Coll, PtrColl&gt;::move(dest, src); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4ddc05abafaee59d66ab1a1510d05306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.namecolors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00276">276</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a4ddc05abafaee59d66ab1a1510d05306">  276</a></span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a4ddc05abafaee59d66ab1a1510d05306">namecolors</a>(name):</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    colors = {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      <span class="stringliteral">&quot;CC&quot;</span>: ROOT.kPink+2,</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <span class="stringliteral">&quot;Cosmic&quot;</span>: ROOT.kGray+1,</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="stringliteral">&quot;Intime Cosmic&quot;</span>: ROOT.kGray+1,</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="stringliteral">&quot;Outtime Cosmic&quot;</span>: ROOT.kGray+2, </div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;      <span class="stringliteral">&quot;NC&quot;</span>: ROOT.kAzure+3,</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="stringliteral">&quot;Other&quot;</span>: ROOT.kRed+2</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordflow">return</span> colors[name]</div>
</div>
<div class="ttc" id="namespaceutil_html_a4ddc05abafaee59d66ab1a1510d05306"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4ddc05abafaee59d66ab1a1510d05306">util.namecolors</a></div><div class="ttdeci">def namecolors</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00276">util.py:276</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dac94677261b934f9ccaf19ad9c0584"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator==. </p>

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00513">513</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  {</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="keywordflow">return</span> !(__x == __y);</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58b6af003aae2adbb7bffbaf8f7bb5ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int RANK1, unsigned int RANK2, typename  = std::enable_if_t&lt;(RANK1 != RANK2), bool&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator!= </td>
          <td>(</td>
          <td class="paramtype">TensorIndices&lt; RANK1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TensorIndices&lt; RANK2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator with tensors of different rank. </p>

<p>Definition at line <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html#l00525">525</a> of file <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html">TensorIndices.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a01604213800d76620886170c986935fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cont , typename Mapping , typename Container , typename Reference &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d4e/classutil_1_1MappedContainer.html">MappedContainer</a>&lt;Cont, Mapping&gt;::template IteratorBase&lt;Container, Reference&gt; util::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename MappedContainer&lt; Cont, Mapping &gt;::template IteratorBase&lt; Container, Reference &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MappedContainer&lt; Cont, Mapping &gt;::template IteratorBase&lt; Container, Reference &gt; const &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/df5/MappedContainer_8h_source.html#l00703">703</a> of file <a class="el" href="../../d2/df5/MappedContainer_8h_source.html">MappedContainer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    { <span class="keywordflow">return</span> it + <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">n</a>; }</div>
<div class="ttc" id="namespacechannelDBConverter_html_ab6cfbbcbb53c275375289d47dec67f46"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">channelDBConverter.n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00249">channelDBConverter.py:249</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adf14c0e43a90e7b91bd329a8e4eef47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00501">501</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keywordflow">return</span> std::lexicographical_compare(__x.sortedVectorMap.begin(),</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                                        __x.sortedVectorMap.end(),</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                                        __y.sortedVectorMap.begin(),</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                        __y.sortedVectorMap.end(),</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                                        __x.valueCompare);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a958d846096090f6b9a8ffc0c1756b5ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Binner&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>binner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../db/dcd/Binner_8h_source.html#l00218">218</a> of file <a class="el" href="../../db/dcd/Binner_8h_source.html">Binner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                                                                      {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  out &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; binner.lower() &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span> &lt;&lt; binner.upper() &lt;&lt; <span class="stringliteral">&quot; ] (&quot;</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    &lt;&lt; binner.nBins() &lt;&lt; <span class="stringliteral">&quot;x &quot;</span> &lt;&lt; binner.step() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;} <span class="comment">// operator&lt;&lt; (Binner&lt;&gt;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1a5aee8fe16506ca25702d0d0334af87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventChangeTracker_t const &amp;&#160;</td>
          <td class="paramname"><em>trk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html#l00105">105</a> of file <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html">ChangeTrackers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    { out &lt;&lt; std::string(trk); <span class="keywordflow">return</span> out; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac5bdd815e3060ee2d44042c2108d6515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d8f/runFilesFromSAM_8sh.html#a9cafae22b6225844ee0cdf5ea57176ff">Stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">addIndent &amp;&amp;&#160;</td>
          <td class="paramname"><em>adder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for <code><a class="el" href="../../da/df1/structutil_1_1addIndent.html" title="Stream modifier that makes it &quot;indented&quot;. ">addIndent</a></code> (. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../da/df1/structutil_1_1addIndent.html" title="Stream modifier that makes it &quot;indented&quot;. ">addIndent</a></code>). </dd></dl>

<p>Definition at line <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html#l00191">191</a> of file <a class="el" href="../../d2/ddb/StreamIndenter_8h_source.html">StreamIndenter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                                      {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="keywordflow">return</span> details::IndentAdder{</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    std::forward&lt;Stream&gt;(out),</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    std::move(adder.indent), std::move(adder.firstIndent)</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    };</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;} <span class="comment">// operator&lt;&lt; (Stream, addIndent)</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5a3374b894f30cb4c2adc8996589aee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataProductChangeTracker_t const &amp;&#160;</td>
          <td class="paramname"><em>trk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html#l00206">206</a> of file <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html">ChangeTrackers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    { out &lt;&lt; std::string(trk); <span class="keywordflow">return</span> out; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5785de3ffa76318f6e841b8595ffb5d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlaneDataChangeTracker_t const &amp;&#160;</td>
          <td class="paramname"><em>trk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html#l00319">319</a> of file <a class="el" href="../../d4/d0f/ChangeTrackers_8h_source.html">ChangeTrackers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    { out &lt;&lt; std::string(trk); <span class="keywordflow">return</span> out; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aee2cb6771c97d36df4985b184f2fb3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00529">529</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  {</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordflow">return</span> !(__y &lt; __x);</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a79c4472a5341320f48fb89ef5ddde6d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator== </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00494">494</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    <span class="keywordflow">return</span> __x.sortedVectorMap == __y.sortedVectorMap;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9cc9c542e10ef72479ce299f90b34431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int RANK1, unsigned int RANK2, typename  = std::enable_if_t&lt;(RANK1 != RANK2), bool&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator== </td>
          <td>(</td>
          <td class="paramtype">TensorIndices&lt; RANK1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TensorIndices&lt; RANK2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator with tensors of different rank. </p>

<p>Definition at line <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html#l00517">517</a> of file <a class="el" href="../../dd/d6a/TensorIndices_8h_source.html">TensorIndices.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaf7ce54e3ab65b02e5a7cb5aa7558a63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00521">521</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  {</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    <span class="keywordflow">return</span> __y &lt; __x;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15f3f2bb1702b0200d3ef7874ed6a3b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00537">537</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keywordflow">return</span> !(__x &lt; __y);</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27485ae016c22bdc5eeb4d399195dd60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::operator| </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeForWrapperTag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a range so that it can be used in a range-for loop. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">Range</a></td><td>the type of range to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the range to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an equivalent range object to be used in a range-for loop</dd></dl>
<p>This is necessary only when the argument provides different types for the begin-of-range and end-of-range iterators. This is also superfluous for compilers adhering to C++ 2017 standard, which accepts iterators of different types by requirement. Example of usage: </p>
<div class="fragment"><div class="line">Range data; <span class="comment">// initialization</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>: data | <a class="code" href="../../d6/d72/namespaceutil.html#a90a2ce9dc82a9f5dc3fbb59ea5583e30">util::range_for</a>) <span class="comment">// ...</span></div>
</div><!-- fragment --><p> where data is supposed to gave begin and end iterators of different types. </p>

<p>Definition at line <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html#l00458">458</a> of file <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html">RangeForWrapper.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a4d9260dbf51f5a9d40bc2cc68f179179">wrapRangeFor</a>(std::forward&lt;Range&gt;(range)); }</div>
<div class="ttc" id="namespaceutil_html_a4d9260dbf51f5a9d40bc2cc68f179179"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4d9260dbf51f5a9d40bc2cc68f179179">util::wrapRangeFor</a></div><div class="ttdeci">auto wrapRangeFor(Range &amp;&amp;range) -&gt; decltype(auto)</div><div class="ttdoc">Wraps an object for use in a range-for loop. </div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d45/RangeForWrapper_8h_source.html#l00426">RangeForWrapper.h:426</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af3802fbad8267765c94febc0ef77b31e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.optstat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00233">233</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00233"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#af3802fbad8267765c94febc0ef77b31e">  233</a></span>&#160;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#af3802fbad8267765c94febc0ef77b31e">optstat</a>(args):</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">if</span> args.optstat:</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        ROOT.gStyle.SetOptStat(args.optstat)</div>
</div>
<div class="ttc" id="namespaceutil_html_af3802fbad8267765c94febc0ef77b31e"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#af3802fbad8267765c94febc0ef77b31e">util.optstat</a></div><div class="ttdeci">def optstat</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00233">util.py:233</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa522ec41346933950a2a529e5bc0f47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T util::pi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constant pi (up to 35 decimal digits of precision) </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00080">80</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{ <span class="keywordflow">return</span> 3.14159265358979323846264338327950288L; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa2f636f1c380effa32255a286e631d4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double util::pythag </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D Euclidean distance </p>

<p>Definition at line <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00039">39</a> of file <a class="el" href="../../d4/d5b/MathUtil_8h_source.html">MathUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">return</span> sqrt(<a class="code" href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a>(<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>)+<a class="code" href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a>(<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a1e5aaaf25e8609a835e8c7c6fda71456">y</a>));</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  }</div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a6673f03521899f7844189bcfd8ee5941"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a></div><div class="ttdeci">process_name opflash particleana ie x</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00090">run_opflash_electron.fcl:90</a></div></div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a1e5aaaf25e8609a835e8c7c6fda71456"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a1e5aaaf25e8609a835e8c7c6fda71456">y</a></div><div class="ttdeci">process_name opflash particleana ie ie y</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00091">run_opflash_electron.fcl:91</a></div></div>
<div class="ttc" id="ComputePi__module_8cc_html_a51cbff124162962a948e82258a33a415"><div class="ttname"><a href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a></div><div class="ttdeci">constexpr T sqr(T v)</div><div class="ttdef"><b>Definition:</b> <a href="../../d8/d39/ComputePi__module_8cc_source.html#l00097">ComputePi_module.cc:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a095598055f1b9dd41c5b01d4fcad34a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double util::pythag </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D Euclidean distance </p>

<p>Definition at line <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00045">45</a> of file <a class="el" href="../../d4/d5b/MathUtil_8h_source.html">MathUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> sqrt(<a class="code" href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a>(<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>)+<a class="code" href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a>(<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a1e5aaaf25e8609a835e8c7c6fda71456">y</a>)+<a class="code" href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a>(<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#ae40184b0245025a43c56daa3261d5e3c">z</a>));</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  }</div>
<div class="ttc" id="run__opflash__electron_8fcl_html_ae40184b0245025a43c56daa3261d5e3c"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#ae40184b0245025a43c56daa3261d5e3c">z</a></div><div class="ttdeci">process_name opflash particleana ie ie ie z</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00092">run_opflash_electron.fcl:92</a></div></div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a6673f03521899f7844189bcfd8ee5941"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a></div><div class="ttdeci">process_name opflash particleana ie x</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00090">run_opflash_electron.fcl:90</a></div></div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a1e5aaaf25e8609a835e8c7c6fda71456"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a1e5aaaf25e8609a835e8c7c6fda71456">y</a></div><div class="ttdeci">process_name opflash particleana ie ie y</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00091">run_opflash_electron.fcl:91</a></div></div>
<div class="ttc" id="ComputePi__module_8cc_html_a51cbff124162962a948e82258a33a415"><div class="ttname"><a href="../../d8/d39/ComputePi__module_8cc.html#a51cbff124162962a948e82258a33a415">sqr</a></div><div class="ttdeci">constexpr T sqr(T v)</div><div class="ttdef"><b>Definition:</b> <a href="../../d8/d39/ComputePi__module_8cc_source.html#l00097">ComputePi_module.cc:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a610f30d0d780990b313247818126b73b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T util::RadiansToDegrees </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the argument angle from radians into degrees ( <img class="formulaInl" alt="$ \pi \rightarrow 180 $" src="../../form_63.png"/>) </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00088">88</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a> / pi&lt;T&gt;() * 180; }</div>
<div class="ttc" id="trackfinderalgorithms_8fcl_html_abfae2e504dfa44c403614b6cd601f99e"><div class="ttname"><a href="../../d2/dbd/trackfinderalgorithms_8fcl.html#abfae2e504dfa44c403614b6cd601f99e">angle</a></div><div class="ttdeci">finds tracks best matching by angle</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/dbd/trackfinderalgorithms_8fcl_source.html#l00064">trackfinderalgorithms.fcl:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af2d88f5bae56f21ca3cb21da09295a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; fhicl::ParameterSetID, fhicl::ParameterSet &gt; util::readConfigurationFromArtFile </td>
          <td>(</td>
          <td class="paramtype">TFile &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the <em>art</em> configuration stored in <code>sourceDir</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td><a class="el" href="../../da/d98/namespaceutil_1_1ROOT.html">ROOT</a> file where the configuration is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the full configuration </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cet::exception</td><td>(category: <code>"readConfigurationFromArtFile"</code>) on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a036bd6f8e03bba53c152f04343399088" title="Reads and returns the complete art configuration in the principal. ">readConfigurationFromArtPrincipal()</a></code></dd></dl>
<p>The configuration is expected to be stored by <em>art</em> in the way it does for <em>art</em> <a class="el" href="../../da/d98/namespaceutil_1_1ROOT.html">ROOT</a> files.</p>
<p>The configuration is returned as a map of parameter set ID to parameter set. </p>

<p>Definition at line <a class="el" href="../../d0/d73/ReadArtConfiguration_8cxx_source.html#l00021">21</a> of file <a class="el" href="../../d0/d73/ReadArtConfiguration_8cxx_source.html">ReadArtConfiguration.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;{</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">   * This code is ripped from `fhiclcpp/ParameterSetRegistry.h` and</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">   * `lardata/DetectorInfoServices/DetectorClocksServiceStandard_service.cc`</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">   * (LArSoft v 9.17.0).</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">   * </span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">   * The special wrapped defines hooks to support a &quot;virtual file system&quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">   * within a ROOT file data base, in the way that art knows and I do not.</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">   * So we bite it and accept a dependency against art_root_io.</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  art::SQLite3Wrapper <a class="code" href="../../d7/d34/namespacecopyPostGresToSQLite.html#a8fa982d3e5f5c766f0390fd1707d6d33">sqliteDB</a>(&amp;<a class="code" href="../../d0/dea/file__to__url_8sh.html#a79854d43ae87cec96a59d17fc4141bf0">file</a>, <span class="stringliteral">&quot;RootFileDB&quot;</span>);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="keyword">auto</span>* <a class="code" href="../../dc/db0/corsika__icarus_8fcl.html#ab93e705c5d934e7777f11582689b7e1f">db</a> = <span class="keyword">static_cast&lt;</span>sqlite3*<span class="keyword">&gt;</span>(<a class="code" href="../../d7/d34/namespacecopyPostGresToSQLite.html#a8fa982d3e5f5c766f0390fd1707d6d33">sqliteDB</a>);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> throwOnSQLiteNotOK = [&amp;<a class="code" href="../../dc/db0/corsika__icarus_8fcl.html#ab93e705c5d934e7777f11582689b7e1f">db</a>](std::string <span class="keyword">const</span>&amp; <a class="code" href="../../d1/d3f/namespaceexample__anaunit.html#a018e3a338e1c96b9b777d478d923b1ef">msg</a> = {})</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="../../dc/db0/corsika__icarus_8fcl.html#ab93e705c5d934e7777f11582689b7e1f">db</a> == <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">throw</span> cet::exception(<span class="stringliteral">&quot;readConfigurationFromArtFile&quot;</span>)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;          &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open SQLite database.&quot;</span>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      }</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <span class="keyword">auto</span> <span class="keyword">const</span> errcode = sqlite3_errcode(<a class="code" href="../../dc/db0/corsika__icarus_8fcl.html#ab93e705c5d934e7777f11582689b7e1f">db</a>);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="comment">// Caller&#39;s responsibility to make sure this really is an error</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      <span class="comment">// and not (say) SQLITE_ROW or SQLITE_DONE:</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      <span class="keywordflow">if</span> (errcode == SQLITE_OK) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      <span class="keywordflow">throw</span> cet::exception(<span class="stringliteral">&quot;readConfigurationFromArtFile&quot;</span>)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;SQLite3 error (code&quot;</span> &lt;&lt; errcode &lt;&lt; <span class="stringliteral">&quot;): &quot;</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        &lt;&lt; sqlite3_errstr(errcode) &lt;&lt; (msg.empty() ? <span class="stringliteral">&quot;&quot;</span> : (<span class="stringliteral">&quot;: &quot;</span> + <a class="code" href="../../d1/d3f/namespaceexample__anaunit.html#a018e3a338e1c96b9b777d478d923b1ef">msg</a>))</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    };</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  sqlite3_stmt* stmt = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  sqlite3_prepare_v2</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    (<a class="code" href="../../d7/d34/namespacecopyPostGresToSQLite.html#a8fa982d3e5f5c766f0390fd1707d6d33">sqliteDB</a>, <span class="stringliteral">&quot;SELECT ID, PSetBlob from ParameterSets;&quot;</span>, -1, &amp;stmt, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  throwOnSQLiteNotOK(<span class="stringliteral">&quot;[SELECT ID, PSetBlob from ParameterSets;]&quot;</span>);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  std::map&lt;fhicl::ParameterSetID, fhicl::ParameterSet&gt; config;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="keywordflow">while</span> (sqlite3_step(stmt) == SQLITE_ROW) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="comment">// reinterpretation: `unsigned char*` -&gt; `char*`</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    std::string <span class="keyword">const</span> psetIDstr</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(sqlite3_column_text(stmt, 0));</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keyword">auto</span> pset = fhicl::ParameterSet::make</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      (reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(stmt, 1)));</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    config.emplace(fhicl::ParameterSetID{ psetIDstr }, std::move(pset));</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  sqlite3_finalize(stmt);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  throwOnSQLiteNotOK(<span class="stringliteral">&quot;[SELECT ID, PSetBlob from ParameterSets;]&quot;</span>);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">return</span> config;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;} <span class="comment">// util::readConfigurationFromArtFile()</span></div>
<div class="ttc" id="file__to__url_8sh_html_a79854d43ae87cec96a59d17fc4141bf0"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a79854d43ae87cec96a59d17fc4141bf0">file</a></div><div class="ttdeci">* file</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00069">file_to_url.sh:69</a></div></div>
<div class="ttc" id="namespaceexample__anaunit_html_a018e3a338e1c96b9b777d478d923b1ef"><div class="ttname"><a href="../../d1/d3f/namespaceexample__anaunit.html#a018e3a338e1c96b9b777d478d923b1ef">example_anaunit.msg</a></div><div class="ttdeci">string msg</div><div class="ttdef"><b>Definition:</b> <a href="../../db/dda/Algorithms_2mac_2example__anaunit_8py_source.html#l00004">Algorithms/mac/example_anaunit.py:4</a></div></div>
<div class="ttc" id="namespacecopyPostGresToSQLite_html_a8fa982d3e5f5c766f0390fd1707d6d33"><div class="ttname"><a href="../../d7/d34/namespacecopyPostGresToSQLite.html#a8fa982d3e5f5c766f0390fd1707d6d33">copyPostGresToSQLite.sqliteDB</a></div><div class="ttdeci">tuple sqliteDB</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dd4/copyPostGresToSQLite_8py_source.html#l00190">copyPostGresToSQLite.py:190</a></div></div>
<div class="ttc" id="corsika__icarus_8fcl_html_ab93e705c5d934e7777f11582689b7e1f"><div class="ttname"><a href="../../dc/db0/corsika__icarus_8fcl.html#ab93e705c5d934e7777f11582689b7e1f">db</a></div><div class="ttdeci">height to which particles are projected pnfs larsoft persistent physics cosmics Fermilab CORSIKA standard He_showers_ * db</div><div class="ttdef"><b>Definition:</b> <a href="../../dc/db0/corsika__icarus_8fcl_source.html#l00039">corsika_icarus.fcl:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a036bd6f8e03bba53c152f04343399088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Principal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, fhicl::ParameterSet &gt; util::readConfigurationFromArtPrincipal </td>
          <td>(</td>
          <td class="paramtype">Principal const &amp;&#160;</td>
          <td class="paramname"><em>principal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the complete <em>art</em> configuration in the principal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Principal</td><td>type of framework principal class (e.g. <code>art::Event</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">principal</td><td>the "principal" <em>art</em> object to read the information from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the full configuration, as map: process name -&gt; FHiCL parameter set </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cet::exception</td><td>(category: <code>"readConfigurationFromArtPrincipal"</code>) on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#af2d88f5bae56f21ca3cb21da09295a7d" title="Reads and returns the art configuration stored in sourceDir. ">readConfigurationFromArtFile()</a></code></dd></dl>
<p>Compared to <code><a class="el" href="../../d6/d72/namespaceutil.html#af2d88f5bae56f21ca3cb21da09295a7d" title="Reads and returns the art configuration stored in sourceDir. ">readConfigurationFromArtFile()</a></code>, this function relays the same information after it has been conveniently extracted by the framework. A "principal" is framework jargon for <code>art::Event</code>, <code>art::SubRun</code> or <code>art::Run</code> (all derived from <code>art::DataViewImpl</code>). Therefore, this function can be called e.g. in <code>beginRun()</code> hook of a module using its <code>art::Run</code> argument, or in a <code><a class="el" href="../../db/d87/run__flashfilter__data_8fcl.html#a7402aaa7731e0e08389d0aded689ed5d">analyze()</a></code> hook using its <code>art::Event</code> argument.</p>
<p>This function is supposed to be more solid than <code><a class="el" href="../../d6/d72/namespaceutil.html#af2d88f5bae56f21ca3cb21da09295a7d" title="Reads and returns the art configuration stored in sourceDir. ">readConfigurationFromArtFile()</a></code> because it relies less on internals of how the framework works. , this function relays the same information after it has been conveniently extracted by the framework. Also, this function should also be compatible with <code>gallery::Event</code> too (which is the reason why it is implemented as template instead of taking a <code>art::DataViewImpl</code>, which is <em>art</em>-specific), making the name of this function a misnomer.</p>
<p>The configuration is returned as a map of process names to parameter sets (note that the key is different from the one returned by <code><a class="el" href="../../d6/d72/namespaceutil.html#af2d88f5bae56f21ca3cb21da09295a7d" title="Reads and returns the art configuration stored in sourceDir. ">readConfigurationFromArtFile()</a></code>). </p>

<p>Definition at line <a class="el" href="../../d4/d95/ReadArtConfiguration_8h_source.html#l00097">97</a> of file <a class="el" href="../../d4/d95/ReadArtConfiguration_8h_source.html">ReadArtConfiguration.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                                                                  {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  std::map&lt;std::string, fhicl::ParameterSet&gt; configMap;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">for</span> (art::ProcessConfiguration <span class="keyword">const</span>&amp; procConfig: principal.processHistory())</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  {</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    fhicl::ParameterSet config;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="../../db/d87/PMTconfigurationExtraction__module_8cc.html#ac33ee765f5ad9f134540bac393721cfe">fhicl::ParameterSetRegistry::get</a>(procConfig.parameterSetID(), config))</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="comment">// this would be, as far as I understand, a logic error</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">throw</span> cet::exception(<span class="stringliteral">&quot;readConfigurationFromArtPrincipal&quot;</span>)</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;Configuration of process &#39;&quot;</span> &lt;&lt; procConfig.processName()</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;&#39; can&#39;t be found!\n&quot;</span>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    configMap[procConfig.processName()] = std::move(config);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  } <span class="comment">// for</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">return</span> configMap;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;} <span class="comment">// util::readConfigurationFromArtPrincipal()</span></div>
<div class="ttc" id="PMTconfigurationExtraction__module_8cc_html_ac33ee765f5ad9f134540bac393721cfe"><div class="ttname"><a href="../../db/d87/PMTconfigurationExtraction__module_8cc.html#ac33ee765f5ad9f134540bac393721cfe">get</a></div><div class="ttdeci">get()</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d87/PMTconfigurationExtraction__module_8cc_source.html#l00168">PMTconfigurationExtraction_module.cc:168</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4bf9a32ad36d4898b3eeaa4a0c9f2b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.resize_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00112">112</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a4bf9a32ad36d4898b3eeaa4a0c9f2b3c">  112</a></span>&#160;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a4bf9a32ad36d4898b3eeaa4a0c9f2b3c">resize_graph</a>(args, hist):</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span> args.range_lo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> args.range_hi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>: </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        hist.GetXaxis().SetLimits(args.range_lo, args.range_hi)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> args.y_min <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> args.y_max <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>: </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        hist.GetYaxis().SetRangeUser(args.y_min, args.y_max)</div>
</div>
<div class="ttc" id="namespaceutil_html_a4bf9a32ad36d4898b3eeaa4a0c9f2b3c"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4bf9a32ad36d4898b3eeaa4a0c9f2b3c">util.resize_graph</a></div><div class="ttdeci">def resize_graph</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00112">util.py:112</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8eda96341323a214c82023547b1a452b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.resize_histo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name_postfix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00118">118</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00118"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a8eda96341323a214c82023547b1a452b">  118</a></span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a8eda96341323a214c82023547b1a452b">resize_histo</a>(args, hist, name_postfix=&quot;&quot;):</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    histdim = 0</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">if</span> isinstance(hist, ROOT.TH1D): histdim = 1</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">elif</span> isinstance(hist, ROOT.TH2D): histdim = 2</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">elif</span> isinstance(hist, ROOT.TH3D): histdim = 3</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    axes_ranges = [(args.x_min, args.x_max), (args.y_min, args.y_max), (args.z_min, args.z_max)]</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">for</span> i_axis, (lo, hi) <span class="keywordflow">in</span> <a class="code" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">enumerate</a>(axes_ranges):</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordflow">if</span> lo <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> hi <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            <span class="keywordflow">if</span> i_axis &gt;= histdim:</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Error: setting axis (%i) for histogram of dimmension (%i)&quot;</span> % (i_axis, histdim))</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">if</span> i_axis == 0: axis = hist.GetXaxis()</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            <span class="keywordflow">elif</span> i_axis == 1: axis = hist.GetYaxis()</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">elif</span> i_axis == 2: axis = hist.GetZaxis()</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            range_lo_ind = <span class="keywordtype">None</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, axis.GetNbins()+1):</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                <span class="keywordflow">if</span> range_lo_ind <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> axis.GetBinLowEdge(i) &gt; lo:</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                    range_lo_ind = max(0, i-2)</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                <span class="keywordflow">if</span> axis.GetBinLowEdge(i) &gt;= hi:</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    range_hi_ind = i</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                    <span class="keywordflow">break</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="keywordflow">else</span>: </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                range_hi_ind = axis.GetNbins()+1</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            assert(range_lo_ind &lt; range_hi_ind)</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            axis_range = [axis.GetBinLowEdge(i) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,axis.GetNbins()+1)] + [axis.GetBinUpEdge(axis.GetNbins())]</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            <span class="comment">#new_axis_range = array(&#39;d&#39;, [axis_range[i] for i in range(range_lo_ind, range_hi_ind)])</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            new_axis_args = [range_hi_ind - range_lo_ind - 1, axis_range[range_lo_ind], axis_range[range_hi_ind-1]]</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keywordflow">if</span> histdim == 1:</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;               new_hist = ROOT.TH1D(hist.GetName() + <span class="stringliteral">&quot; resized &quot;</span> + name_postfix, hist.GetTitle() + name_postfix, *new_axis_args)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">elif</span> histdim == 2:</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;               x_axis_args =  [hist.GetXaxis().GetNbins(), hist.GetXaxis().GetBinLowEdge(1), hist.GetXaxis().GetBinUpEdge(hist.GetXaxis().GetNbins())]</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;               y_axis_args = [hist.GetYaxis().GetNbins(), hist.GetYaxis().GetBinLowEdge(1), hist.GetYaxis().GetBinUpEdge(hist.GetYaxis().GetNbins())]</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;               histo_args = new_axis_args + y_axis_args <span class="keywordflow">if</span> i_axis == 0 <span class="keywordflow">else</span> x_axis_args + new_axis_args</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;               new_hist = ROOT.TH2D(hist.GetName() + <span class="stringliteral">&quot; resized &quot;</span> + name_postfix, hist.GetTitle() + name_postfix, *histo_args)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">elif</span> histdim == 3:</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;               x_axis_args = [hist.GetXaxis().GetNbins(), hist.GetXaxis().GetBinLowEdge(1), hist.GetXaxis().GetBinUpEdge(hist.GetXaxis().GetNbins())]</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;               y_axis_args = [hist.GetYaxis().GetNbins(), hist.GetYaxis().GetBinLowEdge(1), hist.GetYaxis().GetBinUpEdge(hist.GetYaxis().GetNbins())]</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;               z_axis_args = [hist.GetZaxis().GetNbins(), hist.GetZaxis().GetBinLowEdge(1), hist.GetZaxis().GetBinUpEdge(hist.GetZaxis().GetNbins())]</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;               <span class="keywordflow">if</span> i_axis == 0:</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                   histo_args = new_axis_args + y_axis_args + z_axis_args</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;               <span class="keywordflow">elif</span> i_axis == 1:</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                   histo_args = x_axis_args + new_axis_args + z_axis_args</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;               <span class="keywordflow">elif</span> i_axis == 2:</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                   histo_args = x_axis_args + y_axis_args + new_axis_args</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;               new_hist = ROOT.TH3D(hist.GetName() + <span class="stringliteral">&quot; resized &quot;</span> + name_postfix, hist.GetTitle() + name_postfix, *histo_args)</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(range_lo_ind+1, range_hi_ind+1):</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                i_set = i - range_lo_ind</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                <span class="keywordflow">if</span> histdim == 1:</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                    new_hist.SetBinContent(i - range_lo_ind, hist.GetBinContent(i))</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                    new_hist.SetBinError(i - range_lo_ind, hist.GetBinError(i))</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                <span class="keywordflow">elif</span> histdim == 2:</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                    other_axis = hist.GetYaxis() <span class="keywordflow">if</span> i_axis == 0 <span class="keywordflow">else</span> hist.GetXaxis()</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1, other_axis.GetNbins()+1):</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                        i_bin_old = hist.GetBin(i, j) <span class="keywordflow">if</span> i_axis == 0 <span class="keywordflow">else</span> hist.GetBin(j, i)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        i_bin_new = new_hist.GetBin(i_set, j) <span class="keywordflow">if</span> i_axis == 0 <span class="keywordflow">else</span> new_hist.GetBin(j, i_set)</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                        new_hist.SetBinContent(i_bin_new, hist.GetBinContent(i_bin_old))</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                        new_hist.SetBinError(i_bin_new, hist.GetBinError(i_bin_old))</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                <span class="keywordflow">elif</span> histdim == 3:</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                    other_axes = [hist.GetXaxis(), hist.GetYaxis(), hist.GetZaxis()]</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                    other_axes.pop(i_axis)</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                    <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1,other_axes[0].GetNbins()+1):</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(1, other_axes[1].GetNbins()+1):</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                            old_axes_indices = [j,k]</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                            old_axes_indices.insert(i_axis, i)</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                            new_axes_indices = [j,k]</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                            new_axes_indices.insert(i_axis, i_set)</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                            i_bin_old = hist.GetBin(*old_axes_indices)</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                            i_bin_new = new_hist.GetBin(*new_axes_indices)</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                            new_hist.SetBinContent(i_bin_new, hist.GetBinContent(i_bin_old))</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                            new_hist.SetBinError(i_bin_new, hist.GetBinError(i_bin_old))</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            hist = new_hist</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">if</span> args.projectionX:</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        hist = hist.ProjectionX()</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">if</span> args.projectionY:</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        hist = hist.ProjectionY()</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordflow">if</span> args.projectionZ:</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        hist = hist.ProjectionZ()</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">if</span> args.projectionXY:</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        hist = hist.Project3D(<span class="stringliteral">&quot;yx&quot;</span>)</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">if</span> args.projectionYZ:</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        hist = hist.Project3D(<span class="stringliteral">&quot;zy&quot;</span>)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">if</span> args.projectionXZ:</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        hist = hist.Project3D(<span class="stringliteral">&quot;zx&quot;</span>)</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keywordflow">if</span> args.rebinX <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> args.rebinX != 1:</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        hist.RebinX(args.rebinX) </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordflow">if</span> args.rebinY <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> args.rebinY != 1:</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        hist.RebinY(args.rebinY) </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">if</span> args.rebinZ <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> args.rebinZ != 1:</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        hist.RebinZ(args.rebinZ) </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordflow">return</span> hist</div>
</div>
<div class="ttc" id="namespaceutil_html_af0615b7538ff948ea65d5206a23c84f2"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">util::enumerate</a></div><div class="ttdeci">auto enumerate(Iterables &amp;&amp;...iterables)</div><div class="ttdoc">Range-for loop helper tracking the number of iteration. </div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d85/enumerate_8h_source.html#l00069">enumerate.h:69</a></div></div>
<div class="ttc" id="namespaceutil_html_a8eda96341323a214c82023547b1a452b"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a8eda96341323a214c82023547b1a452b">util.resize_histo</a></div><div class="ttdeci">def resize_histo</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00118">util.py:118</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afd8cdd2947ac85743279c480ab444787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.root_env </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00009">9</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00009"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#afd8cdd2947ac85743279c480ab444787">    9</a></span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#afd8cdd2947ac85743279c480ab444787">root_env</a>():</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    buildpath = os.environ[<span class="stringliteral">&quot;SBN_LIB_DIR&quot;</span>]</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="keywordflow">if</span> <span class="keywordflow">not</span> buildpath:</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keywordflow">print</span> <span class="stringliteral">&quot;ERROR: SBNDDAQ_ANALYSIS_BUILD_PATH not set&quot;</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        sys.exit()</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    ROOT.gROOT.ProcessLine(<span class="stringliteral">&quot;.L &quot;</span> + buildpath + <span class="stringliteral">&quot;/libsbnanalysis_Event.so&quot;</span>)</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    ROOT.gROOT.ProcessLine(<span class="stringliteral">&quot;.L &quot;</span> + buildpath + <span class="stringliteral">&quot;/libsbnanalysis_PandoraTesting_classes.so&quot;</span>)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    ROOT.gROOT.ProcessLine(<span class="stringliteral">&quot;.L &quot;</span> + buildpath + <span class="stringliteral">&quot;/libsbnanalysis_SBNOsc_classes.so&quot;</span>)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    ROOT.gROOT.ProcessLine(<span class="stringliteral">&quot;.L &quot;</span> + buildpath + <span class="stringliteral">&quot;/libsbnanalysis_SBNOscReco_classes.so&quot;</span>)</div>
</div>
<div class="ttc" id="namespaceutil_html_afd8cdd2947ac85743279c480ab444787"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#afd8cdd2947ac85743279c480ab444787">util.root_env</a></div><div class="ttdeci">def root_env</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00009">util.py:9</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a078ad2af7ab2588eaea858cddcf72614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter , typename Key , typename Sorter  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::sortBy </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sorter&#160;</td>
          <td class="paramname"><em>sorter</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vectors to pointers to <code>coll</code> elements, sorted by <code>key</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of begin iterator to objects to be sorted </td></tr>
    <tr><td class="paramname">EIter</td><td>type of end iterator to objects to be sorted </td></tr>
    <tr><td class="paramname">Key</td><td>type of functor extracting the key from an element </td></tr>
    <tr><td class="paramname">Sorter</td><td>(default: <code>std::less</code>) type of functor comparing two keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>collection of objects to be sorted </td></tr>
    <tr><td class="paramname">key</td><td>functor extracting the key from an element </td></tr>
    <tr><td class="paramname">sorter</td><td>(default: <code>std::less{}</code>) functor comparing two keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of pointers to <code>coll</code> elements, sorted by <code>key</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#af4a2a442802ada37b9974cb605a4b34a" title="Returns a vectors to pointers to coll elements, sorted by key. ">sortCollBy()</a></code></dd></dl>
<p>A vector of pointers to all elements of <code>coll</code> is returned. The pointers are constant only if <code>Coll</code> is a constant type. The order of the pointed elements is driven by <code>sorter</code> applied to the key of each element (<code>key(item)</code>).</p>
<dl class="section note"><dt>Note</dt><dd>As an exception, if the elements of <code>Coll</code> are already C pointers, the returned collection is a copy of those pointers rather than pointers to them. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dc4/sortBy_8h_source.html#l00104">104</a> of file <a class="el" href="../../d6/dc4/sortBy_8h_source.html">sortBy.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;{</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">   * 0. establish whether we are dealing with pointers or not</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">   * 1. create a collection of pairs { key, pointer to element }</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">   * 2. sort that collection on the first element (key)</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">   * 3. create a collection of the pointer to element (second element of the</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">   *    pairs from the collection just sorted), and return it</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> BIter::value_type;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// 0. establish whether we are dealing with pointers or not</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> isPointer = std::is_pointer_v&lt;value_type&gt;;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="keyword">using</span> pointer_type = std::conditional_t</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    &lt;isPointer, value_type, <span class="keyword">typename</span> std::iterator_traits&lt;BIter&gt;::pointer&gt;;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keyword">using</span> Key_t = std::decay_t&lt;decltype(key(*begin))&gt;;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keyword">using</span> SortingPair_t = std::pair&lt;Key_t, pointer_type&gt;;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="comment">// 1. create a collection of pairs { key, pointer to element }</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keyword">auto</span> getPointer = [](<span class="keyword">auto</span>&amp; elem)</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    { <span class="keywordflow">if</span> constexpr(isPointer) return elem; <a class="code" href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a0544c3fe466e421738dae463968b70ba">else</a> return &amp;elem; };</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  auto makePair = [&amp;key, getPointer](auto&amp;&amp; item)</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    { <span class="keywordflow">return</span> SortingPair_t(key(item), getPointer(item)); };</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  </div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  std::vector&lt;SortingPair_t&gt; sortingColl;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="comment">// reserve size, but only if to discover the size is fast</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="keywordflow">if</span> constexpr(details::is_random_access_iterator_v&lt;BIter&gt;)</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    sortingColl.reserve(<a class="code" href="../../da/dc9/namespacepmtana.html#a9860e62c78db1dd9c7d635a2832b883a">std</a>::distance(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>));</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <a class="code" href="../../da/dc9/namespacepmtana.html#a9860e62c78db1dd9c7d635a2832b883a">std</a>::<a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">transform</a>(begin, end, back_inserter(sortingColl), makePair);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">// 2. sort that collection on the first element (key)</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  auto pair_sorter</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    = [&amp;sorter](SortingPair_t <a class="code" href="../../d7/d8e/namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">const</a>&amp; <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, SortingPair_t <a class="code" href="../../d7/d8e/namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">const</a>&amp; b)</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      { <span class="keywordflow">return</span> sorter(a.first, b.first); }</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    ;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  std::sort(sortingColl.begin(), sortingColl.end(), pair_sorter);</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="comment">// 3. create a collection of the pointer to element (second element of the</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="comment">//    pairs from the collection just sorted), and return it</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  std::vector&lt;pointer_type&gt; sortedColl;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  sortedColl.reserve(sortingColl.size());</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a>(</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    sortingColl.begin(), sortingColl.end(), back_inserter(sortedColl),</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    [](SortingPair_t <span class="keyword">const</span>&amp; pair){ <span class="keywordflow">return</span> pair.second; }</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    );</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  <span class="keywordflow">return</span> sortedColl;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  </div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;} <span class="comment">// util::sortBy()</span></div>
<div class="ttc" id="namespacepmtana_html_a9860e62c78db1dd9c7d635a2832b883a"><div class="ttname"><a href="../../da/dc9/namespacepmtana.html#a9860e62c78db1dd9c7d635a2832b883a">pmtana::std</a></div><div class="ttdeci">double std(const std::vector&lt; short &gt; &amp;wf, const double ped_mean, size_t start, size_t nsample)</div><div class="ttdef"><b>Definition:</b> <a href="../../d8/de4/UtilFunc_8cxx_source.html#l00042">UtilFunc.cxx:42</a></div></div>
<div class="ttc" id="namespaceicarus_1_1waveform__operations_1_1details_html_ae295d3f6cb2f9181dccdf0e3492d44e0"><div class="ttname"><a href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">icarus::waveform_operations::details::transform</a></div><div class="ttdeci">static constexpr Sample_t transform(Sample_t sample)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/d8e/WaveformOperations_8h_source.html#l00145">WaveformOperations.h:145</a></div></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceSortModuleTimes_html_a805854df4323f914a9a09f4e266b4794"><div class="ttname"><a href="../../d7/d8e/namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">SortModuleTimes.const</a></div><div class="ttdeci">string const</div><div class="ttdef"><b>Definition:</b> <a href="../../da/df3/SortModuleTimes_8py_source.html#l00871">SortModuleTimes.py:871</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
<div class="ttc" id="generate__icarus__geometry__splitwire_8pl_html_a0544c3fe466e421738dae463968b70ba"><div class="ttname"><a href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a0544c3fe466e421738dae463968b70ba">else</a></div><div class="ttdeci">else</div><div class="ttdef"><b>Definition:</b> <a href="../../de/ddc/generate__icarus__geometry__splitwire_8pl_source.html#l00039">generate_icarus_geometry_splitwire.pl:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a147c69da475cca9b6f083920f6b072d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename Sorter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::SortByPointers </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&#160;</td>
          <td class="paramname"><em>coll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sorter&#160;</td>
          <td class="paramname"><em>sorter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies sorting indirectly, minimizing data copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection to be sorted </td></tr>
    <tr><td class="paramname">Sorter</td><td>type of sorter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>collection to be sorted </td></tr>
    <tr><td class="paramname">sorter</td><td>functor sorting a vector of pointers (<code><a class="el" href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6" title="Creates a STL vector with pointers to data from another collection. ">makePointerVector()</a></code>)</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>sorter</code> functor can receive a reference to a vector as the one produced by <code>makePointerVector(coll)</code> (that is, a C++ STL vector of pointers to the value type of <code>Coll</code>), and sort it "in place". The container <code>Comp</code> must implement <code>push_back()</code> call in a <code>std::vector</code> fashion.</p>
<p>The algorithm is equivalent to the following:</p>
<ol type="1">
<li>create a parallel vector of pointers to the data</li>
<li>sort the data pointers (delegating to <code>sorter</code>)</li>
<li>move the data, sorted, from the original collection to a new one</li>
<li>replace the content of cont with the one from the sorted collection</li>
</ol>
<p>Single elements are moved from the original collection to a new one.</p>
<p>The data elements of <code>Coll</code> must be moveable, as <code>Coll</code> itself must be.</p>
<dl class="section note"><dt>Note</dt><dd>Use this algorithm only as a last resort, as there are usually better ways to sort collections than this one, which is not even particularly optimized. </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d40/SortByPointers_8h_source.html#l00204">204</a> of file <a class="el" href="../../dc/d40/SortByPointers_8h_source.html">SortByPointers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                                                   {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  <span class="keyword">using</span> coll_t = Coll;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="comment">// create the collection of pointers to data</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  <span class="keyword">auto</span> ptrs = <a class="code" href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6">makePointerVector</a>(coll);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="comment">// delegate the sorting by pointers</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  sorter(ptrs);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  <span class="comment">// create a sorted collection moving the content from the original one</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  coll_t sorted;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <a class="code" href="../../d6/d72/namespaceutil.html#a6a68ff571825cfe2793a2645b8d64fc5">MoveFromPointers</a>(sorted, ptrs);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="comment">// replace the old container with the new one</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  coll = std::move(sorted);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;} <span class="comment">// util::SortByPointers()</span></div>
<div class="ttc" id="namespaceutil_html_ae60c2dec3570d550a2aaf9402ca13ee6"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6">util::makePointerVector</a></div><div class="ttdeci">auto makePointerVector(Coll &amp;coll)</div><div class="ttdoc">Creates a STL vector with pointers to data from another collection. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d40/SortByPointers_8h_source.html#l00198">SortByPointers.h:198</a></div></div>
<div class="ttc" id="namespaceutil_html_a6a68ff571825cfe2793a2645b8d64fc5"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a6a68ff571825cfe2793a2645b8d64fc5">util::MoveFromPointers</a></div><div class="ttdeci">void MoveFromPointers(Coll &amp;dest, PtrColl &amp;src)</div><div class="ttdoc">Moves the content from a collection of pointers to one of data. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d40/SortByPointers_8h_source.html#l00061">SortByPointers.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af4a2a442802ada37b9974cb605a4b34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename Key , typename Sorter  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::sortCollBy </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&#160;</td>
          <td class="paramname"><em>coll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sorter&#160;</td>
          <td class="paramname"><em>sorter</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vectors to pointers to <code>coll</code> elements, sorted by <code>key</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection of objects to be sorted </td></tr>
    <tr><td class="paramname">Key</td><td>type of functor extracting the key from an element </td></tr>
    <tr><td class="paramname">Sorter</td><td>(default: <code>std::less</code>) type of functor comparing two keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>collection of objects to be sorted </td></tr>
    <tr><td class="paramname">key</td><td>functor extracting the key from an element </td></tr>
    <tr><td class="paramname">sorter</td><td>(default: <code>std::less{}</code>) functor comparing two keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of pointers to <code>coll</code> elements, sorted by <code>key</code> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#a078ad2af7ab2588eaea858cddcf72614" title="Returns a vectors to pointers to coll elements, sorted by key. ">sortBy()</a></code></dd></dl>
<p>A vector of pointers to all elements of <code>coll</code> is returned. The pointers are constant only if <code>Coll</code> is a constant type. The order of the pointed elements is driven by <code>sorter</code> applied to the key of each element (<code>key(item)</code>).</p>
<dl class="section note"><dt>Note</dt><dd>As an exception, if the elements of <code>Coll</code> are already C pointers, the returned collection is a copy of those pointers rather than pointers to them. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dc4/sortBy_8h_source.html#l00169">169</a> of file <a class="el" href="../../d6/dc4/sortBy_8h_source.html">sortBy.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                                          {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">std::begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">std::end</a>;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a078ad2af7ab2588eaea858cddcf72614">sortBy</a>(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>(coll), <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>(coll), key, sorter);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;} <span class="comment">// util::sortCollBy()</span></div>
<div class="ttc" id="namespaceutil_html_a078ad2af7ab2588eaea858cddcf72614"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a078ad2af7ab2588eaea858cddcf72614">util::sortBy</a></div><div class="ttdeci">auto sortBy(BIter begin, EIter end, Key key, Sorter sorter={})</div><div class="ttdoc">Returns a vectors to pointers to coll elements, sorted by key. </div><div class="ttdef"><b>Definition:</b> <a href="../../d6/dc4/sortBy_8h_source.html#l00104">sortBy.h:104</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a015eacf29c9f7ae95a10ae66d70df561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll , typename Sorter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::SortUniquePointers </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&#160;</td>
          <td class="paramname"><em>coll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sorter &amp;&amp;&#160;</td>
          <td class="paramname"><em>sorter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a vector of unique pointers using a C pointer sorter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of collection to be sorted </td></tr>
    <tr><td class="paramname">Sorter</td><td>type of sorter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>collection to be sorted </td></tr>
    <tr><td class="paramname">sorter</td><td>sorting procedure</td></tr>
  </table>
  </dd>
</dl>
<p>This adapter moves the unique pointers around to match a sorted version of source. This is an expensive procedure, implying the creation of a temporary vector and of additional supporting data: avoid it if at all possible. </p>

<p>Definition at line <a class="el" href="../../dc/d40/SortByPointers_8h_source.html#l00234">234</a> of file <a class="el" href="../../dc/d40/SortByPointers_8h_source.html">SortByPointers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                                                         {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <span class="keyword">using</span> Collection_t = Coll;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="keyword">using</span> UPtr_t = <span class="keyword">typename</span> Collection_t::value_type;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  </div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  static_assert(util::is_unique_ptr_v&lt;UPtr_t&gt;);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="comment">// create the collection of pointers to data</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="keyword">auto</span> ptrs = <a class="code" href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6">makePointerVector</a>(coll);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  <span class="comment">// data pointer -&gt; index</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> ptrIndex = <a class="code" href="../../d6/d72/namespaceutil.html#adc1d3a95ec691bb7e21db6b8699c2540">util::makeValueIndex</a>(ptrs);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="comment">// delegate the sorting by pointers</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  sorter(ptrs);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="comment">// create a sorted collection moving the content from the original one</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  Collection_t sorted;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; dataPtr: ptrs) {</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    std::size_t <span class="keyword">const</span> originalIndex = ptrIndex.at(dataPtr);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    sorted.emplace_back(std::move(coll[originalIndex]));</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  }</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <span class="comment">// replace the old container with the new one</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  coll = std::move(sorted);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;} <span class="comment">// util::SortUniquePointers()</span></div>
<div class="ttc" id="namespaceutil_html_ae60c2dec3570d550a2aaf9402ca13ee6"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae60c2dec3570d550a2aaf9402ca13ee6">util::makePointerVector</a></div><div class="ttdeci">auto makePointerVector(Coll &amp;coll)</div><div class="ttdoc">Creates a STL vector with pointers to data from another collection. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/d40/SortByPointers_8h_source.html#l00198">SortByPointers.h:198</a></div></div>
<div class="ttc" id="namespaceutil_html_adc1d3a95ec691bb7e21db6b8699c2540"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#adc1d3a95ec691bb7e21db6b8699c2540">util::makeValueIndex</a></div><div class="ttdeci">decltype(auto) makeValueIndex(Coll const &amp;coll, Extractor getter)</div><div class="ttdoc">Returns a map of value to index. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a204cc1fffeab061e648e9d93b2488c44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T util::sqr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>More efficient square function than pow(x,2) </p>

<p>Definition at line <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00023">23</a> of file <a class="el" href="../../d4/d5b/MathUtil_8h_source.html">MathUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>*<a class="code" href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a>;}</div>
<div class="ttc" id="run__opflash__electron_8fcl_html_a6673f03521899f7844189bcfd8ee5941"><div class="ttname"><a href="../../d0/d84/run__opflash__electron_8fcl.html#a6673f03521899f7844189bcfd8ee5941">x</a></div><div class="ttdeci">process_name opflash particleana ie x</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d84/run__opflash__electron_8fcl_source.html#l00090">run_opflash_electron.fcl:90</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3bf4876cc648f293505a82b303ad1ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.style </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00237">237</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00237"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a3bf4876cc648f293505a82b303ad1ad0">  237</a></span>&#160;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a3bf4876cc648f293505a82b303ad1ad0">style</a>(args, canvas, hist):</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    hist.GetYaxis().SetTitleSize(20)</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    hist.GetYaxis().SetTitleFont(43)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    hist.GetYaxis().SetLabelFont(43)</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    hist.GetYaxis().SetLabelSize(20)</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    hist.GetYaxis().CenterTitle()</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    hist.GetXaxis().SetTitleSize(20)</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    hist.GetXaxis().SetTitleFont(43)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    hist.GetXaxis().SetLabelFont(43)</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    hist.GetXaxis().SetLabelSize(20)</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    hist.GetXaxis().CenterTitle()</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keywordflow">if</span> args.margin_left <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        canvas.SetLeftMargin(args.margin_left)</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="keywordflow">if</span> args.margin_right <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        canvas.SetRightMargin(args.margin_right)</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keywordflow">if</span> args.margin_bottom <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        canvas.SetBottomMargin(args.margin_bottom)</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">if</span> args.margin_top <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        canvas.SetTopMargin(args.margin_top)</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span> args.xlabel <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="keywordflow">for</span> i, xlabel <span class="keywordflow">in</span> <a class="code" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">enumerate</a>(args.xlabel):</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            hist.GetXaxis().SetBinLabel(i+1, xlabel)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordflow">if</span> args.ylabel <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">for</span> i, ylabel <span class="keywordflow">in</span> <a class="code" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">enumerate</a>(args.ylabel):</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            hist.GetYaxis().SetBinLabel(i+1, ylabel)</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            hist.GetYaxis().LabelsOption(<span class="stringliteral">&quot;v&quot;</span>)</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">if</span> args.xtitle: hist.GetXaxis().SetTitle(args.xtitle)</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">if</span> args.ytitle: hist.GetYaxis().SetTitle(args.ytitle)</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span> args.yrange: hist.GetYaxis().SetRangeUser(*args.yrange)</div>
</div>
<div class="ttc" id="namespaceutil_html_a3bf4876cc648f293505a82b303ad1ad0"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a3bf4876cc648f293505a82b303ad1ad0">util.style</a></div><div class="ttdeci">def style</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00237">util.py:237</a></div></div>
<div class="ttc" id="namespaceutil_html_af0615b7538ff948ea65d5206a23c84f2"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2">util::enumerate</a></div><div class="ttdeci">auto enumerate(Iterables &amp;&amp;...iterables)</div><div class="ttdoc">Range-for loop helper tracking the number of iteration. </div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d85/enumerate_8h_source.html#l00069">enumerate.h:69</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78c96a01b8b19491fba3f0b04bf4b30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void util::swap </td>
          <td>(</td>
          <td class="paramtype">VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorMap&lt; _Key, _Tp, _Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="../../df/dd5/classutil_1_1VectorMap.html#a011489d28ce5d769e4340cb9cffc5437">VectorMap::swap()</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d30/VectorMap_8h_source.html#l00545">545</a> of file <a class="el" href="../../d0/d30/VectorMap_8h_source.html">VectorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    __x.swap(__y);</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1b7b3801e849acc3b819c67e57bff2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::takeAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a functor that returns the address of its argument. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../de/db1/structutil_1_1AddressTaker.html" title="Functor returning the address in memory of the operand. ">util::AddressTaker</a></code></dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">std::vector&lt;int*&gt; ptrs(data.size());</div>
<div class="line"><a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a></div>
<div class="line">  (data.begin(), data.end(), ptrs.begin(), <a class="code" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3">util::takeAddress</a>());</div>
</div><!-- fragment --><p> will fill the vector <code>ptrs</code> with pointers to the elements of <code>data</code>.</p>
<h2>Why bother? </h2>
<p>C++ already provides a tool to effectively take an address, <code>std::addressof</code>. The reason for <code><a class="el" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3" title="Returns a functor that returns the address of its argument. ">takeAddress()</a></code> is that <code>std::addressof()</code> is a function, with many overloads, and to use it in a STL algorithm the overload has to be resolved first. For example: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> addressof_t = <span class="keywordtype">int</span> <span class="keyword">const</span>*(*)(<span class="keywordtype">int</span> <span class="keyword">const</span>&amp;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a>(data.cbegin(), data.cend(), std::back_inserter(dataPtr),</div>
<div class="line">  ((addressof_t) &amp;std::addressof));</div>
</div><!-- fragment --><p> One important limit is that the type of the argument (in this case <code>int const&amp;</code>) needs to be known or deduced in a quite precise way, in particular regarding constantness and referenceness. This is unconvenient and convoluted enough that one would rather create a new function, like: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3">takeAddress</a> = [](<span class="keyword">auto</span>&amp;&amp; ref){ <span class="keywordflow">return</span> std::addressof(ref); };</div>
<div class="line"></div>
<div class="line">std::vector&lt;int const*&gt; dataPtr;</div>
<div class="line"><a class="code" href="../../d5/d45/namespaceicarus_1_1waveform__operations_1_1details.html#ae295d3f6cb2f9181dccdf0e3492d44e0">std::transform</a>(data.cbegin(), data.cend(), std::back_inserter(dataPtr),</div>
<div class="line">  <a class="code" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3">takeAddress</a>);</div>
</div><!-- fragment --><p> This <code><a class="el" href="../../d6/d72/namespaceutil.html#a1b7b3801e849acc3b819c67e57bff2f3" title="Returns a functor that returns the address of its argument. ">util::takeAddress()</a></code> operates in a very similar way to the lambda in the last example. </p>

<p>Definition at line <a class="el" href="../../da/d4f/operations_8h_source.html#l00086">86</a> of file <a class="el" href="../../da/d4f/operations_8h_source.html">operations.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;{ <span class="keywordflow">return</span> AddressTaker(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8a372ce12124227afecb423d4237611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.validate_hists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00352">352</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ad8a372ce12124227afecb423d4237611">  352</a></span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ad8a372ce12124227afecb423d4237611">validate_hists</a>(names, hists):</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">for</span> nn,hh <span class="keywordflow">in</span> <a class="code" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5">zip</a>(names, hists):</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">if</span> isinstance(hh, list):</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            <span class="keywordflow">for</span> n,h <span class="keywordflow">in</span> <a class="code" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5">zip</a>(nn,hh):</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                <span class="keywordflow">if</span> <span class="keywordflow">not</span> h:</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                     <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Error: invalid histogram with name (%s)&quot;</span> % n)</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                    <span class="comment"># raise Exception(&quot;Error: invalid histogram (%s) with name (%s)&quot; % (h, n))</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            <span class="keywordflow">if</span> <span class="keywordflow">not</span> hh:</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                <span class="keywordflow">raise</span> Exception(<span class="stringliteral">&quot;Error: invalid histogram with name (%s)&quot;</span> % (nn))</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                <span class="comment">#raise Exception(&quot;Error: invalid histogram (%s) with name (%s)&quot; % (hh, nn))</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div>
<div class="ttc" id="namespaceutil_html_ad8a372ce12124227afecb423d4237611"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ad8a372ce12124227afecb423d4237611">util.validate_hists</a></div><div class="ttdeci">def validate_hists</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00352">util.py:352</a></div></div>
<div class="ttc" id="namespaceutil_html_a3efdd3910e740873b4247e10e9884cf5"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5">util::zip</a></div><div class="ttdeci">auto zip(Iterables &amp;&amp;...iterables)</div><div class="ttdoc">Range-for loop helper iterating across many collections at the same time. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d3a/zip_8h_source.html#l00295">zip.h:295</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5a55399a188de49d3d1461d3b0f37dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coll &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::values </td>
          <td>(</td>
          <td class="paramtype">Coll &amp;&amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper iterating across the values of the specified collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coll</td><td>type of the collection to iterate through </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coll</td><td>the collection to iterate through </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable for range-for loop </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#aac4707f84c6dc5c269f147302722611f" title="Range-for loop helper iterating across the constant values of the specified collection. ">util::const_values()</a></code></dd></dl>
<p>This function is in most of cases a no-operation, returning the collection just as it was specified, to be iterated on directly. In case of mapping types, though, a different object is returned and the iteration will happen to the value type of the mapping instead than on the key-value pair.</p>
<div class="fragment"><div class="line">std::map&lt;int, float&gt; data { { 1, 4.0F }, { 3, 12.0F }, { 2, 8.0F } };</div>
<div class="line">std::vector&lt;float&gt; <a class="code" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4">values</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>: <a class="code" href="../../d6/d72/namespaceutil.html#a5a55399a188de49d3d1461d3b0f37dc4">util::values</a>(data)) </div>
<div class="line">  values.push_back(<a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>);</div>
</div><!-- fragment --><p> will result in <code>values</code> vector being of size <code>3</code> and with values <code>{ 4.0F, 8.0F, 12.0F }</code> (the order is the one of iterating through a <code>std::map</code>). </p>

</div>
</div>
<a class="anchor" id="a2a366470c9c9b9d3a2172f37fa1b8740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.wait </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00019">19</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a2a366470c9c9b9d3a2172f37fa1b8740">   19</a></span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a2a366470c9c9b9d3a2172f37fa1b8740">wait</a>(args):</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="keywordflow">if</span> args.wait:</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        raw_input(<span class="stringliteral">&quot;Press Enter to continue...&quot;</span>)</div>
</div>
<div class="ttc" id="namespaceutil_html_a2a366470c9c9b9d3a2172f37fa1b8740"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a2a366470c9c9b9d3a2172f37fa1b8740">util.wait</a></div><div class="ttdeci">def wait</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00019">util.py:19</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4046d74d1677e7c6ba8b6253cd1a2285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_display_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00079">79</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">   79</a></span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">with_display_args</a>(parser):</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-w&quot;</span>, <span class="stringliteral">&quot;--wait&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-o&quot;</span>, <span class="stringliteral">&quot;--output&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_a4046d74d1677e7c6ba8b6253cd1a2285"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">util.with_display_args</a></div><div class="ttdeci">def with_display_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00079">util.py:79</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c2d09360a2f1724c5a928b93994eb82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_graphsize_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00089">89</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">   89</a></span>&#160;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">with_graphsize_args</a>(parser):</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-xm&quot;</span>, <span class="stringliteral">&quot;--x_min&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-xh&quot;</span>, <span class="stringliteral">&quot;--x_max&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-ym&quot;</span>, <span class="stringliteral">&quot;--y_min&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-yh&quot;</span>, <span class="stringliteral">&quot;--y_max&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-zm&quot;</span>, <span class="stringliteral">&quot;--z_min&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-zh&quot;</span>, <span class="stringliteral">&quot;--z_max&quot;</span>, type=float, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_a7c2d09360a2f1724c5a928b93994eb82"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">util.with_graphsize_args</a></div><div class="ttdeci">def with_graphsize_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00089">util.py:89</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae58d6fbb4df28b9d3a17e67bf9cbf06d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_histosize_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00100">100</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ae58d6fbb4df28b9d3a17e67bf9cbf06d">  100</a></span>&#160;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ae58d6fbb4df28b9d3a17e67bf9cbf06d">with_histosize_args</a>(parser):</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-rX&quot;</span>, <span class="stringliteral">&quot;--rebinX&quot;</span>, type=int, default=1)</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-rY&quot;</span>, <span class="stringliteral">&quot;--rebinY&quot;</span>, type=int, default=1)</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-rZ&quot;</span>, <span class="stringliteral">&quot;--rebinZ&quot;</span>, type=int, default=1)</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pX&quot;</span>, <span class="stringliteral">&quot;--projectionX&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pY&quot;</span>, <span class="stringliteral">&quot;--projectionY&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>) </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pZ&quot;</span>, <span class="stringliteral">&quot;--projectionZ&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>) </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pXY&quot;</span>, <span class="stringliteral">&quot;--projectionXY&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>)</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pYZ&quot;</span>, <span class="stringliteral">&quot;--projectionYZ&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>) </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-pXZ&quot;</span>, <span class="stringliteral">&quot;--projectionXZ&quot;</span>, action=<span class="stringliteral">&quot;store_true&quot;</span>) </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">with_graphsize_args</a>(parser)</div>
</div>
<div class="ttc" id="namespaceutil_html_ae58d6fbb4df28b9d3a17e67bf9cbf06d"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ae58d6fbb4df28b9d3a17e67bf9cbf06d">util.with_histosize_args</a></div><div class="ttdeci">def with_histosize_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00100">util.py:100</a></div></div>
<div class="ttc" id="namespaceutil_html_a7c2d09360a2f1724c5a928b93994eb82"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a7c2d09360a2f1724c5a928b93994eb82">util.with_graphsize_args</a></div><div class="ttdeci">def with_graphsize_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00089">util.py:89</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8d71536f0aaebe36f32d1d15b581c021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_histostyle_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00220">220</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a8d71536f0aaebe36f32d1d15b581c021">  220</a></span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a8d71536f0aaebe36f32d1d15b581c021">with_histostyle_args</a>(parser):</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-yr&quot;</span>, <span class="stringliteral">&quot;--yrange&quot;</span>, default=<span class="keywordtype">None</span>, type=int_pair)</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-xt&quot;</span>, <span class="stringliteral">&quot;--xtitle&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-yt&quot;</span>, <span class="stringliteral">&quot;--ytitle&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-yl&quot;</span>, <span class="stringliteral">&quot;--ylabel&quot;</span>, nargs=<span class="stringliteral">&quot;+&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-xl&quot;</span>, <span class="stringliteral">&quot;--xlabel&quot;</span>, nargs=<span class="stringliteral">&quot;+&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-os&quot;</span>, <span class="stringliteral">&quot;--optstat&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-ml&quot;</span>, <span class="stringliteral">&quot;--margin_left&quot;</span>, default=<span class="keywordtype">None</span>, type=float)</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-mr&quot;</span>, <span class="stringliteral">&quot;--margin_right&quot;</span>, default=<span class="keywordtype">None</span>, type=float)</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-mt&quot;</span>, <span class="stringliteral">&quot;--margin_top&quot;</span>, default=<span class="keywordtype">None</span>, type=float)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-mb&quot;</span>, <span class="stringliteral">&quot;--margin_bottom&quot;</span>, default=<span class="keywordtype">None</span>, type=float)</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_a8d71536f0aaebe36f32d1d15b581c021"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a8d71536f0aaebe36f32d1d15b581c021">util.with_histostyle_args</a></div><div class="ttdeci">def with_histostyle_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00220">util.py:220</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af94e63fe4e140fefa6bdb4ba844a148a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_input_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00027">27</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">   27</a></span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">with_input_args</a>(parser):</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">if</span> <span class="stringliteral">&quot;INPUTFILE&quot;</span> <span class="keywordflow">in</span> os.environ:</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        parser.add_argument(<span class="stringliteral">&quot;-i&quot;</span>, <span class="stringliteral">&quot;--input&quot;</span>, default=(<span class="stringliteral">&quot;input&quot;</span>, ROOT.TFile(os.environ[<span class="stringliteral">&quot;INPUTFILE&quot;</span>])), nargs=<span class="stringliteral">&quot;+&quot;</span>, type=filespec, action=FileSpec)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        parser.add_argument(<span class="stringliteral">&quot;-i&quot;</span>, <span class="stringliteral">&quot;--input&quot;</span>, required=<span class="keyword">True</span>, nargs=<span class="stringliteral">&quot;+&quot;</span>, type=filespec, action=FileSpec)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_af94e63fe4e140fefa6bdb4ba844a148a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">util.with_input_args</a></div><div class="ttdeci">def with_input_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00027">util.py:27</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a232d69e15ae3bef0c7e4f093f94096cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_io_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00084">84</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a232d69e15ae3bef0c7e4f093f94096cb">   84</a></span>&#160;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a232d69e15ae3bef0c7e4f093f94096cb">with_io_args</a>(parser):</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    parser = <a class="code" href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">with_input_args</a>(parser)</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    parser = <a class="code" href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">with_display_args</a>(parser)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_af94e63fe4e140fefa6bdb4ba844a148a"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#af94e63fe4e140fefa6bdb4ba844a148a">util.with_input_args</a></div><div class="ttdeci">def with_input_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00027">util.py:27</a></div></div>
<div class="ttc" id="namespaceutil_html_a4046d74d1677e7c6ba8b6253cd1a2285"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4046d74d1677e7c6ba8b6253cd1a2285">util.with_display_args</a></div><div class="ttdeci">def with_display_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00079">util.py:79</a></div></div>
<div class="ttc" id="namespaceutil_html_a232d69e15ae3bef0c7e4f093f94096cb"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a232d69e15ae3bef0c7e4f093f94096cb">util.with_io_args</a></div><div class="ttdeci">def with_io_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00084">util.py:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4963cf5fc98fe4d01ad8c9158a921b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.with_text_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00054">54</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#a4963cf5fc98fe4d01ad8c9158a921b52">   54</a></span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#a4963cf5fc98fe4d01ad8c9158a921b52">with_text_args</a>(parser):</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-txt&quot;</span>, <span class="stringliteral">&quot;--text&quot;</span>, nargs=<span class="stringliteral">&quot;+&quot;</span>, default=<span class="keywordtype">None</span>)</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-tp&quot;</span>, <span class="stringliteral">&quot;--text_position&quot;</span>, default=[0.5,0.4, 0.75, 0.6], type=comma_separated)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-ts&quot;</span>, <span class="stringliteral">&quot;--text_size&quot;</span>, default=30, type=int)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-tf&quot;</span>, <span class="stringliteral">&quot;--text_font&quot;</span>, default=43, type=int)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    parser.add_argument(<span class="stringliteral">&quot;-tc&quot;</span>, <span class="stringliteral">&quot;--text_color&quot;</span>, default=ROOT.kBlack, type=int)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> parser</div>
</div>
<div class="ttc" id="namespaceutil_html_a4963cf5fc98fe4d01ad8c9158a921b52"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#a4963cf5fc98fe4d01ad8c9158a921b52">util.with_text_args</a></div><div class="ttdeci">def with_text_args</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00054">util.py:54</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4d9260dbf51f5a9d40bc2cc68f179179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::wrapRangeFor </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps an object for use in a range-for loop. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="../../df/d18/classutil_1_1Range.html" title="represents a &quot;Range&quot; w/ notion of ordering. A range is defined by a pair of &quot;start&quot; and &quot;end&quot; values...">Range</a></td><td>type of range object (anything with <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#ga624a6c8d8a7c2d3746a644f8cc1c1efe" title="ADL-aware version of std::begin. ">begin()</a> and <a class="el" href="../../dc/ddb/group__LArSoft__CoreUtils__StdUtils.html#gaa1d0cd0cbac37bc1ca4c84daf5343973" title="ADL-aware version of std::end. ">end()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>instance of the range object to be wrapped</td></tr>
  </table>
  </dd>
</dl>
<p>This is necessary only when the argument provides different types for the begin-of-range and end-of-range iterators. This is also superfluous for compilers adhering to C++ 2017 standard, which accepts iterators of different types by requirement. Example of usage: </p>
<div class="fragment"><div class="line">Range data; <span class="comment">// initialization</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>: <a class="code" href="../../d6/d72/namespaceutil.html#a4d9260dbf51f5a9d40bc2cc68f179179">util::wrapRangeFor</a>(data)) <span class="comment">// ...</span></div>
</div><!-- fragment --><p> where data is supposed to gave begin and end iterators of different types. </p>

<p>Definition at line <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html#l00426">426</a> of file <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html">RangeForWrapper.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    {</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;      <span class="keywordflow">return</span> details::WrapRangeForDispatcher&lt;Range&gt;::wrap</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        (std::forward&lt;Range&gt;(range));</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab81157b17422732381feb626f9be3379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>canvas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d5e/util_8py_source.html#l00023">23</a> of file <a class="el" href="../../d0/d5e/util_8py_source.html">util.py</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno"><a class="line" href="../../d6/d72/namespaceutil.html#ab81157b17422732381feb626f9be3379">   23</a></span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keyword">def </span><a class="code" href="../../d6/d72/namespaceutil.html#ab81157b17422732381feb626f9be3379">write</a>(args, canvas):</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="keywordflow">if</span> args.output:</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        canvas.SaveAs(args.output)</div>
</div>
<div class="ttc" id="namespaceutil_html_ab81157b17422732381feb626f9be3379"><div class="ttname"><a href="../../d6/d72/namespaceutil.html#ab81157b17422732381feb626f9be3379">util.write</a></div><div class="ttdeci">def write</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d5e/util_8py_source.html#l00023">util.py:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3efdd3910e740873b4247e10e9884cf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Lead, typename... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::zip </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range-for loop helper iterating across many collections at the same time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lead</td><td>index of the parameter driving the start and end of the loop </td></tr>
    <tr><td class="paramname">Iterables</td><td>type of objects to be iterated together </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterables</td><td>all iterable objects to be iterated together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable for range-for loop </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d6/d72/namespaceutil.html#af0615b7538ff948ea65d5206a23c84f2" title="Range-for loop helper tracking the number of iteration. ">util::enumerate()</a></code></dd></dl>
<p>In the range-for loop, at each iteration this object yields a <code>tuple</code> of values, each of the type returned by dereferencing <code>begin(iterable)</code>. For example: </p>
<div class="fragment"><div class="line">constexpr std::size_t <a class="code" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a> = 4;</div>
<div class="line">std::array&lt;int, N&gt; twice;</div>
<div class="line">std::vector&lt;double&gt; thrice(N + 1);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [ <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, b]: <a class="code" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5">util::zip</a>(twice, thrice)) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> = 2 * i;</div>
<div class="line">  b = 3.0 * i;</div>
<div class="line"></div>
<div class="line">  ++i;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> In this example, <code>N</code> iterations will be run because that is the size of the first iterable given to <code>enumerate</code>. If a different leading iterable is needed, that has to be specified as an argument. The following loop is completely equivalent to the former one: </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [ b, <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>]: util::zip&lt;1U&gt;(thrice, twice)) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> = 2 * i;</div>
<div class="line">  b = 3.0 * i;</div>
<div class="line"></div>
<div class="line">  ++i;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// for</span></div>
</div><!-- fragment --><p> (the index is zero-based, so <code>1U</code> refers to the second argument).</p>
<p>Range-for loop helper iterating across many collections at the same time. </p>

<p>Definition at line <a class="el" href="../../da/d3a/zip_8h_source.html#l00295">295</a> of file <a class="el" href="../../da/d3a/zip_8h_source.html">zip.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                                       {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  </div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d5/d70/structutil_1_1span.html">util::span</a>(</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    details::make_zip_begin_iterator&lt;Lead&gt;(iterables...),</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    details::make_zip_end_iterator&lt;Lead&gt;(iterables...)</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    );</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;} <span class="comment">// util::zip()</span></div>
<div class="ttc" id="structutil_1_1span_html"><div class="ttname"><a href="../../d5/d70/structutil_1_1span.html">util::span</a></div><div class="ttdoc">Simple class with a begin and an end. </div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d7a/span_8h_source.html#l00125">span.h:125</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3fce414074cb3fa1f450751da2e8f871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::zip </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <code><a class="el" href="../../d6/d72/namespaceutil.html#a3efdd3910e740873b4247e10e9884cf5" title="Range-for loop helper iterating across many collections at the same time. ">zip()</a></code> with first iterator implicitly leading the iteration. </p>
<p>Range-for loop helper iterating across many collections at the same time. </p>

<p>Definition at line <a class="el" href="../../da/d3a/zip_8h_source.html#l00080">80</a> of file <a class="el" href="../../da/d3a/zip_8h_source.html">zip.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    { <span class="keywordflow">return</span> zip&lt;0U&gt;(std::forward&lt;Iterables&gt;(iterables)...); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a85007be2ce41bf247364673c302f8a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kBogusD = -999.</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obviously bogus double value </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00071">71</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0796054a3befe89ee1c27998155957f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float util::kBogusF = -999.</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obviously bogus float value </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00073">73</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a182c76e948783adbe3ad07166d4d5996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int util::kBogusI = -999</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obviously bogus integer value </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00072">72</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5741235f9443139fb6ca5063a34551b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kc = 29.9792458</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Speed of light in vacuum in LArSoft units [cm/ns]. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00059">59</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d408b27c811066b7b0ea4446b01fac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kCentimeterToMeter = 1./<a class="el" href="../../d6/d72/namespaceutil.html#a7ce2950cacd9c941568cc2a8ac1a1554">kMeterToCentimeter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00064">64</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa1068ce8202a308d53b640e04501ffbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::keVToMeV = 1.<a class="el" href="../../d9/dd2/selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>-6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1e6 eV = 1 MeV </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00068">68</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac51462247f4e85aa4c2c9bb66f0c0b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kGeVToElectrons = 4.237e7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>23.6eV per ion pair, 1e9 eV/GeV </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00055">55</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a09c8116a4e104ed8d7ea509f41c63090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kINVALID_DOUBLE = std::numeric_limits&lt;Double_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/db5/GeometryUtilities_8h_source.html#l00033">33</a> of file <a class="el" href="../../d5/db5/GeometryUtilities_8h_source.html">GeometryUtilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a758fc2ccbefd8219b384e1d6554bfb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kKilometerToMeter = 1./<a class="el" href="../../d6/d72/namespaceutil.html#a1f215c30f5cda82c16d0f017ff610716">kMeterToKilometer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00066">66</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ce2950cacd9c941568cc2a8ac1a1554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kMeterToCentimeter = 1.e2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 m = 100 cm </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00063">63</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f215c30f5cda82c16d0f017ff610716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kMeterToKilometer = 1.<a class="el" href="../../d9/dd2/selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1000 m = 1 km </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00065">65</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bc85ed7d1d7f6afbd18965a1750f51c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kMeVToeV = 1./<a class="el" href="../../d6/d72/namespaceutil.html#aa1068ce8202a308d53b640e04501ffbc">keVToMeV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00069">69</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac62a2089f10277d70b97c7a396295d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kModBoxA = 0.930</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Box Alpha. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00049">49</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cb09ee269c7c503de7fd8f5313e6267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kModBoxB = 0.212</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Box Beta in g/(MeV cm)*kV/cm. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00050">50</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b8026403bd9c925808117559ae3f6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kRecombA = 0.800</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>A</em> constant. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00035">35</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a899d2fb7f1f3de8da07bdae7431db42e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::kRecombk = 0.0486</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>k</em> constant, in g/(MeV cm)*kV/cm. </p>

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00036">36</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9765743fc3591aa3b7952363ed71e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double util::quietCompiler = <a class="el" href="../../d6/d72/namespaceutil.html#a85007be2ce41bf247364673c302f8a5b">kBogusD</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a182c76e948783adbe3ad07166d4d5996">kBogusI</a>*<a class="el" href="../../d6/d72/namespaceutil.html#ab0796054a3befe89ee1c27998155957f">kBogusF</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a4b8026403bd9c925808117559ae3f6f5">kRecombA</a>*<a class="el" href="../../d6/d72/namespaceutil.html#a899d2fb7f1f3de8da07bdae7431db42e">kRecombk</a>*<a class="el" href="../../d6/d72/namespaceutil.html#ac51462247f4e85aa4c2c9bb66f0c0b1c">kGeVToElectrons</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html#l00075">75</a> of file <a class="el" href="../../dd/d09/PhysicalConstants_8h_source.html">PhysicalConstants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90a2ce9dc82a9f5dc3fbb59ea5583e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d6/d72/structutil_1_1RangeForWrapperTag.html">RangeForWrapperTag</a> util::range_for</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant to be used with <code>operator|(Range&amp;&amp;, details::RangeForWrapperTag)</code>. </p>

<p>Definition at line <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html#l00438">438</a> of file <a class="el" href="../../d6/d45/RangeForWrapper_8h_source.html">RangeForWrapper.h</a>.</p>

</div>
</div>
<a class="anchor" id="a538eae3ddf11b9a4165269e6caae47d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename Func , typename UntilFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d73/classutil_1_1SampledFunction.html">util::SampledFunction</a>&lt; XType, XType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d6a/SampledFunction_8h_source.html#l00362">362</a> of file <a class="el" href="../../d0/d6a/SampledFunction_8h_source.html">SampledFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad425aacbd8188919f73375b333a3db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float util::SQRT_TWO_PI = 2.506628</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/dac/GaussianEliminationAlg_8h_source.html#l00018">18</a> of file <a class="el" href="../../de/dac/GaussianEliminationAlg_8h_source.html">GaussianEliminationAlg.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
