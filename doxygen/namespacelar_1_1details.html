<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>lar::details Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelar.html">lar</a></li><li class="navelem"><a class="el" href="namespacelar_1_1details.html">details</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lar::details Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace hiding implementation details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelar_1_1details_1_1bulk__allocator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details_1_1bulk__allocator.html">bulk_allocator</a></td></tr>
<tr class="memdesc:namespacelar_1_1details_1_1bulk__allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace specific to bulk allocator. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelar_1_1details_1_1counters__map"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details_1_1counters__map.html">counters_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelar_1_1details_1_1type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details_1_1type__traits.html">type_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ServiceRequirementsChecker.html">ServiceRequirementsChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackExtractor.html">ProviderPackExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ServiceProviderRequirementsChecker.html">ServiceProviderRequirementsChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles only if PROVIDER class satisfied service provider requirements.  <a href="structlar_1_1details_1_1ServiceProviderRequirementsChecker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackExtractor_3_01First_00_01Others_8_8_8_4.html">ProviderPackExtractor&lt; First, Others...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackExtractor_3_01Service_01_4.html">ProviderPackExtractor&lt; Service &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__duplicate__types.html">has_duplicate_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1SetFrom.html">SetFrom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail for the extraction constructor.  <a href="structlar_1_1details_1_1SetFrom.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__type.html">has_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__type_3_01Target_00_01First_00_01Others_8_8_8_4.html">has_type&lt; Target, First, Others...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__type_3_01Target_00_01Target_00_01Others_8_8_8_4.html">has_type&lt; Target, Target, Others...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__type_3_01Target_01_4.html">has_type&lt; Target &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__duplicate__types_3_01Key_00_01Types_8_8_8_4.html">has_duplicate_types&lt; Key, Types...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1has__duplicate__types_3_4.html">has_duplicate_types&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1are__types__contained.html">are_types_contained</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1are__same__types.html">are_same_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1are__types__contained_3_01First_00_01OtherTypes_8_8_8_4.html">are_types_contained&lt; First, OtherTypes...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1are__types__contained_3_01First_01_4.html">are_types_contained&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1is__provider__pack.html">is_provider_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1is__provider__pack_3_01ProviderPack_3_01Providers_8_8_8_4_01_4.html">is_provider_pack&lt; ProviderPack&lt; Providers...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1have__same__provider__types.html">have_same_provider_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1have__same__provider__types_3_01ProviderPack_3_01AProviders_8_8_8_4_00_0dba73dccf442da336628336c29986a13.html">have_same_provider_types&lt; ProviderPack&lt; AProviders...&gt;, ProviderPack&lt; BProviders...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__answer.html">findFirstMatching_answer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__answer_3_01Match_00_01Target_00_01true_00_01Candidates_8_8_8_4.html">findFirstMatching_answer&lt; Match, Target, true, Candidates...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__dispatcher.html">findFirstMatching_dispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__dispatcher_3_01Match_00_01Target_01_4.html">findFirstMatching_dispatcher&lt; Match, Target &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__dispatcher_3_01Match_00_01Target_00_01FirstCandidate_00_01OtherCandidates_8_8_8_4.html">findFirstMatching_dispatcher&lt; Match, Target, FirstCandidate, OtherCandidates...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__answer_3_01Match_00_01Target_00_01false_00_01FirstCan163375526534ff1ceb6d10195fba772c.html">findFirstMatching_answer&lt; Match, Target, false, FirstCandidate, OtherCandidates...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findFirstMatching__impl.html">findFirstMatching_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findNextMatching__impl.html">findNextMatching_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findNextMatching__impl_3_01NSkip_00_01Match_00_01Target_00_01FirstCandid28770bcbc16a31e8c3be4244f4740490.html">findNextMatching_impl&lt; NSkip, Match, Target, FirstCandidate, OtherCandidates...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findNextMatching__impl_3_010U_00_01Match_00_01Target_00_01FirstCandidate_00_01OtherCandidates_8_8_8_4.html">findNextMatching_impl&lt; 0U, Match, Target, FirstCandidate, OtherCandidates...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findNextMatching__impl_3_01NSkip_00_01Match_00_01Target_01_4.html">findNextMatching_impl&lt; NSkip, Match, Target &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1findTheMatching__impl.html">findTheMatching_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1is__derived__of.html">is_derived_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1SetFrom_3_01DestPack_00_01SourcePack_00_01FirstProvider_00_01OtherProviders_8_8_8_4.html">SetFrom&lt; DestPack, SourcePack, FirstProvider, OtherProviders...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1SetFrom_3_01DestPack_00_01SourcePack_01_4.html">SetFrom&lt; DestPack, SourcePack &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackComparerBase.html">ProviderPackComparerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackComparer.html">ProviderPackComparer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackComparer_3_01APack_00_01BPack_00_01First_00_01Others_8_8_8_4.html">ProviderPackComparer&lt; APack, BPack, First, Others...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1ProviderPackComparer_3_01APack_00_01BPack_00_01First_01_4.html">ProviderPackComparer&lt; APack, BPack, First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1OptionalHexFloatFormatter.html">OptionalHexFloatFormatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1RangeTraits.html">RangeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlar_1_1details_1_1CollectionExtremes.html">CollectionExtremes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing a begin and a end iterator.  <a href="classlar_1_1details_1_1CollectionExtremes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlar_1_1details_1_1CounterBlock.html">CounterBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of block of counters (just a STL array until SUBCOUNTERS are in)  <a href="classlar_1_1details_1_1CounterBlock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1CountersMapTraits.html">CountersMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlar_1_1details_1_1enable__if__type__exists.html">enable_if_type_exists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlar_1_1details_1_1iteratorRange.html">iteratorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enclosure to use two iterators representing a range in a range-for loop.  <a href="classlar_1_1details_1_1iteratorRange.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlar_1_1details_1_1const__datarange__iterator.html">const_datarange_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2e26a0d333ae812d71b224f13e265a7d"><td class="memTemplParams" colspan="2">template&lt;bool Value&gt; </td></tr>
<tr class="memitem:a2e26a0d333ae812d71b224f13e265a7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a2e26a0d333ae812d71b224f13e265a7d">bool_constant</a> = std::integral_constant&lt; bool, Value &gt;</td></tr>
<tr class="separator:a2e26a0d333ae812d71b224f13e265a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fa3a5065dcb5e268f44a1ae2adfd8f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Value&gt; </td></tr>
<tr class="memitem:a54fa3a5065dcb5e268f44a1ae2adfd8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a54fa3a5065dcb5e268f44a1ae2adfd8f">index_constant</a> = std::integral_constant&lt; std::size_t, Value &gt;</td></tr>
<tr class="separator:a54fa3a5065dcb5e268f44a1ae2adfd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af279dc3941fe281aa5e0be2ac98fec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a6af279dc3941fe281aa5e0be2ac98fec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a6af279dc3941fe281aa5e0be2ac98fec">enable_if_type_exists_t</a> = typename <a class="el" href="structlar_1_1details_1_1enable__if__type__exists.html">enable_if_type_exists</a>&lt; T, R &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="separator:a6af279dc3941fe281aa5e0be2ac98fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9699c9bc68de80b01588ac0512d19e3e"><td class="memTemplParams" colspan="2">template&lt;typename H , typename R  = void&gt; </td></tr>
<tr class="memitem:a9699c9bc68de80b01588ac0512d19e3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a9699c9bc68de80b01588ac0512d19e3e">enable_if_is_handle_t</a> = <a class="el" href="namespacelar_1_1details.html#a6af279dc3941fe281aa5e0be2ac98fec">enable_if_type_exists_t</a>&lt; typename std::decay_t&lt; H &gt;::HandleTag, R &gt;</td></tr>
<tr class="separator:a9699c9bc68de80b01588ac0512d19e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acee4cb37fb82f93350ae2a6e19aab16c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:acee4cb37fb82f93350ae2a6e19aab16c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c">indexOfBaseOf</a> ()</td></tr>
<tr class="memdesc:acee4cb37fb82f93350ae2a6e19aab16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the class among Bases which is base of Derived.  <a href="#acee4cb37fb82f93350ae2a6e19aab16c">More...</a><br/></td></tr>
<tr class="separator:acee4cb37fb82f93350ae2a6e19aab16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafadbbdba055bf9289e7e8577f4ba51"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:afafadbbdba055bf9289e7e8577f4ba51"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#afafadbbdba055bf9289e7e8577f4ba51">indexOfDerivedFrom</a> ()</td></tr>
<tr class="separator:afafadbbdba055bf9289e7e8577f4ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bcce1217b717a4abd1613699c5571c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:a50bcce1217b717a4abd1613699c5571c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a50bcce1217b717a4abd1613699c5571c">findBaseOf</a> ()</td></tr>
<tr class="memdesc:a50bcce1217b717a4abd1613699c5571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the class among Bases which is base of Derived.  <a href="#a50bcce1217b717a4abd1613699c5571c">More...</a><br/></td></tr>
<tr class="separator:a50bcce1217b717a4abd1613699c5571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6923db168ea990def9160e16327f88bc"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:a6923db168ea990def9160e16327f88bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a6923db168ea990def9160e16327f88bc">findDerivedFrom</a> ()</td></tr>
<tr class="separator:a6923db168ea990def9160e16327f88bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5168c1e75da7aa46e563f8f30c70a434"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:a5168c1e75da7aa46e563f8f30c70a434"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a5168c1e75da7aa46e563f8f30c70a434">hasBaseOf</a> ()</td></tr>
<tr class="memdesc:a5168c1e75da7aa46e563f8f30c70a434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is exactly one base class of <code>Derived</code> among <code>Bases</code>.  <a href="#a5168c1e75da7aa46e563f8f30c70a434">More...</a><br/></td></tr>
<tr class="separator:a5168c1e75da7aa46e563f8f30c70a434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4639f0fa9afaea5265119a9de85b05"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:a6f4639f0fa9afaea5265119a9de85b05"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a6f4639f0fa9afaea5265119a9de85b05">hasDerivedFrom</a> ()</td></tr>
<tr class="separator:a6f4639f0fa9afaea5265119a9de85b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a490ab0a8432c2586e8bdc0b52fcf54"><td class="memTemplParams" colspan="2">template&lt;typename Provider , typename APack , typename BPack &gt; </td></tr>
<tr class="memitem:a2a490ab0a8432c2586e8bdc0b52fcf54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a2a490ab0a8432c2586e8bdc0b52fcf54">haveSameProvider</a> (APack const &amp;<a class="el" href="OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, BPack const &amp;b)</td></tr>
<tr class="separator:a2a490ab0a8432c2586e8bdc0b52fcf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c86de03b1db27291275466ac5cc10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e1c86de03b1db27291275466ac5cc10"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a0e1c86de03b1db27291275466ac5cc10">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structlar_1_1details_1_1OptionalHexFloatFormatter.html">details::OptionalHexFloatFormatter</a>&lt; T &gt; fmt)</td></tr>
<tr class="separator:a0e1c86de03b1db27291275466ac5cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44b438066c777217efa19c5de31c639"><td class="memTemplParams" colspan="2">template&lt;typename BeginIter , typename EndIter &gt; </td></tr>
<tr class="memitem:af44b438066c777217efa19c5de31c639"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#af44b438066c777217efa19c5de31c639">makeCollectionExtremes</a> (BeginIter const &amp;b, EndIter const &amp;<a class="el" href="selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>)</td></tr>
<tr class="memdesc:af44b438066c777217efa19c5de31c639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a <a class="el" href="classlar_1_1details_1_1CollectionExtremes.html" title="Class storing a begin and a end iterator. ">CollectionExtremes</a> object from two iterators.  <a href="#af44b438066c777217efa19c5de31c639">More...</a><br/></td></tr>
<tr class="separator:af44b438066c777217efa19c5de31c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95034c4b4a9152e15bee3e6381e0a248"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a95034c4b4a9152e15bee3e6381e0a248"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a95034c4b4a9152e15bee3e6381e0a248">makeCollectionExtremes</a> (Range const &amp;range)</td></tr>
<tr class="memdesc:a95034c4b4a9152e15bee3e6381e0a248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a <a class="el" href="classlar_1_1details_1_1CollectionExtremes.html" title="Class storing a begin and a end iterator. ">CollectionExtremes</a> object from a range object.  <a href="#a95034c4b4a9152e15bee3e6381e0a248">More...</a><br/></td></tr>
<tr class="separator:a95034c4b4a9152e15bee3e6381e0a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aeb80a88749808233f3513d5f95f4a"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a36aeb80a88749808233f3513d5f95f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlar_1_1CollectionView.html">CollectionView</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a36aeb80a88749808233f3513d5f95f4a">makeCollectionView</a> (Range &amp;&amp;)</td></tr>
<tr class="separator:a36aeb80a88749808233f3513d5f95f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8acb5084fd58f804e5bc592acc1216f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#ac8acb5084fd58f804e5bc592acc1216f">LowestSetBitScaler</a> (unsigned long long int v, int b)</td></tr>
<tr class="memdesc:ac8acb5084fd58f804e5bc592acc1216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used by LowestSetBit.  <a href="#ac8acb5084fd58f804e5bc592acc1216f">More...</a><br/></td></tr>
<tr class="separator:ac8acb5084fd58f804e5bc592acc1216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a453a19d4b822c669d0540a4ff2281f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a453a19d4b822c669d0540a4ff2281f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a4a453a19d4b822c669d0540a4ff2281f">make_const_datarange_t</a> (typename <a class="el" href="classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt;::datarange_t &amp;<a class="el" href="condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>)</td></tr>
<tr class="separator:a4a453a19d4b822c669d0540a4ff2281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a124e08ce1743ccc2aef1dbfd8256eed8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a124e08ce1743ccc2aef1dbfd8256eed8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#a124e08ce1743ccc2aef1dbfd8256eed8">demangle</a> ()</td></tr>
<tr class="memdesc:a124e08ce1743ccc2aef1dbfd8256eed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangles the name of a type.  <a href="#a124e08ce1743ccc2aef1dbfd8256eed8">More...</a><br/></td></tr>
<tr class="separator:a124e08ce1743ccc2aef1dbfd8256eed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6d05ccd1f51cfb45f3c73703e2dae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7b6d05ccd1f51cfb45f3c73703e2dae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelar_1_1details.html#ac7b6d05ccd1f51cfb45f3c73703e2dae">demangle</a> (const T &amp;)</td></tr>
<tr class="separator:ac7b6d05ccd1f51cfb45f3c73703e2dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace hiding implementation details. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2e26a0d333ae812d71b224f13e265a7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelar_1_1details.html#a2e26a0d333ae812d71b224f13e265a7d">lar::details::bool_constant</a> = typedef std::integral_constant&lt;bool, Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00314">314</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9699c9bc68de80b01588ac0512d19e3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelar_1_1details.html#a9699c9bc68de80b01588ac0512d19e3e">lar::details::enable_if_is_handle_t</a> = typedef <a class="el" href="namespacelar_1_1details.html#a6af279dc3941fe281aa5e0be2ac98fec">enable_if_type_exists_t</a>&lt;typename std::decay_t&lt;H&gt;::HandleTag, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="FindManyInChainP_8h_source.html#l00038">38</a> of file <a class="el" href="FindManyInChainP_8h_source.html">FindManyInChainP.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6af279dc3941fe281aa5e0be2ac98fec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelar_1_1details.html#a6af279dc3941fe281aa5e0be2ac98fec">lar::details::enable_if_type_exists_t</a> = typedef typename <a class="el" href="structlar_1_1details_1_1enable__if__type__exists.html">enable_if_type_exists</a>&lt;T, R&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="FindManyInChainP_8h_source.html#l00034">34</a> of file <a class="el" href="FindManyInChainP_8h_source.html">FindManyInChainP.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54fa3a5065dcb5e268f44a1ae2adfd8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelar_1_1details.html#a54fa3a5065dcb5e268f44a1ae2adfd8f">lar::details::index_constant</a> = typedef std::integral_constant&lt;std::size_t, Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00317">317</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a124e08ce1743ccc2aef1dbfd8256eed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string lar::details::demangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangles the name of a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to be demangled </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[anonymous]</td><td>parameter to determine the type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the demangled name</dd></dl>
<p>This function relies on GCC ABI; if there is no GCC, no demangling happens. One version of this function takes no parameters, and the type must be specified explicitly in the call. The other takes one parameter, that is not actually used but allows the compiler to understand which type to use. The following usese are equivalent: </p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v;</div>
<div class="line">std::cout &lt;&lt; demangle&lt;std::vector&lt;int&gt;&gt;() &lt;&lt; std::endl;</div>
<div class="line"><a class="code" href="messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a> &lt;&lt; <a class="code" href="namespacelar_1_1details.html#a124e08ce1743ccc2aef1dbfd8256eed8">demangle</a>(v) &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="BulkAllocator_8h_source.html#l00205">205</a> of file <a class="el" href="BulkAllocator_8h_source.html">BulkAllocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                         {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      std::string <a class="code" href="sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a> = <span class="keyword">typeid</span>(T).<a class="code" href="sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a>();</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="preprocessor">      #ifdef __GNUG__</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="preprocessor"></span>        <span class="keywordtype">int</span> status; <span class="comment">// some arbitrary value to eliminate the compiler warning</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        std::unique_ptr&lt;char, void(*)(void*)&gt; res</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;          { abi::__cxa_demangle(name.c_str(), NULL, NULL, &amp;status), std::free };</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <span class="keywordflow">return</span> (status==0) ? res.get() : <a class="code" href="sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a> ;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="preprocessor">      #else // !__GNUG__</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="preprocessor">      #endif // ?__GNUG__</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="preprocessor"></span>    } <span class="comment">// demangle()</span></div>
<div class="ttc" id="sbndpoms__genfclwithrunnumber__maker_8sh_html_a19dd16849ed641adb2aff777fdc4bd8b"><div class="ttname"><a href="sbndpoms__genfclwithrunnumber__maker_8sh.html#a19dd16849ed641adb2aff777fdc4bd8b">name</a></div><div class="ttdeci">then echo fcl name</div><div class="ttdef"><b>Definition:</b> <a href="sbndpoms__genfclwithrunnumber__maker_8sh_source.html#l00220">sbndpoms_genfclwithrunnumber_maker.sh:220</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac7b6d05ccd1f51cfb45f3c73703e2dae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string lar::details::demangle </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="BulkAllocator_8h_source.html#l00218">218</a> of file <a class="el" href="BulkAllocator_8h_source.html">BulkAllocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;{ <span class="keywordflow">return</span> demangle&lt;T&gt;(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a50bcce1217b717a4abd1613699c5571c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::findBaseOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the class among Bases which is base of Derived. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>the class to be found </td></tr>
    <tr><td class="paramname">Bases</td><td>a list of classes candidate to be the base of Derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the class among Bases which is base of Derived </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">static_assert</td><td>if none, or multiple classes, are base of <code>Derived</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacelar_1_1details.html#a5168c1e75da7aa46e563f8f30c70a434" title="Returns whether there is exactly one base class of Derived among Bases. ">hasBaseOf()</a>, <a class="el" href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c" title="Index of the class among Bases which is base of Derived. ">indexOfBaseOf()</a> </dd></dl>

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00579">579</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      {</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        constexpr std::size_t index = <a class="code" href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c">indexOfBaseOf</a>&lt;Derived, Bases...&gt;();</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        static_assert(</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;          index &lt; <span class="keyword">sizeof</span>...(Bases),</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;          <span class="stringliteral">&quot;Target is not derived from any of the available classes&quot;</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;          );</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">return</span> index;</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;      } <span class="comment">// findBaseOf()</span></div>
<div class="ttc" id="namespacelar_1_1details_html_acee4cb37fb82f93350ae2a6e19aab16c"><div class="ttname"><a href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c">lar::details::indexOfBaseOf</a></div><div class="ttdeci">constexpr std::size_t indexOfBaseOf()</div><div class="ttdoc">Index of the class among Bases which is base of Derived. </div><div class="ttdef"><b>Definition:</b> <a href="ProviderPack_8h_source.html#l00575">ProviderPack.h:575</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6923db168ea990def9160e16327f88bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::findDerivedFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00598">598</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        constexpr std::size_t index = <a class="code" href="namespacelar_1_1details.html#afafadbbdba055bf9289e7e8577f4ba51">indexOfDerivedFrom</a>&lt;Base, Derived...&gt;();</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        static_assert(</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;          index &lt; <span class="keyword">sizeof</span>...(Derived),</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;          <span class="stringliteral">&quot;Target is not base of any of the available classes&quot;</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;          );</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="keywordflow">return</span> index;</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;      } <span class="comment">// findDerivedFrom()</span></div>
<div class="ttc" id="namespacelar_1_1details_html_afafadbbdba055bf9289e7e8577f4ba51"><div class="ttname"><a href="namespacelar_1_1details.html#afafadbbdba055bf9289e7e8577f4ba51">lar::details::indexOfDerivedFrom</a></div><div class="ttdeci">constexpr std::size_t indexOfDerivedFrom()</div><div class="ttdef"><b>Definition:</b> <a href="ProviderPack_8h_source.html#l00594">ProviderPack.h:594</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5168c1e75da7aa46e563f8f30c70a434"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::hasBaseOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there is exactly one base class of <code>Derived</code> among <code>Bases</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>the class to be found </td></tr>
    <tr><td class="paramname">Bases</td><td>a list of classes candidate to be the base of Derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether there is exactly one base class of <code>Derived</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">static_assert</td><td>if multiple classes are base of <code>Derived</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c" title="Index of the class among Bases which is base of Derived. ">indexOfBaseOf()</a>, <a class="el" href="namespacelar_1_1details.html#a50bcce1217b717a4abd1613699c5571c" title="Index of the class among Bases which is base of Derived. ">findBaseOf()</a> </dd></dl>

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00073">73</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      { <span class="keywordflow">return</span> <a class="code" href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c">indexOfBaseOf</a>&lt;Derived, Bases...&gt;() &lt; <span class="keyword">sizeof</span>...(Bases); }</div>
<div class="ttc" id="namespacelar_1_1details_html_acee4cb37fb82f93350ae2a6e19aab16c"><div class="ttname"><a href="namespacelar_1_1details.html#acee4cb37fb82f93350ae2a6e19aab16c">lar::details::indexOfBaseOf</a></div><div class="ttdeci">constexpr std::size_t indexOfBaseOf()</div><div class="ttdoc">Index of the class among Bases which is base of Derived. </div><div class="ttdef"><b>Definition:</b> <a href="ProviderPack_8h_source.html#l00575">ProviderPack.h:575</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f4639f0fa9afaea5265119a9de85b05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::hasDerivedFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00077">77</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      { <span class="keywordflow">return</span> <a class="code" href="namespacelar_1_1details.html#afafadbbdba055bf9289e7e8577f4ba51">indexOfDerivedFrom</a>&lt;Derived, Bases...&gt;() &lt; <span class="keyword">sizeof</span>...(Bases); }</div>
<div class="ttc" id="namespacelar_1_1details_html_afafadbbdba055bf9289e7e8577f4ba51"><div class="ttname"><a href="namespacelar_1_1details.html#afafadbbdba055bf9289e7e8577f4ba51">lar::details::indexOfDerivedFrom</a></div><div class="ttdeci">constexpr std::size_t indexOfDerivedFrom()</div><div class="ttdef"><b>Definition:</b> <a href="ProviderPack_8h_source.html#l00594">ProviderPack.h:594</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a490ab0a8432c2586e8bdc0b52fcf54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Provider , typename APack , typename BPack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool lar::details::haveSameProvider </td>
          <td>(</td>
          <td class="paramtype">APack const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BPack const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00635">635</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                                                          {</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      static_assert(is_provider_pack&lt;APack&gt;() &amp;&amp; is_provider_pack&lt;BPack&gt;(),</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        <span class="stringliteral">&quot;This class needs two ProviderPack template types.&quot;</span>);</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.template get&lt;Provider&gt;() == b.template get&lt;Provider&gt;();</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    } <span class="comment">// haveSameProvider()</span></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acee4cb37fb82f93350ae2a6e19aab16c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::indexOfBaseOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the class among Bases which is base of Derived. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>the class to be found </td></tr>
    <tr><td class="paramname">Bases</td><td>a list of classes candidate to be the base of Derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the class among Bases which is base of Derived </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">static_assert</td><td>if multiple classes are base of <code>Derived</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacelar_1_1details.html#a5168c1e75da7aa46e563f8f30c70a434" title="Returns whether there is exactly one base class of Derived among Bases. ">hasBaseOf()</a>, <a class="el" href="namespacelar_1_1details.html#a50bcce1217b717a4abd1613699c5571c" title="Index of the class among Bases which is base of Derived. ">findBaseOf()</a></dd></dl>
<p>If no class among <code>Bases</code> is actually a base class of <code>Derived</code>, an invalid index is returned, greater than any valid index (that is, no smaller than <code>sizeof...(Bases)</code>). </p>

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00575">575</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      { <span class="keywordflow">return</span> findTheMatching_impl&lt;std::is_base_of, Derived, Bases...&gt;(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afafadbbdba055bf9289e7e8577f4ba51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename... Bases&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t lar::details::indexOfDerivedFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ProviderPack_8h_source.html#l00594">594</a> of file <a class="el" href="ProviderPack_8h_source.html">ProviderPack.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      { <span class="keywordflow">return</span> findTheMatching_impl&lt;is_derived_of, Base, Derived...&gt;(); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac8acb5084fd58f804e5bc592acc1216f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int lar::details::LowestSetBitScaler </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally used by LowestSetBit. </p>

<p>Definition at line <a class="el" href="CountersMap_8h_source.html#l00402">402</a> of file <a class="el" href="CountersMap_8h_source.html">CountersMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      { <span class="keywordflow">return</span> (v &amp; 1)? b: <a class="code" href="namespacelar_1_1details.html#ac8acb5084fd58f804e5bc592acc1216f">LowestSetBitScaler</a>(v &gt;&gt; 1, b + 1); }</div>
<div class="ttc" id="namespacelar_1_1details_html_ac8acb5084fd58f804e5bc592acc1216f"><div class="ttname"><a href="namespacelar_1_1details.html#ac8acb5084fd58f804e5bc592acc1216f">lar::details::LowestSetBitScaler</a></div><div class="ttdeci">constexpr int LowestSetBitScaler(unsigned long long int v, int b)</div><div class="ttdoc">Internally used by LowestSetBit. </div><div class="ttdef"><b>Definition:</b> <a href="CountersMap_8h_source.html#l00402">CountersMap.h:402</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a453a19d4b822c669d0540a4ff2281f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) lar::details::make_const_datarange_t </td>
          <td>(</td>
          <td class="paramtype">typename sparse_vector&lt; T &gt;::datarange_t &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af44b438066c777217efa19c5de31c639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BeginIter , typename EndIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto lar::details::makeCollectionExtremes </td>
          <td>(</td>
          <td class="paramtype">BeginIter const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndIter const &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a <a class="el" href="classlar_1_1details_1_1CollectionExtremes.html" title="Class storing a begin and a end iterator. ">CollectionExtremes</a> object from two iterators. </p>

<p>Definition at line <a class="el" href="CollectionView_8h_source.html#l00149">149</a> of file <a class="el" href="CollectionView_8h_source.html">CollectionView.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      { <span class="keywordflow">return</span> CollectionExtremes&lt;BeginIter, EndIter&gt;(b, <a class="code" href="updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>); }</div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a95034c4b4a9152e15bee3e6381e0a248"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto lar::details::makeCollectionExtremes </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a <a class="el" href="classlar_1_1details_1_1CollectionExtremes.html" title="Class storing a begin and a end iterator. ">CollectionExtremes</a> object from a range object. </p>

<p>Definition at line <a class="el" href="CollectionView_8h_source.html#l00155">155</a> of file <a class="el" href="CollectionView_8h_source.html">CollectionView.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keyword">using</span> <a class="code" href="namespaceicarus_1_1ns_1_1util.html#ac27be52617e5c2346bb0af46485a8696">std::cbegin</a>;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keyword">using</span> <a class="code" href="namespaceicarus_1_1ns_1_1util.html#ad9f95380d00f1d88d8f89fb910938752">std::cend</a>;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacelar_1_1details.html#af44b438066c777217efa19c5de31c639">makeCollectionExtremes</a>(<a class="code" href="namespaceicarus_1_1ns_1_1util.html#ac27be52617e5c2346bb0af46485a8696">cbegin</a>(range), <a class="code" href="namespaceicarus_1_1ns_1_1util.html#ad9f95380d00f1d88d8f89fb910938752">cend</a>(range));</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      } <span class="comment">// makeCollectionExtremes(range)</span></div>
<div class="ttc" id="namespacelar_1_1details_html_af44b438066c777217efa19c5de31c639"><div class="ttname"><a href="namespacelar_1_1details.html#af44b438066c777217efa19c5de31c639">lar::details::makeCollectionExtremes</a></div><div class="ttdeci">auto makeCollectionExtremes(BeginIter const &amp;b, EndIter const &amp;e)</div><div class="ttdoc">Helper to create a CollectionExtremes object from two iterators. </div><div class="ttdef"><b>Definition:</b> <a href="CollectionView_8h_source.html#l00149">CollectionView.h:149</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_ac27be52617e5c2346bb0af46485a8696"><div class="ttname"><a href="namespaceicarus_1_1ns_1_1util.html#ac27be52617e5c2346bb0af46485a8696">icarus::ns::util::cbegin</a></div><div class="ttdeci">auto cbegin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FixedBins_8h_source.html#l00567">FixedBins.h:567</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_ad9f95380d00f1d88d8f89fb910938752"><div class="ttname"><a href="namespaceicarus_1_1ns_1_1util.html#ad9f95380d00f1d88d8f89fb910938752">icarus::ns::util::cend</a></div><div class="ttdeci">auto cend(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FixedBins_8h_source.html#l00579">FixedBins.h:579</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a36aeb80a88749808233f3513d5f95f4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlar_1_1CollectionView.html">CollectionView</a>&lt; Range &gt; lar::details::makeCollectionView </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="CollectionView_8h_source.html#l00446">446</a> of file <a class="el" href="CollectionView_8h_source.html">CollectionView.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      { <span class="keywordflow">return</span> CollectionView&lt;Range&gt;(std::move(range)); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e1c86de03b1db27291275466ac5cc10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lar::details::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">details::OptionalHexFloatFormatter&lt; T &gt;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hexfloat_8h_source.html#l00081">81</a> of file <a class="el" href="hexfloat_8h_source.html">hexfloat.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        { <span class="keywordflow">return</span> fmt(os); }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
