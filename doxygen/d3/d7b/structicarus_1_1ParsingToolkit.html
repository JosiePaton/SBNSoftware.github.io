<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>icarus::ParsingToolkit Struct Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../da/d4d/namespaceicarus.html">icarus</a></li><li class="navelem"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html">ParsingToolkit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d8/d82/structicarus_1_1ParsingToolkit-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icarus::ParsingToolkit Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilities for text parsing.  
 <a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dce/structicarus_1_1ParsingToolkit_1_1Error.html">Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All parsing parameters.  <a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t.html">SplitView_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record of a split token: pre-separator, separator and post-separator.  <a href="../../dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9fae443451384bddeecef2c0237c5f27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> = std::pair&lt; std::string, std::string &gt;</td></tr>
<tr class="memdesc:a9fae443451384bddeecef2c0237c5f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specification of quotation: opening and closing.  <a href="#a9fae443451384bddeecef2c0237c5f27">More...</a><br/></td></tr>
<tr class="separator:a9fae443451384bddeecef2c0237c5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c0771b23b03681072f28a87950c04e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0c0771b23b03681072f28a87950c04e5">ParsingToolkit</a> ()</td></tr>
<tr class="memdesc:a0c0771b23b03681072f28a87950c04e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parsing parameters.  <a href="#a0c0771b23b03681072f28a87950c04e5">More...</a><br/></td></tr>
<tr class="separator:a0c0771b23b03681072f28a87950c04e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c911af179a04d12b4da58e68be9d019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a1c911af179a04d12b4da58e68be9d019">ParsingToolkit</a> (<a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> <a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">params</a>)</td></tr>
<tr class="memdesc:a1c911af179a04d12b4da58e68be9d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a parser with the specified parsing parameters.  <a href="#a1c911af179a04d12b4da58e68be9d019">More...</a><br/></td></tr>
<tr class="separator:a1c911af179a04d12b4da58e68be9d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1de5816c9b1ee67a869157627d353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">params</a> () const noexcept</td></tr>
<tr class="memdesc:a99d1de5816c9b1ee67a869157627d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current parameters of parsing.  <a href="#a99d1de5816c9b1ee67a869157627d353">More...</a><br/></td></tr>
<tr class="separator:a99d1de5816c9b1ee67a869157627d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fdaee01be26d53ede077c5e8e38b89"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:a92fdaee01be26d53ede077c5e8e38b89"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a92fdaee01be26d53ede077c5e8e38b89">findFirstUnquoted</a> (std::string_view sv, BIter beginKey, EIter endKey) const </td></tr>
<tr class="memdesc:a92fdaee01be26d53ede077c5e8e38b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in the unquoted part of <code>sv</code>.  <a href="#a92fdaee01be26d53ede077c5e8e38b89">More...</a><br/></td></tr>
<tr class="separator:a92fdaee01be26d53ede077c5e8e38b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e96ba886bc2df9360edb14559460c"><td class="memTemplParams" colspan="2">template&lt;typename Words &gt; </td></tr>
<tr class="memitem:a544e96ba886bc2df9360edb14559460c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a544e96ba886bc2df9360edb14559460c">removeEscapes</a> (Words const &amp;words) const </td></tr>
<tr class="memdesc:a544e96ba886bc2df9360edb14559460c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>words</code> with all escape characters removed.  <a href="#a544e96ba886bc2df9360edb14559460c">More...</a><br/></td></tr>
<tr class="separator:a544e96ba886bc2df9360edb14559460c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a8254522168c6c464db3203f73dabf"><td class="memTemplParams" colspan="2">template&lt;typename Words &gt; </td></tr>
<tr class="memitem:af4a8254522168c6c464db3203f73dabf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#af4a8254522168c6c464db3203f73dabf">removeQuotations</a> (Words const &amp;words) const </td></tr>
<tr class="memdesc:af4a8254522168c6c464db3203f73dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>words</code> with no quotation starts and ends.  <a href="#af4a8254522168c6c464db3203f73dabf">More...</a><br/></td></tr>
<tr class="separator:af4a8254522168c6c464db3203f73dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad209b8a70d8a396de63efb27649195c6"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:ad209b8a70d8a396de63efb27649195c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad209b8a70d8a396de63efb27649195c6">isCharacterEscaped</a> (Iter <a class="el" href="../../df/db6/geo__vectors__utils__TVector_8h.html#abd762dc0ccf00b6ee7f81a289b7bd4f8">begin</a>, Iter itCh) const </td></tr>
<tr class="separator:ad209b8a70d8a396de63efb27649195c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input</div></td></tr>
<tr class="memitem:a9a7a2a18c8c7a4e2855ae190cd85fb35"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9a7a2a18c8c7a4e2855ae190cd85fb35">readMultiline</a> (std::istream &amp;<a class="el" href="../../d2/d2c/duplicate__finder__run__subrun_8sh.html#af623bf5f52bd5b3d3fb5381d86820c12">in</a>) const </td></tr>
<tr class="memdesc:a9a7a2a18c8c7a4e2855ae190cd85fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single line of text from the input stream.  <a href="#a9a7a2a18c8c7a4e2855ae190cd85fb35">More...</a><br/></td></tr>
<tr class="separator:a9a7a2a18c8c7a4e2855ae190cd85fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tokenization</div></td></tr>
<tr class="memitem:a124f8a92d029e9c7142d5388d0b5fd97"><td class="memTemplParams" colspan="2">template&lt;typename Delim &gt; </td></tr>
<tr class="memitem:a124f8a92d029e9c7142d5388d0b5fd97"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string_view &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a124f8a92d029e9c7142d5388d0b5fd97">splitWords</a> (std::string const &amp;<a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>, Delim isDelimiter) const </td></tr>
<tr class="memdesc:a124f8a92d029e9c7142d5388d0b5fd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into words.  <a href="#a124f8a92d029e9c7142d5388d0b5fd97">More...</a><br/></td></tr>
<tr class="separator:a124f8a92d029e9c7142d5388d0b5fd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7e05ef3978769188f9d4ed5ca12995"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a4c7e05ef3978769188f9d4ed5ca12995">splitWords</a> (std::string const &amp;<a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>) const </td></tr>
<tr class="memdesc:a4c7e05ef3978769188f9d4ed5ca12995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper version of <code>splitWords(std::string const&amp;, Delim)</code>.  <a href="#a4c7e05ef3978769188f9d4ed5ca12995">More...</a><br/></td></tr>
<tr class="separator:a4c7e05ef3978769188f9d4ed5ca12995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522a9e4e7289b01915f2bf429994f99b"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a522a9e4e7289b01915f2bf429994f99b"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a522a9e4e7289b01915f2bf429994f99b">findCommentWord</a> (Iter beginWord, Iter endWord) const </td></tr>
<tr class="memdesc:a522a9e4e7289b01915f2bf429994f99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first word starting with a comment marker.  <a href="#a522a9e4e7289b01915f2bf429994f99b">More...</a><br/></td></tr>
<tr class="separator:a522a9e4e7289b01915f2bf429994f99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fa4efd4850e6ba028ab2598c66ec3e"><td class="memTemplParams" colspan="2">template&lt;typename WordType &gt; </td></tr>
<tr class="memitem:aa9fa4efd4850e6ba028ab2598c66ec3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aa9fa4efd4850e6ba028ab2598c66ec3e">removeCommentLine</a> (std::vector&lt; WordType &gt; &amp;words) const </td></tr>
<tr class="memdesc:aa9fa4efd4850e6ba028ab2598c66ec3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the words from the one starting with a comment marker.  <a href="#aa9fa4efd4850e6ba028ab2598c66ec3e">More...</a><br/></td></tr>
<tr class="separator:aa9fa4efd4850e6ba028ab2598c66ec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62423130160f6b379f638ca942b78225"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string_view, <br class="typebreak"/>
<a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">findQuotationStart</a> (std::string_view sv) const </td></tr>
<tr class="memdesc:a62423130160f6b379f638ca942b78225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the start of the next quotation in <code>sv</code>.  <a href="#a62423130160f6b379f638ca942b78225">More...</a><br/></td></tr>
<tr class="separator:a62423130160f6b379f638ca942b78225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bfd5281c00ddad61b7354cce785001"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">findQuotationEnd</a> (std::string_view sv, std::string const &amp;quotEnd) const </td></tr>
<tr class="memdesc:ad9bfd5281c00ddad61b7354cce785001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the quotation end in <code>sv</code>.  <a href="#ad9bfd5281c00ddad61b7354cce785001">More...</a><br/></td></tr>
<tr class="separator:ad9bfd5281c00ddad61b7354cce785001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f59b97e625e2d57301bf3172c0669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2f0f59b97e625e2d57301bf3172c0669">isQuotationUnclosed</a> (std::string_view sv) const </td></tr>
<tr class="memdesc:a2f0f59b97e625e2d57301bf3172c0669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the sequence <code>sv</code> has unclosed quotation at its end.  <a href="#a2f0f59b97e625e2d57301bf3172c0669">More...</a><br/></td></tr>
<tr class="separator:a2f0f59b97e625e2d57301bf3172c0669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1665420e8a8888782cfa4cf079285f"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:a6f1665420e8a8888782cfa4cf079285f"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">findFirstUnescaped</a> (std::string_view sv, BIter beginKey, EIter endKey) const </td></tr>
<tr class="memdesc:a6f1665420e8a8888782cfa4cf079285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in <code>sv</code>.  <a href="#a6f1665420e8a8888782cfa4cf079285f">More...</a><br/></td></tr>
<tr class="separator:a6f1665420e8a8888782cfa4cf079285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d39b99f5b6ba67d5e54752a39ccd78"><td class="memTemplParams" colspan="2">template&lt;typename Keys &gt; </td></tr>
<tr class="memitem:ad1d39b99f5b6ba67d5e54752a39ccd78"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad1d39b99f5b6ba67d5e54752a39ccd78">findFirstUnescaped</a> (std::string_view sv, Keys const &amp;keys) const </td></tr>
<tr class="memdesc:ad1d39b99f5b6ba67d5e54752a39ccd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in <code>sv</code>.  <a href="#ad1d39b99f5b6ba67d5e54752a39ccd78">More...</a><br/></td></tr>
<tr class="separator:ad1d39b99f5b6ba67d5e54752a39ccd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246f5477e60fc2f3db0b02884c048cd"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:af246f5477e60fc2f3db0b02884c048cd"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#af246f5477e60fc2f3db0b02884c048cd">findFirstUnescaped</a> (std::string_view sv, std::initializer_list&lt; Key &gt; keys) const </td></tr>
<tr class="separator:af246f5477e60fc2f3db0b02884c048cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9184c2741f2e6f8e33182e368fd9f141"><td class="memTemplParams" colspan="2">template&lt;typename Keys &gt; </td></tr>
<tr class="memitem:a9184c2741f2e6f8e33182e368fd9f141"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9184c2741f2e6f8e33182e368fd9f141">findFirstUnquoted</a> (std::string_view sv, Keys const &amp;keys) const </td></tr>
<tr class="memdesc:a9184c2741f2e6f8e33182e368fd9f141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first of the specified keys in the unquoted part of <code>sv</code>.  <a href="#a9184c2741f2e6f8e33182e368fd9f141">More...</a><br/></td></tr>
<tr class="separator:a9184c2741f2e6f8e33182e368fd9f141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e62c4349779633c803acf9075906fb"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a83e62c4349779633c803acf9075906fb"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a83e62c4349779633c803acf9075906fb">findFirstUnquoted</a> (std::string_view sv, std::initializer_list&lt; Key &gt; keys) const </td></tr>
<tr class="separator:a83e62c4349779633c803acf9075906fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Characters</div></td></tr>
<tr class="memitem:a46aac5046e18e06ad60c693b26d42909"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a46aac5046e18e06ad60c693b26d42909">isEscape</a> (char ch) const </td></tr>
<tr class="memdesc:a46aac5046e18e06ad60c693b26d42909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>ch</code> is an escape character.  <a href="#a46aac5046e18e06ad60c693b26d42909">More...</a><br/></td></tr>
<tr class="separator:a46aac5046e18e06ad60c693b26d42909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fed88d833a14a5fcc07c19defe5c2c3"><td class="memTemplParams" colspan="2">template&lt;typename BIter &gt; </td></tr>
<tr class="memitem:a3fed88d833a14a5fcc07c19defe5c2c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a> (BIter <a class="el" href="../../df/db6/geo__vectors__utils__TVector_8h.html#abd762dc0ccf00b6ee7f81a289b7bd4f8">begin</a>, BIter itCh) const </td></tr>
<tr class="memdesc:a3fed88d833a14a5fcc07c19defe5c2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the character pointed by <code>itCh</code> is escaped or not.  <a href="#a3fed88d833a14a5fcc07c19defe5c2c3">More...</a><br/></td></tr>
<tr class="separator:a3fed88d833a14a5fcc07c19defe5c2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade21ce7766e9762b631f5356a927e2fb"><td class="memTemplParams" colspan="2">template&lt;typename Sel &gt; </td></tr>
<tr class="memitem:ade21ce7766e9762b631f5356a927e2fb"><td class="memTemplItemLeft" align="right" valign="top">std::string_view::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ade21ce7766e9762b631f5356a927e2fb">findNextCharacter</a> (std::string_view <a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>, Sel select) const </td></tr>
<tr class="memdesc:ade21ce7766e9762b631f5356a927e2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next character satisfying the specified criterion.  <a href="#ade21ce7766e9762b631f5356a927e2fb">More...</a><br/></td></tr>
<tr class="separator:ade21ce7766e9762b631f5356a927e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17684960758e7b91c576d6c32cb5e457"><td class="memItemLeft" align="right" valign="top">std::string_view::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a17684960758e7b91c576d6c32cb5e457">findNextBlank</a> (std::string_view <a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>) const </td></tr>
<tr class="memdesc:a17684960758e7b91c576d6c32cb5e457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <code>findNextCharacter(std::string_view, Sel)</code>.  <a href="#a17684960758e7b91c576d6c32cb5e457">More...</a><br/></td></tr>
<tr class="separator:a17684960758e7b91c576d6c32cb5e457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f2bf3dde0cc0cd3ae60ae06a67cc15"><td class="memTemplParams" colspan="2">template&lt;typename CType &gt; </td></tr>
<tr class="memitem:a68f2bf3dde0cc0cd3ae60ae06a67cc15"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a68f2bf3dde0cc0cd3ae60ae06a67cc15">removeTrailingCharacters</a> (std::string_view <a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>, CType charType) const </td></tr>
<tr class="memdesc:a68f2bf3dde0cc0cd3ae60ae06a67cc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the blank characters a the beginning of <code>s</code>.  <a href="#a68f2bf3dde0cc0cd3ae60ae06a67cc15">More...</a><br/></td></tr>
<tr class="separator:a68f2bf3dde0cc0cd3ae60ae06a67cc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536eb3a876fac903379f1c3b4202e59c"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a536eb3a876fac903379f1c3b4202e59c">removeTrailingBlanks</a> (std::string_view <a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>) const </td></tr>
<tr class="memdesc:a536eb3a876fac903379f1c3b4202e59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the blank characters a the beginning of <code>s</code>.  <a href="#a536eb3a876fac903379f1c3b4202e59c">More...</a><br/></td></tr>
<tr class="separator:a536eb3a876fac903379f1c3b4202e59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc0cf30e7b55f3a4276a90b05939cba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">removeWordEscapes</a> (std::string &amp;&amp;w) const </td></tr>
<tr class="memdesc:a9fc0cf30e7b55f3a4276a90b05939cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>w</code> with all escape characters removed.  <a href="#a9fc0cf30e7b55f3a4276a90b05939cba">More...</a><br/></td></tr>
<tr class="separator:a9fc0cf30e7b55f3a4276a90b05939cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fc61da5a515bb1bcc652940aea6681"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ab6fc61da5a515bb1bcc652940aea6681">removeWordEscapes</a> (std::string_view w) const </td></tr>
<tr class="separator:ab6fc61da5a515bb1bcc652940aea6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5805544675796f2dddbb96212ccd81a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ae5805544675796f2dddbb96212ccd81a">removeWordEscapes</a> (const char *w) const </td></tr>
<tr class="separator:ae5805544675796f2dddbb96212ccd81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0dfa67494496674689d615d638369901"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">removeWordQuotations</a> (std::string &amp;&amp;w) const </td></tr>
<tr class="memdesc:a0dfa67494496674689d615d638369901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>w</code> with no quotation starts and ends.  <a href="#a0dfa67494496674689d615d638369901">More...</a><br/></td></tr>
<tr class="separator:a0dfa67494496674689d615d638369901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f91ef5eb96d77a2d0e764169bcbfdc1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0f91ef5eb96d77a2d0e764169bcbfdc1">removeWordQuotations</a> (std::string_view w) const </td></tr>
<tr class="separator:a0f91ef5eb96d77a2d0e764169bcbfdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab440b8ac5d12886c77e26cc7ffa88fea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ab440b8ac5d12886c77e26cc7ffa88fea">removeWordQuotations</a> (const char *w) const </td></tr>
<tr class="separator:ab440b8ac5d12886c77e26cc7ffa88fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2a13ec3538d5983475ba3165ce4bae72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t.html">SplitView_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2a13ec3538d5983475ba3165ce4bae72">splitOn</a> (std::string_view sv, std::string_view sep)</td></tr>
<tr class="memdesc:a2a13ec3538d5983475ba3165ce4bae72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the view <code>sv</code> in three: before <code>sep</code>, <code>sep</code> and after <code>sep</code>.  <a href="#a2a13ec3538d5983475ba3165ce4bae72">More...</a><br/></td></tr>
<tr class="separator:a2a13ec3538d5983475ba3165ce4bae72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97456628bb7fa9fbe5dff5de4c2580db"><td class="memItemLeft" align="right" valign="top">static std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a> (std::string const &amp;<a class="el" href="../../dd/dea/fix__cmake__genie3_8pl.html#a3691308f2a4c2f6983f2880d32e29c84">s</a>)</td></tr>
<tr class="memdesc:a97456628bb7fa9fbe5dff5de4c2580db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::string_view</code> from an entire string <code>s</code>.  <a href="#a97456628bb7fa9fbe5dff5de4c2580db">More...</a><br/></td></tr>
<tr class="separator:a97456628bb7fa9fbe5dff5de4c2580db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11253fc69ac22ca140e647511f200b1"><td class="memTemplParams" colspan="2">template&lt;typename BIter , typename EIter &gt; </td></tr>
<tr class="memitem:ac11253fc69ac22ca140e647511f200b1"><td class="memTemplItemLeft" align="right" valign="top">static std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ac11253fc69ac22ca140e647511f200b1">make_view</a> (BIter b, EIter <a class="el" href="../../d9/dd2/selectors_8fcl.html#ad3fec9b8b789cdb7b6899bd350d3a726">e</a>)</td></tr>
<tr class="memdesc:ac11253fc69ac22ca140e647511f200b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::string_view</code> from two string iterators <code>b</code> and <code>e</code>.  <a href="#ac11253fc69ac22ca140e647511f200b1">More...</a><br/></td></tr>
<tr class="separator:ac11253fc69ac22ca140e647511f200b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a><br class="typebreak"/>
&lt;&amp;std::isblank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a> {}</td></tr>
<tr class="memdesc:a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter for determining if a character is a blank (see <code>std::isblank()</code>).  <a href="#a2100f4bcaeaf4a5cc6181d9c533e6f64">More...</a><br/></td></tr>
<tr class="separator:a2100f4bcaeaf4a5cc6181d9c533e6f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523180de83def4934a514e53195233bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a523180de83def4934a514e53195233bd">DefaultParameters</a></td></tr>
<tr class="separator:a523180de83def4934a514e53195233bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeec514386dbfbf8e9ced24dcdccc764a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams</a> (<a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> <a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">params</a>)</td></tr>
<tr class="memdesc:aeec514386dbfbf8e9ced24dcdccc764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the parameters and caches.  <a href="#aeec514386dbfbf8e9ced24dcdccc764a">More...</a><br/></td></tr>
<tr class="separator:aeec514386dbfbf8e9ced24dcdccc764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2bceda651449f16763f91450d13f5d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a></td></tr>
<tr class="memdesc:a2bceda651449f16763f91450d13f5d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing parameters.  <a href="#a2bceda651449f16763f91450d13f5d27">More...</a><br/></td></tr>
<tr class="separator:a2bceda651449f16763f91450d13f5d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf582659e376b2550059557df8748f5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a></td></tr>
<tr class="memdesc:acf582659e376b2550059557df8748f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start characters of all supported quotations.  <a href="#acf582659e376b2550059557df8748f5e">More...</a><br/></td></tr>
<tr class="separator:acf582659e376b2550059557df8748f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utilities for text parsing. </p>
<p>This "class" is a glorified namespace with some configuration inside.</p>
<h2>Quotation </h2>
<p>A quoted string is the content in between an opening quoting sequence and the matching closing sequence. Each sequence may be any string, including but not limited to a one-character long string. Escaping the first character of an opening or closing quotation string will turn it in common string data carrying no quotation meaning.</p>
<h2>Escaping rules </h2>
<p>Any single character following the escape character is "escaped". The escaped characters lose their standard function and are replaced by a substitute character. For example, escaping the first character of a opening quotation makes that a standard character. An escaped escape character is always replaced by the character itself, without its escape function. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00054">54</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9fae443451384bddeecef2c0237c5f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">icarus::ParsingToolkit::QuotSpec_t</a> =  std::pair&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specification of quotation: opening and closing. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00063">63</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0c0771b23b03681072f28a87950c04e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icarus::ParsingToolkit::ParsingToolkit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default parsing parameters. </p>
<p>Creates a parser with the default parsing parameters. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00100">100</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;{ <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams</a>(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a523180de83def4934a514e53195233bd">DefaultParameters</a>); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_aeec514386dbfbf8e9ced24dcdccc764a"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aeec514386dbfbf8e9ced24dcdccc764a">icarus::ParsingToolkit::adoptParams</a></div><div class="ttdeci">void adoptParams(Params_t params)</div><div class="ttdoc">Initializes the parameters and caches. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00220">ParsingToolkit.cxx:220</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a523180de83def4934a514e53195233bd"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a523180de83def4934a514e53195233bd">icarus::ParsingToolkit::DefaultParameters</a></div><div class="ttdeci">static Params_t const DefaultParameters</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00097">ParsingToolkit.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1c911af179a04d12b4da58e68be9d019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icarus::ParsingToolkit::ParsingToolkit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a parser with the specified parsing parameters. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00103">103</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;{ <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aeec514386dbfbf8e9ced24dcdccc764a">adoptParams</a>(std::move(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">params</a>)); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_aeec514386dbfbf8e9ced24dcdccc764a"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#aeec514386dbfbf8e9ced24dcdccc764a">icarus::ParsingToolkit::adoptParams</a></div><div class="ttdeci">void adoptParams(Params_t params)</div><div class="ttdoc">Initializes the parameters and caches. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00220">ParsingToolkit.cxx:220</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a99d1de5816c9b1ee67a869157627d353"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">icarus::ParsingToolkit::params</a></div><div class="ttdeci">Params_t const &amp; params() const noexcept</div><div class="ttdoc">Returns the current parameters of parsing. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00111">ParsingToolkit.h:111</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeec514386dbfbf8e9ced24dcdccc764a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::ParsingToolkit::adoptParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the parameters and caches. </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00220">220</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                                                      {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a> = std::move(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">params</a>);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="comment">// sort the quotations by length</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> byOpeningLength = [](<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> <span class="keyword">const</span>&amp; <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>, <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> <span class="keyword">const</span>&amp; b)</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      std::size_t <span class="keyword">const</span> al = a.first.length(), bl = b.first.length();</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      <span class="keywordflow">return</span> (al != bl)? (al &gt; bl): (a &lt; b);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    };</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  std::sort(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">quotes</a>.begin(), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">quotes</a>.end(), byOpeningLength);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="comment">// collect the first character of each of the opening quotes</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  <span class="comment">// (sorted and with no duplicates)</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">QuotSpec_t</a> <span class="keyword">const</span>&amp; quotSpec: <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">quotes</a>)</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a> += quotSpec.first.front();</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  std::sort(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.begin(), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.end());</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.erase</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    (std::unique(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.begin(), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.end()), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.end());</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  </div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;} <span class="comment">// icarus::ParsingToolkit::adoptParams()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_ae26d399098e4b368e706a839de9427a6"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">icarus::ParsingToolkit::Params_t::quotes</a></div><div class="ttdeci">std::vector&lt; QuotSpec_t &gt; quotes</div><div class="ttdoc">List of matching start and end of quote. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00076">ParsingToolkit.h:76</a></div></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a9fae443451384bddeecef2c0237c5f27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fae443451384bddeecef2c0237c5f27">icarus::ParsingToolkit::QuotSpec_t</a></div><div class="ttdeci">std::pair&lt; std::string, std::string &gt; QuotSpec_t</div><div class="ttdoc">Specification of quotation: opening and closing. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00063">ParsingToolkit.h:63</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a99d1de5816c9b1ee67a869157627d353"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a99d1de5816c9b1ee67a869157627d353">icarus::ParsingToolkit::params</a></div><div class="ttdeci">Params_t const &amp; params() const noexcept</div><div class="ttdoc">Returns the current parameters of parsing. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00111">ParsingToolkit.h:111</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_acf582659e376b2550059557df8748f5e"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">icarus::ParsingToolkit::fQuoteStarts</a></div><div class="ttdeci">std::string fQuoteStarts</div><div class="ttdoc">Start characters of all supported quotations. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00524">ParsingToolkit.h:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a522a9e4e7289b01915f2bf429994f99b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iter icarus::ParsingToolkit::findCommentWord </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>beginWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>endWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first word starting with a comment marker. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>type of iterator to the words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginWord</td><td>iterator to the first word to consider </td></tr>
    <tr><td class="paramname">endWord</td><td>iterator past the lasy word to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the comment word, or <code>endWord</code> if not found</dd></dl>
<p>The original list is modified, the word starting with a comment marker and all the following ones are removed. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00748">748</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;{</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = beginWord; it != endWord; ++it) {</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4a/GeoObjectSorterSBND_8cxx.html#a1591fe891371002ed473166e626dc2a3">std::equal</a>(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#a611b5343feca4a0cfb6040d3b691a25f">comment</a>.begin(), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#a611b5343feca4a0cfb6040d3b691a25f">comment</a>.end(), <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>(*it)))</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;      <span class="keywordflow">return</span> it;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;  } <span class="comment">// for</span></div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  <span class="keywordflow">return</span> endWord;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findCommentWord()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_a611b5343feca4a0cfb6040d3b691a25f"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#a611b5343feca4a0cfb6040d3b691a25f">icarus::ParsingToolkit::Params_t::comment</a></div><div class="ttdeci">std::string comment</div><div class="ttdoc">Word introducing a comment. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00071">ParsingToolkit.h:71</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
<div class="ttc" id="GeoObjectSorterSBND_8cxx_html_a1591fe891371002ed473166e626dc2a3"><div class="ttname"><a href="../../d2/d4a/GeoObjectSorterSBND_8cxx.html#a1591fe891371002ed473166e626dc2a3">equal</a></div><div class="ttdeci">bool equal(double a, double b)</div><div class="ttdoc">Comparison tolerance, in centimeters. </div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d4a/GeoObjectSorterSBND_8cxx_source.html#l00033">GeoObjectSorterSBND.cxx:33</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f1665420e8a8888782cfa4cf079285f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>beginKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>endKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the key found within <code>sv</code>, empty if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first). The first character of the key must not be escaped. Escaped characters in the key are not supported.</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>.</p>
<p>The quoting in <code>sv</code> is ignored. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00634">634</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;{</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="keyword">typename</span> std::iterator_traits&lt;BIter&gt;::value_type <span class="keyword">const</span>* key = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  std::size_t keyPos = std::string_view::npos;</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  </div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> iKey = beginKey; iKey != endKey; ++iKey) {</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="comment">// find where this key is (unescaped)</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    std::size_t pos = 0;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    <span class="keywordflow">while</span> (pos &lt; sv.length()) {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      pos = sv.find(*iKey, pos);</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;      <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(sv.begin(), sv.begin() + pos)) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;      ++pos;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    }</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    <span class="comment">// is this the first among the keys?</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">if</span> (pos &gt;= std::min(keyPos, sv.length())) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    key = &amp;*iKey;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    keyPos = pos;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  } <span class="comment">// for keys</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  </div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;  <span class="comment">// return a substring of sv, not key</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  <span class="keywordflow">if</span> (key) {</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">std::begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">std::end</a>;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    std::size_t <span class="keyword">const</span> keyLength = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(*key).length();</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    <span class="keywordflow">return</span> { sv.data() + keyPos, keyLength };</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  }</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">return</span> { sv.data() + sv.length(), 0 };</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findFirstUnescaped()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a3fed88d833a14a5fcc07c19defe5c2c3"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">icarus::ParsingToolkit::isCharacterEscaped</a></div><div class="ttdeci">bool isCharacterEscaped(BIter begin, BIter itCh) const </div><div class="ttdoc">Returns whether the character pointed by itCh is escaped or not. </div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad1d39b99f5b6ba67d5e54752a39ccd78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Keys &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Keys const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the key found within <code>sv</code>, empty if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first). The first character of the key must not be escaped. Escaped characters in the key are not supported.</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>.</p>
<p>The quoting in <code>sv</code> is ignored. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00667">667</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;{</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">std::begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">std::end</a>;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">findFirstUnescaped</a>(sv, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>(keys), <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>(keys)); </div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findFirstUnescaped(Keys)</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a6f1665420e8a8888782cfa4cf079285f"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">icarus::ParsingToolkit::findFirstUnescaped</a></div><div class="ttdeci">std::string_view findFirstUnescaped(std::string_view sv, BIter beginKey, EIter endKey) const </div><div class="ttdoc">Finds the first of the specified keys in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00634">ParsingToolkit.h:634</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af246f5477e60fc2f3db0b02884c048cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnescaped </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Key &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00677">677</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">findFirstUnescaped</a>(sv, keys.begin(), keys.end()); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a6f1665420e8a8888782cfa4cf079285f"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">icarus::ParsingToolkit::findFirstUnescaped</a></div><div class="ttdeci">std::string_view findFirstUnescaped(std::string_view sv, BIter beginKey, EIter endKey) const </div><div class="ttdoc">Finds the first of the specified keys in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00634">ParsingToolkit.h:634</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a92fdaee01be26d53ede077c5e8e38b89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>beginKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>endKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in the unquoted part of <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the view pointing to the key in <code>sv</code>, or empty to its end if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first).</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00684">684</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;{</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  </div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  <span class="comment">// if a key is found between `b` and `e`, returns `sv` split around the key;</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <span class="comment">// otherwise, all `sv` is in post</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="keyword">auto</span> findKey = [<span class="keyword">this</span>,beginKey,endKey]</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    (std::string_view::const_iterator b, std::string_view::const_iterator <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>)</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">findFirstUnescaped</a>(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(b, <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>), beginKey, endKey); };</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  </div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  std::string_view key{ sv.data() + sv.length(), 0 };</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    </div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <span class="comment">// find the next quotation</span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> [ fromQ, qptr ] = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">findQuotationStart</a>(sv);</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    </div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;    <span class="comment">// search in the unquoted part</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;    key = findKey(sv.begin(), fromQ.begin());</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <span class="keywordflow">if</span> (!key.empty()) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    </div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    <span class="comment">// skip the quotation; if there is no quotation, we are done</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    <span class="keywordflow">if</span> (!qptr) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    </div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    sv = fromQ;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    sv.remove_prefix(qptr-&gt;first.length()); <span class="comment">// skip the quotation start</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    </div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="comment">// find the end of quotation</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    std::string_view <span class="keyword">const</span> afterQ = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">findQuotationEnd</a>(sv, qptr-&gt;second);</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    </div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    <span class="keywordflow">if</span> (afterQ.empty()) { <span class="comment">// begin of quotation, but no end: no good</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;      <span class="comment">// so we don&#39;t consider this as quotation: search in the &quot;quoted&quot; part</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;      key = findKey(fromQ.begin(), fromQ.end());</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    } <span class="comment">// if</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    <span class="comment">// skip the quoted material, and the quotation end too</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    sv = afterQ;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    sv.remove_prefix(qptr-&gt;second.length());</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    </div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  </div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="keywordflow">return</span> key;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  </div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findFirstUnquoted(Iter)</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a62423130160f6b379f638ca942b78225"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">icarus::ParsingToolkit::findQuotationStart</a></div><div class="ttdeci">std::pair&lt; std::string_view, QuotSpec_t const * &gt; findQuotationStart(std::string_view sv) const </div><div class="ttdoc">Finds the start of the next quotation in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">ParsingToolkit.cxx:66</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a6f1665420e8a8888782cfa4cf079285f"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a6f1665420e8a8888782cfa4cf079285f">icarus::ParsingToolkit::findFirstUnescaped</a></div><div class="ttdeci">std::string_view findFirstUnescaped(std::string_view sv, BIter beginKey, EIter endKey) const </div><div class="ttdoc">Finds the first of the specified keys in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00634">ParsingToolkit.h:634</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ad9bfd5281c00ddad61b7354cce785001"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">icarus::ParsingToolkit::findQuotationEnd</a></div><div class="ttdeci">std::string_view findQuotationEnd(std::string_view sv, std::string const &amp;quotEnd) const </div><div class="ttdoc">Finds the quotation end in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00107">ParsingToolkit.cxx:107</a></div></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9184c2741f2e6f8e33182e368fd9f141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Keys &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Keys const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first of the specified keys in the unquoted part of <code>sv</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>type of iterator to the keys </td></tr>
    <tr><td class="paramname">EIter</td><td>type of key end-iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>string to be parsed </td></tr>
    <tr><td class="paramname">beginKey</td><td>iterator to the first key </td></tr>
    <tr><td class="paramname">endKey</td><td>iterator past the last key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the view pointing to the key in <code>sv</code>, or empty to its end if none</dd></dl>
<p>The <code>keys</code> are required to be sorted, longest first, since they are tested in order and the first match is kept (e.g. if the first key is <code>=</code> and the second is <code>==</code>, the second key is never matched since the first one matches first).</p>
<p>If no <code>key</code> is found, the returned view is zero-length and pointing to the end of <code>sv</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00732">732</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;{</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">std::begin</a>, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">std::end</a>;</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a92fdaee01be26d53ede077c5e8e38b89">findFirstUnquoted</a>(sv, <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>(keys), <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end</a>(keys)); </div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findFirstUnquoted(Keys)</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a92fdaee01be26d53ede077c5e8e38b89"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a92fdaee01be26d53ede077c5e8e38b89">icarus::ParsingToolkit::findFirstUnquoted</a></div><div class="ttdeci">std::string_view findFirstUnquoted(std::string_view sv, BIter beginKey, EIter endKey) const </div><div class="ttdoc">Finds the first of the specified keys in the unquoted part of sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00684">ParsingToolkit.h:684</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a83e62c4349779633c803acf9075906fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findFirstUnquoted </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Key &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00742">742</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;  { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a92fdaee01be26d53ede077c5e8e38b89">findFirstUnquoted</a>(sv, keys.begin(), keys.end()); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a92fdaee01be26d53ede077c5e8e38b89"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a92fdaee01be26d53ede077c5e8e38b89">icarus::ParsingToolkit::findFirstUnquoted</a></div><div class="ttdeci">std::string_view findFirstUnquoted(std::string_view sv, BIter beginKey, EIter endKey) const </div><div class="ttdoc">Finds the first of the specified keys in the unquoted part of sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00684">ParsingToolkit.h:684</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a17684960758e7b91c576d6c32cb5e457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::const_iterator icarus::ParsingToolkit::findNextBlank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <code>findNextCharacter(std::string_view, Sel)</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00405">405</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ade21ce7766e9762b631f5356a927e2fb">findNextCharacter</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>, <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ade21ce7766e9762b631f5356a927e2fb"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ade21ce7766e9762b631f5356a927e2fb">icarus::ParsingToolkit::findNextCharacter</a></div><div class="ttdeci">std::string_view::const_iterator findNextCharacter(std::string_view s, Sel select) const </div><div class="ttdoc">Finds the next character satisfying the specified criterion. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00778">ParsingToolkit.h:778</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2100f4bcaeaf4a5cc6181d9c533e6f64"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">icarus::ParsingToolkit::isBlank</a></div><div class="ttdeci">static constexpr CCTypeAdapter&lt;&amp;std::isblank &gt; isBlank</div><div class="ttdoc">Adapter for determining if a character is a blank (see std::isblank()). </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00092">ParsingToolkit.h:92</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ade21ce7766e9762b631f5356a927e2fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::const_iterator icarus::ParsingToolkit::findNextCharacter </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sel&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next character satisfying the specified criterion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sel</td><td>type of functor determining which character to consider blank </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>view of the string to be parsed </td></tr>
    <tr><td class="paramname">select</td><td>functor determining which character(s) to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first character, <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">s.end()</a></code> if none</dd></dl>
<p>By default, the selected character is a blank character <code>ch</code>, which has <code>std::isblank(ch)</code> <code>true</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00778">778</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;{</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> sbegin = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.begin(), send = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.end();</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  <span class="keyword">auto</span> it = sbegin;</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <span class="keywordflow">while</span> (it != send) {</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    it = std::find_if(it, send, selector);</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(sbegin, it)) <span class="keywordflow">return</span> it;</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    ++it; <span class="comment">// skip the escaped character and move on</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;  <span class="keywordflow">return</span> send;</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findNextCharacter()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a3fed88d833a14a5fcc07c19defe5c2c3"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">icarus::ParsingToolkit::isCharacterEscaped</a></div><div class="ttdeci">bool isCharacterEscaped(BIter begin, BIter itCh) const </div><div class="ttdoc">Returns whether the character pointed by itCh is escaped or not. </div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad9bfd5281c00ddad61b7354cce785001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::findQuotationEnd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>quotEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the quotation end in <code>sv</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>the buffer to look the quotation end into </td></tr>
    <tr><td class="paramname">quotEnd</td><td>the quotation end to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of <code>sv</code> from the quotation end, included, empty if not found</dd></dl>
<p>Note that <code>sv</code> should not include the quotation start. </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00107">107</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    std::size_t <span class="keyword">const</span> pos = sv.find(quotEnd);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">if</span> (pos == std::string_view::npos) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    </div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(sv.begin(), sv.begin() + pos)) {</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      sv.remove_prefix(pos);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="keywordflow">return</span> sv;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    sv.remove_prefix(pos + 1);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(sv.end(), sv.end());</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findQuotationEnd()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a3fed88d833a14a5fcc07c19defe5c2c3"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">icarus::ParsingToolkit::isCharacterEscaped</a></div><div class="ttdeci">bool isCharacterEscaped(BIter begin, BIter itCh) const </div><div class="ttdoc">Returns whether the character pointed by itCh is escaped or not. </div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a62423130160f6b379f638ca942b78225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::ParsingToolkit::findQuotationStart </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the start of the next quotation in <code>sv</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>the buffer to look the quotation start into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a subview of <code>sv</code> starting from the quotation found, empty if none </dd></dl>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">66</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;{</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// look for a character that could start a quotation opening</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    std::size_t <span class="keyword">const</span> startPos = sv.find_first_of(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="comment">// no such character found:</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordflow">if</span> (startPos == std::string_view::npos) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// if the character is escaped, this is not a quotation opening:</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(sv.begin(), sv.begin() + startPos)) {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      sv.remove_prefix(std::min(startPos + 1, sv.length()));</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    sv.remove_prefix(std::min(startPos, sv.length()));</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// try all the opening quotes</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="comment">// (may be optimized by grouping them by first character)</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; qSpec: <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">quotes</a>) {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">//       if (sv.starts_with(qSpec.first)) return { sv, &amp;qSpec }; // C++20</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      <span class="keywordflow">if</span> (sv.compare(0, qSpec.first.length(), qSpec.first) == 0)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keywordflow">return</span> { sv, &amp;qSpec };</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      </div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    } <span class="comment">// for quotes</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    </div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// nope, just a character; remove it and keep looking</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    sv.remove_prefix(1);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  } <span class="comment">// while sv</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">return</span> { <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(sv.end(), sv.end()), <span class="keyword">nullptr</span> };</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;} <span class="comment">// icarus::ParsingToolkit::findQuotationStart()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_ae26d399098e4b368e706a839de9427a6"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ae26d399098e4b368e706a839de9427a6">icarus::ParsingToolkit::Params_t::quotes</a></div><div class="ttdeci">std::vector&lt; QuotSpec_t &gt; quotes</div><div class="ttdoc">List of matching start and end of quote. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00076">ParsingToolkit.h:76</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a3fed88d833a14a5fcc07c19defe5c2c3"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">icarus::ParsingToolkit::isCharacterEscaped</a></div><div class="ttdeci">bool isCharacterEscaped(BIter begin, BIter itCh) const </div><div class="ttdoc">Returns whether the character pointed by itCh is escaped or not. </div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_acf582659e376b2550059557df8748f5e"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">icarus::ParsingToolkit::fQuoteStarts</a></div><div class="ttdeci">std::string fQuoteStarts</div><div class="ttdoc">Start characters of all supported quotations. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00524">ParsingToolkit.h:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3fed88d833a14a5fcc07c19defe5c2c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isCharacterEscaped </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>itCh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the character pointed by <code>itCh</code> is escaped or not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BIter</td><td>iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the beginning of the string </td></tr>
    <tr><td class="paramname">itCh</td><td>iterator to the character to be investigated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether there is an unescaped escape character before <code>itCh</code></dd></dl>
<p>Note that <code>itCh</code> may be a end iterator (for an empty string, the result is <code>false</code>). </p>

</div>
</div>
<a class="anchor" id="ad209b8a70d8a396de63efb27649195c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isCharacterEscaped </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>itCh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00760">760</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;{</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nEscapes = 0U;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="keywordflow">while</span> (itCh-- != <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin</a>) {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    </div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a46aac5046e18e06ad60c693b26d42909">isEscape</a>(*itCh)) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    ++nEscapes;</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    </div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  </div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="keywordflow">return</span> (nEscapes &amp; 1) == 1; <span class="comment">// odd number of escapes means escaped</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  </div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;} <span class="comment">// icarus::ParsingToolkit::isCharacterEscaped()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a46aac5046e18e06ad60c693b26d42909"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a46aac5046e18e06ad60c693b26d42909">icarus::ParsingToolkit::isEscape</a></div><div class="ttdeci">bool isEscape(char ch) const </div><div class="ttdoc">Returns whether ch is an escape character. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00375">ParsingToolkit.h:375</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a46aac5046e18e06ad60c693b26d42909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isEscape </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>ch</code> is an escape character. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00375">375</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;{ <span class="keywordflow">return</span> ch == <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">escape</a>; }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_aefba854f9d6536bcbe3b27193c0ed567"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">icarus::ParsingToolkit::Params_t::escape</a></div><div class="ttdeci">char escape</div><div class="ttdoc">Escape character. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00069">ParsingToolkit.h:69</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2f0f59b97e625e2d57301bf3172c0669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool icarus::ParsingToolkit::isQuotationUnclosed </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the sequence <code>sv</code> has unclosed quotation at its end. </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00128">128</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                                                                      {</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keyword">auto</span> [ qsv, qptr ] = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">findQuotationStart</a>(sv);</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keywordflow">if</span> (!qptr) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    </div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    qsv.remove_prefix(qptr-&gt;first.length()); <span class="comment">// remove the opening quote</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    qsv = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">findQuotationEnd</a>(qsv, qptr-&gt;second);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">if</span> (qsv.empty()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    qsv.remove_prefix(qptr-&gt;second.length());</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    sv = qsv;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  </div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;} <span class="comment">// icarus::ParsingToolkit::isQuotationUnclosed()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a62423130160f6b379f638ca942b78225"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">icarus::ParsingToolkit::findQuotationStart</a></div><div class="ttdeci">std::pair&lt; std::string_view, QuotSpec_t const * &gt; findQuotationStart(std::string_view sv) const </div><div class="ttdoc">Finds the start of the next quotation in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">ParsingToolkit.cxx:66</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ad9bfd5281c00ddad61b7354cce785001"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">icarus::ParsingToolkit::findQuotationEnd</a></div><div class="ttdeci">std::string_view findQuotationEnd(std::string_view sv, std::string const &amp;quotEnd) const </div><div class="ttdoc">Finds the quotation end in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00107">ParsingToolkit.cxx:107</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97456628bb7fa9fbe5dff5de4c2580db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string_view icarus::ParsingToolkit::make_view </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>std::string_view</code> from an entire string <code>s</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00510">510</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.begin(), <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.end()); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac11253fc69ac22ca140e647511f200b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BIter , typename EIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string_view icarus::ParsingToolkit::make_view </td>
          <td>(</td>
          <td class="paramtype">BIter&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EIter&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code>std::string_view</code> from two string iterators <code>b</code> and <code>e</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00515">515</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    { <span class="keywordflow">return</span> { &amp;*b, <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(<a class="code" href="../../da/d4d/namespaceicarus.html#a6ad3253842c1a0803df7cd600b60c35f">std::distance</a>(b, <a class="code" href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a>)) }; }</div>
<div class="ttc" id="namespaceicarus_html_a6ad3253842c1a0803df7cd600b60c35f"><div class="ttname"><a href="../../da/d4d/namespaceicarus.html#a6ad3253842c1a0803df7cd600b60c35f">icarus::distance</a></div><div class="ttdeci">double distance(geo::Point_t const &amp;point, CathodeDesc_t const &amp;cathode)</div><div class="ttdoc">Returns the distance of a point from the cathode. </div><div class="ttdef"><b>Definition:</b> <a href="../../dc/dd1/CathodeCrossingUtils_8cxx_source.html#l00035">CathodeCrossingUtils.cxx:35</a></div></div>
<div class="ttc" id="updateVersionList_8sh_html_a067a8c1534d6da9b2c501a6cf4ef89bd"><div class="ttname"><a href="../../d4/dca/updateVersionList_8sh.html#a067a8c1534d6da9b2c501a6cf4ef89bd">e</a></div><div class="ttdeci">do i e</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dca/updateVersionList_8sh_source.html#l00068">updateVersionList.sh:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99d1de5816c9b1ee67a869157627d353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> const&amp; icarus::ParsingToolkit::params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current parameters of parsing. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00111">111</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>; }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9a7a2a18c8c7a4e2855ae190cd85fb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, unsigned int &gt; icarus::ParsingToolkit::readMultiline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single line of text from the input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read, and the number of lines read </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d4/dce/structicarus_1_1ParsingToolkit_1_1Error.html">Error</a></td><td>on fatal parsing errors</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads entire lines from <code>in</code>, where a line is defined as in <code>std::getline()</code>. If the line ends with an unescaped escape character, another line is read and appended (the escape character is dropped). The return value is the merged string with no end-of-line characters, and the number of lines read. If there is no string to be read, it returns an empty string and <code>0U</code>.</p>
<h3>Special behaviour</h3>
<ul>
<li>If the line ends while a quotation is still open, the next line is also merged, and the line break is kept; to merge quoted lines without preserving the line break character, end the quote on the first line, immediately break the line escaping it, and then next line should immediately start with opening a quotation.</li>
<li>If the line ends while a quotation is still open, it is a parsing error to have the line break character escaped (an exception will be thrown) merged, and the line break is kept.</li>
<li>If the file ends while a quotation is still open, the line is preserved as such. </li>
</ul>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00027">27</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;{</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  std::string fullLine;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  std::string openQuoteLine;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nLines = 0U;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="keywordflow">while</span> (<a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a>) {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    std::string line;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    std::getline(<a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a>, line, <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a>.widen(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ac6ce4e274ab86089a463bbbf43d609b8">EOL</a>));</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordtype">bool</span> <span class="keyword">const</span> isEOF = <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a>.eof();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">if</span> (!isEOF || !line.empty()) ++nLines;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    openQuoteLine.append(line);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2f0f59b97e625e2d57301bf3172c0669">isQuotationUnclosed</a>(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(openQuoteLine))) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(line.begin(), line.end())) {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        fullLine.append(openQuoteLine);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">throw</span> Error{ <span class="stringliteral">&quot;Parser error: escaped end-of-line inside a quotation:\n&quot;</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;          + fullLine + <span class="stringliteral">&quot;\n&quot;</span> };</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      }</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;      <span class="comment">// if the newline is quoted, it&#39;s preserved</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;      <span class="keywordflow">if</span> (!isEOF) openQuoteLine += <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ac6ce4e274ab86089a463bbbf43d609b8">EOL</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    fullLine.append(openQuoteLine);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    openQuoteLine.clear();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">isCharacterEscaped</a>(fullLine.begin(), fullLine.end())) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    fullLine.pop_back(); <span class="comment">// remove the escape character</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  fullLine.append(openQuoteLine); <span class="comment">// usually empty</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="keywordflow">return</span> { std::move(fullLine), nLines };</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;} <span class="comment">// icarus::ParsingToolkit::readMultiline()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2f0f59b97e625e2d57301bf3172c0669"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2f0f59b97e625e2d57301bf3172c0669">icarus::ParsingToolkit::isQuotationUnclosed</a></div><div class="ttdeci">bool isQuotationUnclosed(std::string_view sv) const </div><div class="ttdoc">Returns if the sequence sv has unclosed quotation at its end. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00128">ParsingToolkit.cxx:128</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_ac6ce4e274ab86089a463bbbf43d609b8"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#ac6ce4e274ab86089a463bbbf43d609b8">icarus::ParsingToolkit::Params_t::EOL</a></div><div class="ttdeci">char EOL</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00073">ParsingToolkit.h:73</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a3fed88d833a14a5fcc07c19defe5c2c3"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a3fed88d833a14a5fcc07c19defe5c2c3">icarus::ParsingToolkit::isCharacterEscaped</a></div><div class="ttdeci">bool isCharacterEscaped(BIter begin, BIter itCh) const </div><div class="ttdoc">Returns whether the character pointed by itCh is escaped or not. </div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="quiet__Math__Functor__test_8sh_html_adfac98fbd1e85554d2cf0454cdcbc717"><div class="ttname"><a href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a></div><div class="ttdeci">if &amp;&amp;[-z&quot;$BASH_VERSION&quot;] then echo Attempting to switch to bash bash shellSwitch exit fi &amp;&amp;[&quot;$1&quot;= 'shellSwitch'] shift declare a IncludeDirectives for Dir in</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/df7/quiet__Math__Functor__test_8sh_source.html#l00023">quiet_Math_Functor_test.sh:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa9fa4efd4850e6ba028ab2598c66ec3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icarus::ParsingToolkit::removeCommentLine </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; WordType &gt; &amp;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the words from the one starting with a comment marker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>list of words</td></tr>
  </table>
  </dd>
</dl>
<p>The original list is modified, the word starting with a comment marker and all the following ones are removed. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00216">216</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    { words.erase(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a522a9e4e7289b01915f2bf429994f99b">findCommentWord</a>(words.begin(), words.end()), words.end()); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a522a9e4e7289b01915f2bf429994f99b"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a522a9e4e7289b01915f2bf429994f99b">icarus::ParsingToolkit::findCommentWord</a></div><div class="ttdeci">Iter findCommentWord(Iter beginWord, Iter endWord) const </div><div class="ttdoc">Finds the first word starting with a comment marker. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00748">ParsingToolkit.h:748</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a544e96ba886bc2df9360edb14559460c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Words &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; icarus::ParsingToolkit::removeEscapes </td>
          <td>(</td>
          <td class="paramtype">Words const &amp;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>words</code> with all escape characters removed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Words</td><td>type of list of words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the list of words to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of words without escaping </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>removeEscapes(std::string)</code></dd></dl>
<p>The escaping is removed from each of the <code>words</code> in the list, which are treated as independent. See <code>removeEscapes(std::string)</code> for the details. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00810">810</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;{</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">std::size</a>;</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  std::vector&lt;std::string&gt; nv;</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  nv.reserve(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">size</a>(words));</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word: words) nv.push_back(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">removeWordEscapes</a>(word));</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  <span class="keywordflow">return</span> nv;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;} <span class="comment">// icarus::ParsingToolkit::removeEscapes()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a9fc0cf30e7b55f3a4276a90b05939cba"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">icarus::ParsingToolkit::removeWordEscapes</a></div><div class="ttdeci">std::string removeWordEscapes(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with all escape characters removed. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00158">ParsingToolkit.cxx:158</a></div></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aaae74cf315284bc0f44c2e050c119781"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">icarus::ns::util::size</a></div><div class="ttdeci">std::size_t size(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00561">FixedBins.h:561</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af4a8254522168c6c464db3203f73dabf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Words &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; icarus::ParsingToolkit::removeQuotations </td>
          <td>(</td>
          <td class="paramtype">Words const &amp;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>words</code> with no quotation starts and ends. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Words</td><td>type of list of words </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the list of words to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of words without quotations </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>removeQuotations(std::string)</code></dd></dl>
<p>The substitution is applied on each of the <code>words</code> in the list, which are treated as independent. See <code>removeQuotations(std::string)</code> for the details. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00823">823</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;{</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;  <span class="keyword">using</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">std::size</a>;</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;  std::vector&lt;std::string&gt; nv;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  nv.reserve(<a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">size</a>(words));</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word: words) nv.push_back(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">removeWordQuotations</a>(word));</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;  <span class="keywordflow">return</span> nv;</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;} <span class="comment">// icarus::ParsingToolkit::removeEscapes()</span></div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aaae74cf315284bc0f44c2e050c119781"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aaae74cf315284bc0f44c2e050c119781">icarus::ns::util::size</a></div><div class="ttdeci">std::size_t size(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00561">FixedBins.h:561</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a0dfa67494496674689d615d638369901"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">icarus::ParsingToolkit::removeWordQuotations</a></div><div class="ttdeci">std::string removeWordQuotations(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with no quotation starts and ends. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00176">ParsingToolkit.cxx:176</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a536eb3a876fac903379f1c3b4202e59c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::removeTrailingBlanks </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumes the blank characters a the beginning of <code>s</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a68f2bf3dde0cc0cd3ae60ae06a67cc15" title="Consumes the blank characters a the beginning of s. ">removeTrailingCharacters()</a></code> </dd></dl>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00422">422</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a68f2bf3dde0cc0cd3ae60ae06a67cc15">removeTrailingCharacters</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>, <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a68f2bf3dde0cc0cd3ae60ae06a67cc15"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a68f2bf3dde0cc0cd3ae60ae06a67cc15">icarus::ParsingToolkit::removeTrailingCharacters</a></div><div class="ttdeci">std::string_view removeTrailingCharacters(std::string_view s, CType charType) const </div><div class="ttdoc">Consumes the blank characters a the beginning of s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00794">ParsingToolkit.h:794</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2100f4bcaeaf4a5cc6181d9c533e6f64"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">icarus::ParsingToolkit::isBlank</a></div><div class="ttdeci">static constexpr CCTypeAdapter&lt;&amp;std::isblank &gt; isBlank</div><div class="ttdoc">Adapter for determining if a character is a blank (see std::isblank()). </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00092">ParsingToolkit.h:92</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a68f2bf3dde0cc0cd3ae60ae06a67cc15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string_view icarus::ParsingToolkit::removeTrailingCharacters </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CType&#160;</td>
          <td class="paramname"><em>charType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes the blank characters a the beginning of <code>s</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CType</td><td>type of functor determining which type of character to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>view of the string to be parsed </td></tr>
    <tr><td class="paramname">charType</td><td>functor determining which characters to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of <code>s</code> starting after its trailing <code>charType</code> characters </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a536eb3a876fac903379f1c3b4202e59c" title="Consumes the blank characters a the beginning of s. ">removeTrailingBlanks()</a></code> </dd></dl>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00794">794</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;{</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;  <span class="comment">// REQUIREMENT: escape character must not be classified as delimiter</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;  assert(!charType(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">escape</a>));</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;  </div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;  <span class="keywordflow">while</span> (!<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.empty()) {</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="keywordflow">if</span> (!charType(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.front())) <span class="keywordflow">break</span>; <span class="comment">// escape character triggers this too</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.remove_prefix(1U);</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>;</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;} <span class="comment">// icarus::ParsingToolkit::removeTrailingCharacters()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_aefba854f9d6536bcbe3b27193c0ed567"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">icarus::ParsingToolkit::Params_t::escape</a></div><div class="ttdeci">char escape</div><div class="ttdoc">Escape character. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00069">ParsingToolkit.h:69</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9fc0cf30e7b55f3a4276a90b05939cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>w</code> with all escape characters removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>the string to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>w</code> without escaping </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>removeEscapes(Word const&amp;)</code></dd></dl>
<p>The escaping scheme that is applied is just to remove the escape character (no replacement table supported here). An unescaped escape character at the end of the string will not be removed.</p>
<p>It is recommended that this be done as the last step of the parsing, since it changes the meaning of the parsing elements like quotations, comments etc.</p>
<p>Note that applying <code><a class="el" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a544e96ba886bc2df9360edb14559460c" title="Returns a copy of words with all escape characters removed. ">removeEscapes()</a></code> more than once will keep removing characters that in the earlier passes were not considered escapes (for example, four escape characters become two in the first pass, one in the second and disappear in the following passes). </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00158">158</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                                                                     {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  </div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="comment">// replace in place</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  std::string::const_iterator iSrc = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.begin(), send = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.end();</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  std::string::iterator iDest = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.begin();</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  </div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// if the last character is an escape, it&#39;s kept</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="keywordflow">while</span> (iSrc != send) {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordtype">char</span> <span class="keyword">const</span> ch = *iSrc++;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    *iDest++ = (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a46aac5046e18e06ad60c693b26d42909">isEscape</a>(ch) &amp;&amp; (iSrc != send))? *iSrc++: ch;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.erase(iDest, send);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="keywordflow">return</span> std::move(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;} <span class="comment">// icarus::ParsingToolkit::removeWordEscapes()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a46aac5046e18e06ad60c693b26d42909"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a46aac5046e18e06ad60c693b26d42909">icarus::ParsingToolkit::isEscape</a></div><div class="ttdeci">bool isEscape(char ch) const </div><div class="ttdoc">Returns whether ch is an escape character. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00375">ParsingToolkit.h:375</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6fc61da5a515bb1bcc652940aea6681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00447">447</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">removeWordEscapes</a>(std::string{ <a class="code" href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">w</a> }); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a9fc0cf30e7b55f3a4276a90b05939cba"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">icarus::ParsingToolkit::removeWordEscapes</a></div><div class="ttdeci">std::string removeWordEscapes(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with all escape characters removed. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00158">ParsingToolkit.cxx:158</a></div></div>
<div class="ttc" id="namespacegen__crt__frags_html_a8cdc67339147aad209b4122a38d7e246"><div class="ttname"><a href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">gen_crt_frags.w</a></div><div class="ttdeci">tuple w</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d8c/gen__crt__frags_8py_source.html#l01416">gen_crt_frags.py:1416</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae5805544675796f2dddbb96212ccd81a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordEscapes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00449">449</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">removeWordEscapes</a>(std::string{ <a class="code" href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">w</a> }); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a9fc0cf30e7b55f3a4276a90b05939cba"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a9fc0cf30e7b55f3a4276a90b05939cba">icarus::ParsingToolkit::removeWordEscapes</a></div><div class="ttdeci">std::string removeWordEscapes(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with all escape characters removed. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00158">ParsingToolkit.cxx:158</a></div></div>
<div class="ttc" id="namespacegen__crt__frags_html_a8cdc67339147aad209b4122a38d7e246"><div class="ttname"><a href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">gen_crt_frags.w</a></div><div class="ttdeci">tuple w</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d8c/gen__crt__frags_8py_source.html#l01416">gen_crt_frags.py:1416</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0dfa67494496674689d615d638369901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>w</code> with no quotation starts and ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>the string to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the word without quotations </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code>removeQuotations(Words const&amp;)</code></dd></dl>
<p>Escaping is still honored (if present).</p>
<p>Note that applying <code>removeQuotations</code> more than once will keep removing quotation markings that in the earlier passes were not considered such (for example, `a1 &lt;&lt; "b1 &lt;&lt; 'c1 &lt;&lt; " or " &lt;&lt; c2' &lt;&lt; b2" &lt;&lt; a2<code>will become first </code>a1 &lt;&lt; b1 &lt;&lt; 'c1 &lt;&lt; or &lt;&lt; c2' &lt;&lt; b2 &lt;&lt; a2<code>, and eventually </code>a1 &lt;&lt; b1 &lt;&lt; c1 &lt;&lt; or &lt;&lt; c2 &lt;&lt; b2 &lt;&lt; a2`). </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00176">176</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;{</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  std::string_view sv = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  std::string::iterator iDest = <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.begin();</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="comment">// find the next quotation</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> [ fromQ, qptr ] = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">findQuotationStart</a>(sv);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="comment">// copy the material until the next quotation</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    iDest = <a class="code" href="../../d6/dd6/RangeForWrapper__test_8cc.html#a2a47a7f29f0ddd7ff5d68f8aff63125c">std::copy</a>(sv.begin(), fromQ.begin(), iDest);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    sv = fromQ;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    </div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">if</span> (!qptr) <span class="keywordflow">break</span>; <span class="comment">// if there is no quotation, we are done</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    sv.remove_prefix(qptr-&gt;first.length()); <span class="comment">// skip the quotation start</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    </div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="comment">// find the end of quotation</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    std::string_view <span class="keyword">const</span> afterQ = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">findQuotationEnd</a>(sv, qptr-&gt;second);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    </div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">if</span> (afterQ.empty()) { <span class="comment">// begin of quotation, but no end: no good</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      <span class="comment">// leave the &quot;begin of quotation&quot; as is</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      iDest = <a class="code" href="../../d6/dd6/RangeForWrapper__test_8cc.html#a2a47a7f29f0ddd7ff5d68f8aff63125c">std::copy</a>(fromQ.begin(), fromQ.end(), iDest);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      sv.remove_prefix(sv.length()); <span class="comment">// note: quote start was already removed</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    }</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">// copy the quoted material</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    iDest = <a class="code" href="../../d6/dd6/RangeForWrapper__test_8cc.html#a2a47a7f29f0ddd7ff5d68f8aff63125c">std::copy</a>(sv.begin(), afterQ.begin(), iDest);</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    sv = afterQ;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    </div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    sv.remove_prefix(qptr-&gt;second.length()); <span class="comment">// skip the quotation end</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    </div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  assert(sv.empty());</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.erase(iDest, <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>.end());</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="keywordflow">return</span> std::move(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;} <span class="comment">// icarus::ParsingToolkit::removeWordQuotations()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a62423130160f6b379f638ca942b78225"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">icarus::ParsingToolkit::findQuotationStart</a></div><div class="ttdeci">std::pair&lt; std::string_view, QuotSpec_t const * &gt; findQuotationStart(std::string_view sv) const </div><div class="ttdoc">Finds the start of the next quotation in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">ParsingToolkit.cxx:66</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ad9bfd5281c00ddad61b7354cce785001"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">icarus::ParsingToolkit::findQuotationEnd</a></div><div class="ttdeci">std::string_view findQuotationEnd(std::string_view sv, std::string const &amp;quotEnd) const </div><div class="ttdoc">Finds the quotation end in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00107">ParsingToolkit.cxx:107</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="RangeForWrapper__test_8cc_html_a2a47a7f29f0ddd7ff5d68f8aff63125c"><div class="ttname"><a href="../../d6/dd6/RangeForWrapper__test_8cc.html#a2a47a7f29f0ddd7ff5d68f8aff63125c">copy</a></div><div class="ttdeci">T copy(T const &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/dd6/RangeForWrapper__test_8cc_source.html#l00098">RangeForWrapper_test.cc:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0f91ef5eb96d77a2d0e764169bcbfdc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00485">485</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">removeWordQuotations</a>(std::string{ <a class="code" href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">w</a> }); }</div>
<div class="ttc" id="namespacegen__crt__frags_html_a8cdc67339147aad209b4122a38d7e246"><div class="ttname"><a href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">gen_crt_frags.w</a></div><div class="ttdeci">tuple w</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d8c/gen__crt__frags_8py_source.html#l01416">gen_crt_frags.py:1416</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a0dfa67494496674689d615d638369901"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">icarus::ParsingToolkit::removeWordQuotations</a></div><div class="ttdeci">std::string removeWordQuotations(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with no quotation starts and ends. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00176">ParsingToolkit.cxx:176</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab440b8ac5d12886c77e26cc7ffa88fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::removeWordQuotations </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00487">487</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">removeWordQuotations</a>(std::string{ <a class="code" href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">w</a> }); }</div>
<div class="ttc" id="namespacegen__crt__frags_html_a8cdc67339147aad209b4122a38d7e246"><div class="ttname"><a href="../../d8/ddf/namespacegen__crt__frags.html#a8cdc67339147aad209b4122a38d7e246">gen_crt_frags.w</a></div><div class="ttdeci">tuple w</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d8c/gen__crt__frags_8py_source.html#l01416">gen_crt_frags.py:1416</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a0dfa67494496674689d615d638369901"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0dfa67494496674689d615d638369901">icarus::ParsingToolkit::removeWordQuotations</a></div><div class="ttdeci">std::string removeWordQuotations(std::string &amp;&amp;w) const </div><div class="ttdoc">Returns a copy of w with no quotation starts and ends. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00176">ParsingToolkit.cxx:176</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a13ec3538d5983475ba3165ce4bae72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto icarus::ParsingToolkit::splitOn </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the view <code>sv</code> in three: before <code>sep</code>, <code>sep</code> and after <code>sep</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>view of the string to split </td></tr>
    <tr><td class="paramname">sep</td><td>a subview of <code>sv</code> to split at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="../../dc/d0d/structicarus_1_1ParsingToolkit_1_1SplitView__t.html" title="Record of a split token: pre-separator, separator and post-separator. ">SplitView_t</a></code> object with the three parts split, empty if needed</dd></dl>
<p>The view <code>sep</code> is required to be a subview of <code>sv</code>: it's not enough for it to have as content a substring of <code>sv</code>. For example, <code>splitOn("a:1", ":")</code> will not work, because the string <code>"a:1"</code> does not share data in memory with <code>":"</code>.</p>
<p>Even if <code>sep</code> is empty, it's still required to point with both <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">begin()</a></code> and <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">end()</a></code> within <code>sv</code>, and <code>sv</code> will be split according to that point. </p>

<p>Definition at line <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00149">149</a> of file <a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;{</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="keywordflow">return</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    { <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(sv.begin(), sep.begin()), sep, <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(sep.end(), sv.end()) };</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;} <span class="comment">// icarus::ParsingToolkit::splitOn()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a124f8a92d029e9c7142d5388d0b5fd97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Delim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string_view &gt; icarus::ParsingToolkit::splitWords </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Delim&#160;</td>
          <td class="paramname"><em>isDelimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into words. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Delim</td><td>type of delimiter functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to be split </td></tr>
    <tr><td class="paramname">isDelimiter</td><td>(default: <code>isblank()</code>) determines if a character is a word delimiter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of views, one per word</dd></dl>
<p>The splitter algorithm defines a word separator as a sequence of one or more unescaped, unquoted delimiter characters, where a delimiter is a character <code>ch</code> for which <code>isDelimiter(ch)</code> is <code>true</code>.</p>
<p>Note that this function does not change the content of the data, and in particular it does not remove escaping nor quoting (although it interprets both).</p>
<p>A character used as delimiter can appear in a word only if escaped or within quotation. Contiguous non-delimiter elements of a string, including quoted strings, belong to the same word (for example, <code>a" and "b</code> is a single word when delimitation is by blank characters). An empty word can be introduced only in quotations (e.g. <code>""</code>).</p>
<p>The <code>Delim</code> type is a functor so that <code>isDelimiter(ch)</code> returns something convertible to <code>bool</code>, <code>true</code> if the <code>ch</code> character should be considered a delimiter. Note that no context is provided for the answer, so the use of each character as delimiter is fixed, and modified only by the hard-coded quotation and escaping rules.</p>
<p>The first characters of quotation starts and the escape characters must not be classified as delimiters, or the algorithm will give wrong results. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00545">545</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;{</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="comment">// REQUIREMENT: escape character must not be classified as delimiter</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  assert(!isDelimiter(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">fParams</a>.<a class="code" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">escape</a>));</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  <span class="comment">// REQUIREMENT: the first character of no quotation start must be classified</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="comment">//              as delimiter</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  assert(</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    std::count_if(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.cbegin(), <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">fQuoteStarts</a>.cend(), isDelimiter) == 0</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    );</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  <span class="comment">// helper class:</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="comment">// stores the word as collected so far, updates `sv` and starts new words</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  <span class="keyword">class </span>WordTracker {</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0c0771b23b03681072f28a87950c04e5">ParsingToolkit</a> <span class="keyword">const</span>&amp; tk;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    Delim <span class="keyword">const</span>&amp; isDelimiter;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    std::string_view&amp; sv;</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    std::vector&lt;std::string_view&gt; words;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    std::string_view::const_iterator wStart;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;      <span class="keyword">public</span>:</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    WordTracker(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0c0771b23b03681072f28a87950c04e5">ParsingToolkit</a> <span class="keyword">const</span>&amp; tk, Delim <span class="keyword">const</span>&amp; d, std::string_view&amp; sv)</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;      : tk{ tk }, isDelimiter{ d }, sv{ consumeDelim(sv) }, wStart{ sv.begin() }</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;      {}</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    <span class="keywordtype">void</span> startNew()</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;      {</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        words.push_back(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(wStart, sv.begin()));</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        wStart = consumeDelim().begin();</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      }</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keywordtype">void</span> moveEndTo(std::string_view::const_iterator it)</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;      { moveEndBy(it - sv.begin()); }</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    <span class="keywordtype">void</span> moveEndBy(std::size_t <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">n</a>) { sv.remove_prefix(n); }</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    std::vector&lt;std::string_view&gt; finish()</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      { <span class="keywordflow">if</span> (wStart != sv.begin()) startNew(); <span class="keywordflow">return</span> std::move(words); }</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    std::string_view&amp; consumeDelim(std::string_view&amp; <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>)<span class="keyword"> const</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="keyword">      </span>{ <span class="keywordflow">return</span> s = tk.removeTrailingCharacters(s, isDelimiter); }</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    std::string_view&amp; consumeDelim() { <span class="keywordflow">return</span> consumeDelim(sv); }</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  }; <span class="comment">// WordTracker</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  </div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;  std::string_view sv = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>);</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  WordTracker words { *<span class="keyword">this</span>, isDelimiter, sv }; <span class="comment">// shares sv management</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  </div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  <span class="comment">// sv.begin() is kept updated to the candidate end of word;</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  <span class="comment">// the beginning of the current word is always cached as words.wStart</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  <span class="keywordflow">while</span> (!sv.empty()) {</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="comment">// process up to the next quotation</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> [ qsv, qptr ] = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">findQuotationStart</a>(sv);</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    </div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="comment">// parse and split until the quotation start:</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> qstart = qsv.begin();</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      </div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;      <span class="comment">// find next space;</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;      <span class="comment">// if next space is past the quotation, stop to the quotation instead</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      words.moveEndTo</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        (<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ade21ce7766e9762b631f5356a927e2fb">findNextCharacter</a>(<a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">make_view</a>(sv.begin(), qstart), isDelimiter));</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      </div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      <span class="keywordflow">if</span> (sv.begin() == qstart) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      </div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;      <span class="comment">// not the quote? it&#39;s a delimiter! new word found:</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;      words.startNew();</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;      </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    } <span class="comment">// while(true)</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    </div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="comment">// handle the quoted part</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <span class="keywordflow">if</span> (qptr) {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;      assert(sv.substr(0, qptr-&gt;first.length()) == qptr-&gt;first);</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;      </div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;      words.moveEndBy(qptr-&gt;first.length());</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;      </div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;      <span class="comment">// find the end of the quote, and swallow it into the current word</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;      std::string_view <span class="keyword">const</span> quotEnd = <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">findQuotationEnd</a>(sv, qptr-&gt;second);</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      words.moveEndTo(quotEnd.begin());</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;      </div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;      <span class="comment">// if we have found a end of quote, swallow it too (otherwise it&#39;s over)</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      <span class="keywordflow">if</span> (!quotEnd.empty()) words.moveEndBy(qptr-&gt;second.length());</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;      </div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    } <span class="comment">// if quotation found</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    </div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  </div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  <span class="keywordflow">return</span> words.finish();</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;} <span class="comment">// icarus::ParsingToolkit::splitWords()</span></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a62423130160f6b379f638ca942b78225"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a62423130160f6b379f638ca942b78225">icarus::ParsingToolkit::findQuotationStart</a></div><div class="ttdeci">std::pair&lt; std::string_view, QuotSpec_t const * &gt; findQuotationStart(std::string_view sv) const </div><div class="ttdoc">Finds the start of the next quotation in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00066">ParsingToolkit.cxx:66</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_1_1Params__t_html_aefba854f9d6536bcbe3b27193c0ed567"><div class="ttname"><a href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html#aefba854f9d6536bcbe3b27193c0ed567">icarus::ParsingToolkit::Params_t::escape</a></div><div class="ttdeci">char escape</div><div class="ttdoc">Escape character. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00069">ParsingToolkit.h:69</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a0c0771b23b03681072f28a87950c04e5"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a0c0771b23b03681072f28a87950c04e5">icarus::ParsingToolkit::ParsingToolkit</a></div><div class="ttdeci">ParsingToolkit()</div><div class="ttdoc">Default parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00100">ParsingToolkit.h:100</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2bceda651449f16763f91450d13f5d27"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2bceda651449f16763f91450d13f5d27">icarus::ParsingToolkit::fParams</a></div><div class="ttdeci">Params_t fParams</div><div class="ttdoc">Parsing parameters. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00519">ParsingToolkit.h:519</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a97456628bb7fa9fbe5dff5de4c2580db"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a97456628bb7fa9fbe5dff5de4c2580db">icarus::ParsingToolkit::make_view</a></div><div class="ttdeci">static std::string_view make_view(std::string const &amp;s)</div><div class="ttdoc">Creates a std::string_view from an entire string s. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00510">ParsingToolkit.h:510</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ade21ce7766e9762b631f5356a927e2fb"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ade21ce7766e9762b631f5356a927e2fb">icarus::ParsingToolkit::findNextCharacter</a></div><div class="ttdeci">std::string_view::const_iterator findNextCharacter(std::string_view s, Sel select) const </div><div class="ttdoc">Finds the next character satisfying the specified criterion. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00778">ParsingToolkit.h:778</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_ad9bfd5281c00ddad61b7354cce785001"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#ad9bfd5281c00ddad61b7354cce785001">icarus::ParsingToolkit::findQuotationEnd</a></div><div class="ttdeci">std::string_view findQuotationEnd(std::string_view sv, std::string const &amp;quotEnd) const </div><div class="ttdoc">Finds the quotation end in sv. </div><div class="ttdef"><b>Definition:</b> <a href="../../de/dc2/ParsingToolkit_8cxx_source.html#l00107">ParsingToolkit.cxx:107</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_acf582659e376b2550059557df8748f5e"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#acf582659e376b2550059557df8748f5e">icarus::ParsingToolkit::fQuoteStarts</a></div><div class="ttdeci">std::string fQuoteStarts</div><div class="ttdoc">Start characters of all supported quotations. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00524">ParsingToolkit.h:524</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_ab6cfbbcbb53c275375289d47dec67f46"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#ab6cfbbcbb53c275375289d47dec67f46">channelDBConverter.n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00249">channelDBConverter.py:249</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4c7e05ef3978769188f9d4ed5ca12995"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string_view&gt; icarus::ParsingToolkit::splitWords </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper version of <code>splitWords(std::string const&amp;, Delim)</code>. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00190">190</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a124f8a92d029e9c7142d5388d0b5fd97">splitWords</a>(<a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>, <a class="code" href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">isBlank</a>); }</div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a124f8a92d029e9c7142d5388d0b5fd97"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a124f8a92d029e9c7142d5388d0b5fd97">icarus::ParsingToolkit::splitWords</a></div><div class="ttdeci">std::vector&lt; std::string_view &gt; splitWords(std::string const &amp;s, Delim isDelimiter) const </div><div class="ttdoc">Splits a string into words. </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00545">ParsingToolkit.h:545</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="structicarus_1_1ParsingToolkit_html_a2100f4bcaeaf4a5cc6181d9c533e6f64"><div class="ttname"><a href="../../d3/d7b/structicarus_1_1ParsingToolkit.html#a2100f4bcaeaf4a5cc6181d9c533e6f64">icarus::ParsingToolkit::isBlank</a></div><div class="ttdeci">static constexpr CCTypeAdapter&lt;&amp;std::isblank &gt; isBlank</div><div class="ttdoc">Adapter for determining if a character is a blank (see std::isblank()). </div><div class="ttdef"><b>Definition:</b> <a href="../../da/d56/ParsingToolkit_8h_source.html#l00092">ParsingToolkit.h:92</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a523180de83def4934a514e53195233bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">icarus::ParsingToolkit::Params_t</a> const icarus::ParsingToolkit::DefaultParameters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00097">97</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2bceda651449f16763f91450d13f5d27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d61/structicarus_1_1ParsingToolkit_1_1Params__t.html">Params_t</a> icarus::ParsingToolkit::fParams</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parsing parameters. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00519">519</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf582659e376b2550059557df8748f5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icarus::ParsingToolkit::fQuoteStarts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start characters of all supported quotations. </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00524">524</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2100f4bcaeaf4a5cc6181d9c533e6f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d5f/structicarus_1_1ParsingToolkit_1_1CCTypeAdapter.html">CCTypeAdapter</a>&lt;&amp;std::isblank&gt; icarus::ParsingToolkit::isBlank {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapter for determining if a character is a blank (see <code>std::isblank()</code>). </p>

<p>Definition at line <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html#l00092">92</a> of file <a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="../../da/d56/ParsingToolkit_8h_source.html">ParsingToolkit.h</a></li>
<li><a class="el" href="../../de/dc2/ParsingToolkit_8cxx_source.html">ParsingToolkit.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
