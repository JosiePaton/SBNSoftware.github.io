<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Tag-related traits</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Tag-related traits<div class="ingroups"><a class="el" href="group__Metaprogramming.html">General utilities for metaprogramming</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Traits for types with a <code>tag</code>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TaggedType.html">util::TaggedType&lt; T, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type with a specified tag.  <a href="structutil_1_1TaggedType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1add__tag.html">util::add_tag&lt; T, Tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1remove__tag.html">util::remove_tag&lt; Tagged &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the type contained in a <code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code> (or the type itself).  <a href="structutil_1_1remove__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1remove__tag_3_01TaggedType_3_01T_00_01Tag_01_4_01_4.html">util::remove_tag&lt; TaggedType&lt; T, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TagN.html">util::TagN&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class parametrized by a sequence of numbers.  <a href="structutil_1_1TagN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TagExtractor.html">util::TagExtractor&lt; Tagged &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the tag from a type.  <a href="structutil_1_1TagExtractor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tag &gt; </td></tr>
<tr class="memitem:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t</a> = typename add_tag&lt; T, Tag &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="separator:gac2c6492e66c8201ee902f6890c4ef2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b135825beaff13bf4abacec82d618b5"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga5b135825beaff13bf4abacec82d618b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga5b135825beaff13bf4abacec82d618b5">util::remove_tag_t</a> = typename remove_tag&lt; Tagged &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="memdesc:ga5b135825beaff13bf4abacec82d618b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type contained in <code><a class="el" href="structutil_1_1remove__tag.html" title="Trait holding the type contained in a TaggedType (or the type itself). ">remove_tag</a></code>.  <a href="#ga5b135825beaff13bf4abacec82d618b5">More...</a><br/></td></tr>
<tr class="separator:ga5b135825beaff13bf4abacec82d618b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf2c3171daa4919784330b46b09e098"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:gacbf2c3171daa4919784330b46b09e098"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gacbf2c3171daa4919784330b46b09e098">util::tag_of</a> = TagExtractor&lt; Tagged &gt;</td></tr>
<tr class="memdesc:gacbf2c3171daa4919784330b46b09e098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the tag of <code>Tagged</code> as <code>type</code>.  <a href="#gacbf2c3171daa4919784330b46b09e098">More...</a><br/></td></tr>
<tr class="separator:gacbf2c3171daa4919784330b46b09e098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gaf44ec834b967f8d3635a635cacc6ec80">util::tag_of_t</a> = typename tag_of&lt; Tagged &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="memdesc:gaf44ec834b967f8d3635a635cacc6ec80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code>tag_of</code>.  <a href="#gaf44ec834b967f8d3635a635cacc6ec80">More...</a><br/></td></tr>
<tr class="separator:gaf44ec834b967f8d3635a635cacc6ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memTemplParams" colspan="2">template&lt;typename SrcTuple &gt; </td></tr>
<tr class="memitem:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga2c8dd8d85383c9a067a0ac3674f1c50e">util::extract_tags</a> = extract_to_tuple_type&lt; SrcTuple, TagExtractor &gt;</td></tr>
<tr class="memdesc:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tuple with all the tags from <code>SrcTuple</code>.  <a href="#ga2c8dd8d85383c9a067a0ac3674f1c50e">More...</a><br/></td></tr>
<tr class="separator:ga2c8dd8d85383c9a067a0ac3674f1c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memTemplParams" colspan="2">template&lt;typename SrcTuple &gt; </td></tr>
<tr class="memitem:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gabc0685c0b0eafbf7aedb59f3e9eef67c">util::extract_tags_t</a> = typename extract_tags&lt; SrcTuple &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="memdesc:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the type in <code>extract_tags</code>.  <a href="#gabc0685c0b0eafbf7aedb59f3e9eef67c">More...</a><br/></td></tr>
<tr class="separator:gabc0685c0b0eafbf7aedb59f3e9eef67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388">util::index_of_tag</a> = index_of_extracted_type&lt; TagExtractor, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the index of the element of <code>Tuple</code> with tag <code>Tag</code>.  <a href="#ga55d0e7499db19f01bb8a3d5346ff8388">More...</a><br/></td></tr>
<tr class="separator:ga55d0e7499db19f01bb8a3d5346ff8388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09c7641292f908026f622a4b887845c"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaf09c7641292f908026f622a4b887845c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">util::type_with_tag</a> = type_with_extracted_type&lt; TagExtractor, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:gaf09c7641292f908026f622a4b887845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait holding the type of the element of <code>Tuple</code> with tag <code>Tag</code>.  <a href="#gaf09c7641292f908026f622a4b887845c">More...</a><br/></td></tr>
<tr class="separator:gaf09c7641292f908026f622a4b887845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdf38097f72e12a2b25660704d84522"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaefdf38097f72e12a2b25660704d84522"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gaefdf38097f72e12a2b25660704d84522">util::type_with_tag_t</a> = typename type_with_tag&lt; Tag, Tuple &gt;::<a class="el" href="structtype.html">type</a></td></tr>
<tr class="memdesc:gaefdf38097f72e12a2b25660704d84522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>type_with_tag</code>.  <a href="#gaefdf38097f72e12a2b25660704d84522">More...</a><br/></td></tr>
<tr class="separator:gaefdf38097f72e12a2b25660704d84522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba4dd10684e5ec60541764d14db537f"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:gaeba4dd10684e5ec60541764d14db537f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f">util::has_tag</a> = has_extracted_type&lt; TagExtractor, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:gaeba4dd10684e5ec60541764d14db537f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait informing if there are elements in <code>Tuple</code> with tag <code>Tag</code>.  <a href="#gaeba4dd10684e5ec60541764d14db537f">More...</a><br/></td></tr>
<tr class="separator:gaeba4dd10684e5ec60541764d14db537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324">util::count_tags</a> = count_extracted_types&lt; TagExtractor, Tag, Tuple &gt;</td></tr>
<tr class="memdesc:ga8f12cb0558ab8f41cd640961b3e53324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait counting the elements in <code>Tuple</code> with tag <code>Tag</code>.  <a href="#ga8f12cb0558ab8f41cd640961b3e53324">More...</a><br/></td></tr>
<tr class="separator:ga8f12cb0558ab8f41cd640961b3e53324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585">util::has_duplicate_tags</a> = has_duplicate_extracted_types&lt; TagExtractor, Tuple &gt;</td></tr>
<tr class="memdesc:ga0cfc7db316e0d8085e278be1ddd56585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait reporting if multiple elements in <code>Tuple</code> have the same tag.  <a href="#ga0cfc7db316e0d8085e278be1ddd56585">More...</a><br/></td></tr>
<tr class="separator:ga0cfc7db316e0d8085e278be1ddd56585"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4417e45bc692ac9d1667479dcafb381e"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga4417e45bc692ac9d1667479dcafb381e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga4417e45bc692ac9d1667479dcafb381e">util::makeTagged</a> (T &amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga4417e45bc692ac9d1667479dcafb381e"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="#ga4417e45bc692ac9d1667479dcafb381e">More...</a><br/></td></tr>
<tr class="separator:ga4417e45bc692ac9d1667479dcafb381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d0849e186add2239834cf1c4b805c5"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga80d0849e186add2239834cf1c4b805c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga80d0849e186add2239834cf1c4b805c5">util::makeTagged</a> (T const &amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga80d0849e186add2239834cf1c4b805c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="#ga80d0849e186add2239834cf1c4b805c5">More...</a><br/></td></tr>
<tr class="separator:ga80d0849e186add2239834cf1c4b805c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga203ab7f1d6cac9d7c1a809268e66f1ef">util::makeTagged</a> (T const &amp;&amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="#ga203ab7f1d6cac9d7c1a809268e66f1ef">More...</a><br/></td></tr>
<tr class="separator:ga203ab7f1d6cac9d7c1a809268e66f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec1f0e583af63d593c99e689c842844"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename T &gt; </td></tr>
<tr class="memitem:ga2ec1f0e583af63d593c99e689c842844"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga2ec1f0e583af63d593c99e689c842844">util::makeTagged</a> (T &amp;&amp;obj) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga2ec1f0e583af63d593c99e689c842844"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" <code>obj</code> to an object with tag <code>Tag</code>.  <a href="#ga2ec1f0e583af63d593c99e689c842844">More...</a><br/></td></tr>
<tr class="separator:ga2ec1f0e583af63d593c99e689c842844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga3501a5dcc0a73dbe1eeb35962fc1072d">util::removeTag</a> (Tagged &amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="#ga3501a5dcc0a73dbe1eeb35962fc1072d">More...</a><br/></td></tr>
<tr class="separator:ga3501a5dcc0a73dbe1eeb35962fc1072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7301708ee42ce486d5d916e4608d4def"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga7301708ee42ce486d5d916e4608d4def"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga7301708ee42ce486d5d916e4608d4def">util::removeTag</a> (Tagged const &amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga7301708ee42ce486d5d916e4608d4def"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="#ga7301708ee42ce486d5d916e4608d4def">More...</a><br/></td></tr>
<tr class="separator:ga7301708ee42ce486d5d916e4608d4def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a174508a8b306a65841d3514fe7dd99"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga3a174508a8b306a65841d3514fe7dd99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga3a174508a8b306a65841d3514fe7dd99">util::removeTag</a> (Tagged const &amp;&amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga3a174508a8b306a65841d3514fe7dd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="#ga3a174508a8b306a65841d3514fe7dd99">More...</a><br/></td></tr>
<tr class="separator:ga3a174508a8b306a65841d3514fe7dd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memTemplParams" colspan="2">template&lt;typename Tagged &gt; </td></tr>
<tr class="memitem:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga1f3c35ec5f6dcb0948918080eec4f2df">util::removeTag</a> (Tagged &amp;&amp;tagged) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Converts" a tagged type back to its original type.  <a href="#ga1f3c35ec5f6dcb0948918080eec4f2df">More...</a><br/></td></tr>
<tr class="separator:ga1f3c35ec5f6dcb0948918080eec4f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5077b90fa8c5e783381625ddda42579c"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga5077b90fa8c5e783381625ddda42579c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga5077b90fa8c5e783381625ddda42579c">util::getByTag</a> (Tuple const &amp;data) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ga5077b90fa8c5e783381625ddda42579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object with the specified tag.  <a href="#ga5077b90fa8c5e783381625ddda42579c">More...</a><br/></td></tr>
<tr class="separator:ga5077b90fa8c5e783381625ddda42579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga162f35f1d3fd56f6b36c16df6f35befc">util::index_of_tag_v</a> = index_of_tag&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>index_of_tag</code>.  <a href="#ga162f35f1d3fd56f6b36c16df6f35befc">More...</a><br/></td></tr>
<tr class="separator:ga162f35f1d3fd56f6b36c16df6f35befc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa82c6620743044d07b345ac498a8a0"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga7fa82c6620743044d07b345ac498a8a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga7fa82c6620743044d07b345ac498a8a0">util::has_tag_v</a> = has_tag&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga7fa82c6620743044d07b345ac498a8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_tag</code>.  <a href="#ga7fa82c6620743044d07b345ac498a8a0">More...</a><br/></td></tr>
<tr class="separator:ga7fa82c6620743044d07b345ac498a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12189386f08f62432634a62d649e2ed8"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Tuple &gt; </td></tr>
<tr class="memitem:ga12189386f08f62432634a62d649e2ed8"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga12189386f08f62432634a62d649e2ed8">util::count_tags_v</a> = count_tags&lt;Tag, Tuple&gt;()</td></tr>
<tr class="memdesc:ga12189386f08f62432634a62d649e2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>count_tags</code>.  <a href="#ga12189386f08f62432634a62d649e2ed8">More...</a><br/></td></tr>
<tr class="separator:ga12189386f08f62432634a62d649e2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MetaprogrammingTagged.html#ga1b44306c24204dd46c99e1fe8a02ad89">util::has_duplicate_tags_v</a> = has_duplicate_tags&lt;Tuple&gt;()</td></tr>
<tr class="memdesc:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>has_duplicate_tags</code>.  <a href="#ga1b44306c24204dd46c99e1fe8a02ad89">More...</a><br/></td></tr>
<tr class="separator:ga1b44306c24204dd46c99e1fe8a02ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Traits for types with a <code>tag</code>. </p>
<p>Tag-related traits operate on "tagged" types. A tagged type is a type which contains a <code>tag</code> type definition, and that type is the tag type.</p>
<p>In the examples, the types used are defined as: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structutil_1_1TagN.html">TagA</a> {};</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structutil_1_1TagN.html">TagB</a> {};</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structutil_1_1TagN.html">TagC</a> {};</div>
<div class="line"><span class="keyword">struct </span>TagD {};</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> IntTaggedA     = <a class="code" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t&lt;std::vector&lt;int&gt;</a>,    <a class="code" href="structutil_1_1TagN.html">TagA</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> DoubleTaggedB  = <a class="code" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t&lt;std::vector&lt;double&gt;</a>, <a class="code" href="structutil_1_1TagN.html">TagB</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> StringTaggedC  = <a class="code" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t&lt;std::string,         TagC&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> ComplexTaggedA = <a class="code" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t&lt;std::complex&lt;float&gt;</a>, <a class="code" href="structutil_1_1TagN.html">TagA</a>&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> Tuple_t     = std::tuple&lt;IntTaggedA, DoubleTaggedB, StringTaggedC&gt;;</div>
<div class="line"><span class="keyword">using</span> DuplTuple_t = std::tuple&lt;IntTaggedA, DoubleTaggedB, ComplexTaggedA&gt;;</div>
</div><!-- fragment --><p> Note that <code>DuplTuple_t</code> has two elements with the same tag (<code>TagA</code>).</p>
<dl class="section note"><dt>Note</dt><dd>All the traits and function here will generate a compilation error if any of the elements is not tagged. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gac2c6492e66c8201ee902f6890c4ef2cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gac2c6492e66c8201ee902f6890c4ef2cf">util::add_tag_t</a> = typedef typename add_tag&lt;T, Tag&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct access to the type contained in <code><a class="el" href="structutil_1_1add__tag.html">add_tag</a></code>. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code> </dd></dl>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00617">617</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f12cb0558ab8f41cd640961b3e53324"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324">util::count_tags</a> = typedef count_extracted_types&lt;TagExtractor, Tag, Tuple&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait counting the elements in <code>Tuple</code> with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the sought tag </td></tr>
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the elements to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">index_of_tag</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga12189386f08f62432634a62d649e2ed8" title="Direct access to the value in count_tags. ">count_tags_v</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585" title="Trait reporting if multiple elements in Tuple have the same tag. ">has_duplicate_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f" title="Trait informing if there are elements in Tuple with tag Tag. ">has_tag</a></code></dd></dl>
<p>Given a tuple-like type <code>Tuple</code>, this traits returns the number of element types tagged with <code>Tag</code>.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagA     = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagA, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagB     = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagB, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagC     = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagC, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagD     = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagD, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagAdupl = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagA, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagBdupl = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagB, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagCdupl = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagC, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTagDdupl = <a class="code" href="structutil_1_1count__extracted__types.html">util::count_tags&lt;TagD, DuplTuple_t&gt;</a>();</div>
</div><!-- fragment --><p> <code>nTagA</code>, <code>nTagB</code> and <code>nTagC</code>, will be <code>1</code> and <code>nTagD</code> will be <code>0</code>. Likewise, <code>nTagAdupl</code> will be <code>1</code>, <code>nTagBdupl</code> will be <code>2</code>, while <code>nTagCdupl</code> and <code>nTagDdupl</code> will be <code>0</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00885">885</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c8dd8d85383c9a067a0ac3674f1c50e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#ga2c8dd8d85383c9a067a0ac3674f1c50e">util::extract_tags</a> = typedef extract_to_tuple_type&lt;SrcTuple, TagExtractor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a tuple with all the tags from <code>SrcTuple</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00744">744</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabc0685c0b0eafbf7aedb59f3e9eef67c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gabc0685c0b0eafbf7aedb59f3e9eef67c">util::extract_tags_t</a> = typedef typename extract_tags&lt;SrcTuple&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the type in <code>extract_tags</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00748">748</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cfc7db316e0d8085e278be1ddd56585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585">util::has_duplicate_tags</a> = typedef has_duplicate_extracted_types&lt;TagExtractor, Tuple&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait reporting if multiple elements in <code>Tuple</code> have the same tag. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the elements to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">index_of_tag</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324" title="Trait counting the elements in Tuple with tag Tag. ">count_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga1b44306c24204dd46c99e1fe8a02ad89" title="Direct access to the value in has_duplicate_tags. ">has_duplicate_tags_v</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f" title="Trait informing if there are elements in Tuple with tag Tag. ">has_tag</a></code></dd></dl>
<p>Given a tuple-like type <code>Tuple</code>, this traits returns whether any of the tags in the elements appears more than once.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> hasDuplTags     = <a class="code" href="structutil_1_1has__duplicate__extracted__types.html">util::has_duplicate_tags&lt;Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasDuplTagsDupl = <a class="code" href="structutil_1_1has__duplicate__extracted__types.html">util::has_duplicate_tags&lt;DuplTuple_t&gt;</a>();</div>
</div><!-- fragment --><p> <code>hasDuplTags</code>, will be <code>false</code> and <code>hasDuplTagsDupl</code> will be <code>true</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00908">908</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeba4dd10684e5ec60541764d14db537f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f">util::has_tag</a> = typedef has_extracted_type&lt;TagExtractor, Tag, Tuple&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait informing if there are elements in <code>Tuple</code> with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the sought tag </td></tr>
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the elements to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">index_of_tag</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324" title="Trait counting the elements in Tuple with tag Tag. ">count_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585" title="Trait reporting if multiple elements in Tuple have the same tag. ">has_duplicate_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga7fa82c6620743044d07b345ac498a8a0" title="Direct access to the value in has_tag. ">has_tag_v</a></code></dd></dl>
<p>Given a tuple-like type <code>Tuple</code>, this traits returns whether there is at least one element type tagged with <code>Tag</code>.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">bool</span> hasTagA     = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagA, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagB     = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagB, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagC     = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagC, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagD     = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagD, Tuple_t    &gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagAdupl = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagA, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagBdupl = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagB, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagCdupl = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagC, DuplTuple_t&gt;</a>();</div>
<div class="line">constexpr <span class="keywordtype">bool</span> hasTagDdupl = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagD, DuplTuple_t&gt;</a>();</div>
</div><!-- fragment --><p> <code>hasTagA</code>, <code>hasTagB</code> and <code>hasTagC</code>, will be <code>true</code> and <code>hasTagD</code> will be <code>false</code>. Likewise, <code>hasTagAdupl</code> and <code>hasTagBdupl</code> will be <code>true</code>, while <code>hasTagCdupl</code> and <code>hasTagDdupl</code> will be <code>false</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00853">853</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga55d0e7499db19f01bb8a3d5346ff8388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388">util::index_of_tag</a> = typedef index_of_extracted_type&lt;TagExtractor, Tag, Tuple&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait holding the index of the element of <code>Tuple</code> with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the sought tag </td></tr>
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the elements to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#ga162f35f1d3fd56f6b36c16df6f35befc" title="Direct access to the value in index_of_tag. ">index_of_tag_v</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324" title="Trait counting the elements in Tuple with tag Tag. ">count_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585" title="Trait reporting if multiple elements in Tuple have the same tag. ">has_duplicate_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f" title="Trait informing if there are elements in Tuple with tag Tag. ">has_tag</a></code></dd></dl>
<p>Given a tuple-like type <code>Tuple</code>, this traits returns the index of the one element type tagged with <code>Tag</code>. If the target type is not present, or if it is present more than once, a compilation error will ensue.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line">constexpr std::size_t TagAindex = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagA, Tuple_t&gt;</a>();</div>
<div class="line">constexpr std::size_t TagBindex = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagB, Tuple_t&gt;</a>();</div>
<div class="line">constexpr std::size_t TagBduplIndex</div>
<div class="line">  = <a class="code" href="structutil_1_1index__of__extracted__type.html">util::index_of_tag&lt;TagB, DuplTuple_t&gt;</a>();</div>
</div><!-- fragment --><p> <code>TagAindex</code> will hold value <code>0</code>, pointing to the container in <code>Tuple_t</code> of type <code>IntTaggedA</code>, while <code>TagBindex</code> will be <code>1</code> and <code>TagBduplIndex</code> will be also <code>1</code>. Instead, the expression <code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">util::index_of_tag</a>&lt;TagD, Tuple_t&gt;()</code> would not compile because no element in <code>Tuple_t</code> is tagged with <code>TagD</code>, and the expression <code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">util::index_of_tag</a>&lt;TagA, DuplTuple_t&gt;()</code> would not compile because two elements of <code>DuplTuple_t</code> are tagged <code>TagA</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently there is no equivalent trait to ask for the index of the second or following type, allowing for duplicate tags; this can be implemented on request. </dd></dl>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00782">782</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b135825beaff13bf4abacec82d618b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#ga5b135825beaff13bf4abacec82d618b5">util::remove_tag_t</a> = typedef typename remove_tag&lt;Tagged&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the type contained in <code><a class="el" href="structutil_1_1remove__tag.html" title="Trait holding the type contained in a TaggedType (or the type itself). ">remove_tag</a></code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00630">630</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacbf2c3171daa4919784330b46b09e098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gacbf2c3171daa4919784330b46b09e098">util::tag_of</a> = typedef TagExtractor&lt;Tagged&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait holding the tag of <code>Tagged</code> as <code>type</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00735">735</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf44ec834b967f8d3635a635cacc6ec80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gaf44ec834b967f8d3635a635cacc6ec80">util::tag_of_t</a> = typedef typename tag_of&lt;Tagged&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the type in <code>tag_of</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00739">739</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf09c7641292f908026f622a4b887845c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">util::type_with_tag</a> = typedef type_with_extracted_type&lt;TagExtractor, Tag, Tuple&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait holding the type of the element of <code>Tuple</code> with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the sought tag </td></tr>
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the elements to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#gaefdf38097f72e12a2b25660704d84522" title="Direct access to the value in type_with_tag. ">type_with_tag_t</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">index_of_tag</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324" title="Trait counting the elements in Tuple with tag Tag. ">count_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585" title="Trait reporting if multiple elements in Tuple have the same tag. ">has_duplicate_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f" title="Trait informing if there are elements in Tuple with tag Tag. ">has_tag</a></code></dd></dl>
<p>Given a tuple-like type <code>Tuple</code>, this traits returns the one element type tagged with <code>Tag</code>. If the target type is not present, or if it is present more than once, a compilation error will ensue.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> TagA_t = <span class="keyword">typename</span> <a class="code" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">util::type_with_tag&lt;TagA, Tuple_t&gt;::type</a>;</div>
<div class="line"><span class="keyword">using</span> TagB_t = <span class="keyword">typename</span> <a class="code" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">util::type_with_tag&lt;TagB, Tuple_t&gt;::type</a>;</div>
<div class="line"><span class="keyword">using</span> TagBdupl_t = <span class="keyword">typename</span> <a class="code" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c">util::type_with_tag&lt;TagB, DuplTuple_t&gt;::type</a>;</div>
</div><!-- fragment --><p> <code>TagA_t</code> will be <code>IntTaggedA</code>, the type in <code>Tuple_t</code> with <code>TagA</code>, while <code>TagB_t</code> will be <code>DoubleTaggedB</code> and <code>TagBdupl_t</code> will be also <code>DoubleTaggedB</code>. Instead, the type <code><a class="el" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c" title="Trait holding the type of the element of Tuple with tag Tag. ">util::type_with_tag</a>&lt;TagD, Tuple_t&gt;</code> would not compile because no element in <code>Tuple_t</code> is tagged with <code>TagD</code>, and the type <code><a class="el" href="group__MetaprogrammingTagged.html#gaf09c7641292f908026f622a4b887845c" title="Trait holding the type of the element of Tuple with tag Tag. ">util::type_with_tag</a>&lt;TagA, DuplTuple_t&gt;()</code> would not compile because two elements of <code>DuplTuple_t</code> are tagged <code>TagA</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently there is no equivalent trait to ask for the second or following type, allowing for duplicate tags; this can be implemented on request. </dd></dl>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00820">820</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaefdf38097f72e12a2b25660704d84522"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__MetaprogrammingTagged.html#gaefdf38097f72e12a2b25660704d84522">util::type_with_tag_t</a> = typedef typename type_with_tag&lt;Tag, Tuple&gt;::<a class="el" href="structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>type_with_tag</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00825">825</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5077b90fa8c5e783381625ddda42579c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::getByTag </td>
          <td>(</td>
          <td class="paramtype">Tuple const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the object with the specified tag. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the sought tag </td></tr>
    <tr><td class="paramname">Tuple</td><td>the tuple-like type holding the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="group__MetaprogrammingTagged.html#ga55d0e7499db19f01bb8a3d5346ff8388" title="Trait holding the index of the element of Tuple with tag Tag. ">index_of_tag</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga8f12cb0558ab8f41cd640961b3e53324" title="Trait counting the elements in Tuple with tag Tag. ">count_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#ga0cfc7db316e0d8085e278be1ddd56585" title="Trait reporting if multiple elements in Tuple have the same tag. ">has_duplicate_tags</a></code>, <code><a class="el" href="group__MetaprogrammingTagged.html#gaeba4dd10684e5ec60541764d14db537f" title="Trait informing if there are elements in Tuple with tag Tag. ">has_tag</a></code></dd></dl>
<p>This function operates in a fashion similar to <code>std::get()</code>, where instead of specifying the index or type of the object to retrieve, the tag is specified.</p>
<p>For example (see above for the definitions): </p>
<div class="fragment"><div class="line">Tuple_t data(</div>
<div class="line">  { 0, 1, 2 },   <span class="comment">// std::vector&lt;int&gt; assigned to TagA</span></div>
<div class="line">  { 0.5, 1.5 },  <span class="comment">// std::vector&lt;double&gt; assigned to TagB</span></div>
<div class="line">  <span class="stringliteral">&quot;middle point&quot;</span> <span class="comment">// std::string assigned to TagC</span></div>
<div class="line">  );</div>
<div class="line">decltype(<span class="keyword">auto</span>) TagBdata = util::<a class="code" href="group__MetaprogrammingTagged.html#ga5077b90fa8c5e783381625ddda42579c">getByTag</a>&lt;<a class="code" href="structutil_1_1TagN.html">TagB</a>&gt;(data);</div>
</div><!-- fragment --><p> <code>TagBdata</code> will be a reference to a <code>std::vector&lt;double&gt;</code> in <code>data</code>, currently with values <code>{ 0.5, 1.5 }". The attempt to use</code><a class="el" href="group__MetaprogrammingTagged.html#ga5077b90fa8c5e783381625ddda42579c" title="Returns the object with the specified tag. ">util::getByTag()</a><code>on an argument with duplicate tags (like</code>DuplTuple_t`) will ensue a compilation error. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00940">940</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    { <span class="keywordflow">return</span> getByExtractedType&lt;TagExtractor, Tag&gt;(data); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga4417e45bc692ac9d1667479dcafb381e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeTagged </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" <code>obj</code> to an object with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>tag to be added to the object </td></tr>
    <tr><td class="paramname">T</td><td>type of the object to be tagged (implicitly deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>(l-value) reference to the object to be tagged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>obj</code>, reinterpreted as tagged </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code>, <code><a class="el" href="structutil_1_1add__tag.html">add_tag</a></code></dd></dl>
<p>The returned object is the same as <code>obj</code>, reinterpreted as a different type derived from <code>T</code> and tagged with <code>Tag</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00645">645</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>add_tag_t&lt;T, Tag&gt;&amp;<span class="keyword">&gt;</span>(obj); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga80d0849e186add2239834cf1c4b805c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeTagged </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" <code>obj</code> to an object with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>tag to be added to the object </td></tr>
    <tr><td class="paramname">T</td><td>type of the object to be tagged (implicitly deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>(l-value) constant reference to the object to be tagged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>obj</code>, reinterpreted as tagged </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code>, <code><a class="el" href="structutil_1_1add__tag.html">add_tag</a></code></dd></dl>
<p>The returned object is the same as <code>obj</code>, reinterpreted as a different type derived from <code>T</code> and tagged with <code>Tag</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00660">660</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>add_tag_t&lt;T const, Tag&gt; <a class="code" href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">const</a>&amp;<span class="keyword">&gt;</span>(obj); }</div>
<div class="ttc" id="namespaceSortModuleTimes_html_a805854df4323f914a9a09f4e266b4794"><div class="ttname"><a href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">SortModuleTimes.const</a></div><div class="ttdeci">string const</div><div class="ttdef"><b>Definition:</b> <a href="SortModuleTimes_8py_source.html#l00871">SortModuleTimes.py:871</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga203ab7f1d6cac9d7c1a809268e66f1ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeTagged </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" <code>obj</code> to an object with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>tag to be added to the object </td></tr>
    <tr><td class="paramname">T</td><td>type of the object to be tagged (implicitly deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>(r-value) reference to the object to be tagged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>obj</code>, reinterpreted as tagged </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code>, <code><a class="el" href="structutil_1_1add__tag.html">add_tag</a></code></dd></dl>
<p>The returned object is an object of a new type, derived from <code>T</code> , with data copied from <code>obj</code>, and tagged with <code>Tag</code>. The argument object may be a temporary. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00676">676</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    { <span class="keywordflow">return</span> add_tag_t&lt;T, Tag&gt;(obj); <span class="comment">/* copy, since it&#39;s constant */</span> }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga2ec1f0e583af63d593c99e689c842844"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::makeTagged </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" <code>obj</code> to an object with tag <code>Tag</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>tag to be added to the object </td></tr>
    <tr><td class="paramname">T</td><td>type of the object to be tagged (implicitly deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to be tagged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>obj</code>, reinterpreted as tagged </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="structutil_1_1TaggedType.html" title="A type with a specified tag. ">TaggedType</a></code>, <code><a class="el" href="structutil_1_1add__tag.html">add_tag</a></code></dd></dl>
<p>The returned object is the same as <code>obj</code>, reinterpreted as a different type derived from <code>T</code> and tagged with <code>Tag</code>. The returned object is a temporary of the new type, whose content is moved (<code>std::move()</code>) from the argument object <code>obj</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00693">693</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    { <span class="keywordflow">return</span> add_tag_t&lt;T, Tag&gt;(std::move(obj)); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga3501a5dcc0a73dbe1eeb35962fc1072d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::removeTag </td>
          <td>(</td>
          <td class="paramtype">Tagged &amp;&#160;</td>
          <td class="paramname"><em>tagged</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" a tagged type back to its original type. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00698">698</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>remove_tag_t&lt;Tagged&gt;&amp;<span class="keyword">&gt;</span>(tagged); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga7301708ee42ce486d5d916e4608d4def"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::removeTag </td>
          <td>(</td>
          <td class="paramtype">Tagged const &amp;&#160;</td>
          <td class="paramname"><em>tagged</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" a tagged type back to its original type. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00703">703</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>remove_tag_t&lt;Tagged&gt; <a class="code" href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">const</a>&amp;<span class="keyword">&gt;</span>(tagged); }</div>
<div class="ttc" id="namespaceSortModuleTimes_html_a805854df4323f914a9a09f4e266b4794"><div class="ttname"><a href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">SortModuleTimes.const</a></div><div class="ttdeci">string const</div><div class="ttdef"><b>Definition:</b> <a href="SortModuleTimes_8py_source.html#l00871">SortModuleTimes.py:871</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga3a174508a8b306a65841d3514fe7dd99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::removeTag </td>
          <td>(</td>
          <td class="paramtype">Tagged const &amp;&amp;&#160;</td>
          <td class="paramname"><em>tagged</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" a tagged type back to its original type. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00708">708</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>remove_tag_t&lt;Tagged&gt; <a class="code" href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">const</a>&amp;&amp;<span class="keyword">&gt;</span>(tagged); }</div>
<div class="ttc" id="namespaceSortModuleTimes_html_a805854df4323f914a9a09f4e266b4794"><div class="ttname"><a href="namespaceSortModuleTimes.html#a805854df4323f914a9a09f4e266b4794">SortModuleTimes.const</a></div><div class="ttdeci">string const</div><div class="ttdef"><b>Definition:</b> <a href="SortModuleTimes_8py_source.html#l00871">SortModuleTimes.py:871</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga1f3c35ec5f6dcb0948918080eec4f2df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tagged &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto util::removeTag </td>
          <td>(</td>
          <td class="paramtype">Tagged &amp;&amp;&#160;</td>
          <td class="paramname"><em>tagged</em></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Converts" a tagged type back to its original type. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00713">713</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>remove_tag_t&lt;Tagged&gt;&amp;&amp;<span class="keyword">&gt;</span>(tagged); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga12189386f08f62432634a62d649e2ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int util::count_tags_v = count_tags&lt;Tag, Tuple&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>count_tags</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00889">889</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b44306c24204dd46c99e1fe8a02ad89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::has_duplicate_tags_v = has_duplicate_tags&lt;Tuple&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>has_duplicate_tags</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00912">912</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7fa82c6620743044d07b345ac498a8a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::has_tag_v = has_tag&lt;Tag, Tuple&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>has_tag</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00857">857</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga162f35f1d3fd56f6b36c16df6f35befc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t util::index_of_tag_v = index_of_tag&lt;Tag, Tuple&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>index_of_tag</code>. </p>

<p>Definition at line <a class="el" href="TupleLookupByTag_8h_source.html#l00787">787</a> of file <a class="el" href="TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
