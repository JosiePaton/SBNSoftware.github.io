<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>lar::sparse_vector&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d7/d0b/namespacelar.html">lar</a></li><li class="navelem"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d1/dd3/classlar_1_1sparse__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lar::sparse_vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A sparse vector.  
 <a href="../../d4/da5/classlar_1_1sparse__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d91/classlar_1_1sparse__vector_1_1const__datarange__t.html">const_datarange_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant reference to a data range.  <a href="../../dc/d91/classlar_1_1sparse__vector_1_1const__datarange__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the sparse vector values.  <a href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/classlar_1_1sparse__vector_1_1const__reference.html">const_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special little box to allow void elements to be treated as references.  <a href="../../da/d7e/classlar_1_1sparse__vector_1_1const__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range class, with range and data.  <a href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the sparse vector values.  <a href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6c/classlar_1_1sparse__vector_1_1reference.html">reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a cell in a sparse vector.  <a href="../../dd/d6c/classlar_1_1sparse__vector_1_1reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84ae9b33ffba8b4b2d6e2f840ef12611"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a></td></tr>
<tr class="memdesc:a84ae9b33ffba8b4b2d6e2f840ef12611"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the stored values  <a href="#a84ae9b33ffba8b4b2d6e2f840ef12611">More...</a><br/></td></tr>
<tr class="separator:a84ae9b33ffba8b4b2d6e2f840ef12611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fd3f170a77316f9410e181da02beab"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a></td></tr>
<tr class="memdesc:a03fd3f170a77316f9410e181da02beab"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of STL vector holding this data  <a href="#a03fd3f170a77316f9410e181da02beab">More...</a><br/></td></tr>
<tr class="separator:a03fd3f170a77316f9410e181da02beab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5f860ccf8633e81d310ae4b31f7193"><td class="memItemLeft" align="right" valign="top">typedef vector_t::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a></td></tr>
<tr class="memdesc:aff5f860ccf8633e81d310ae4b31f7193"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <a href="#aff5f860ccf8633e81d310ae4b31f7193">More...</a><br/></td></tr>
<tr class="separator:aff5f860ccf8633e81d310ae4b31f7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535ed142129efbfa4cae9b5b84c5964"><td class="memItemLeft" align="right" valign="top">typedef vector_t::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0535ed142129efbfa4cae9b5b84c5964">difference_type</a></td></tr>
<tr class="memdesc:a0535ed142129efbfa4cae9b5b84c5964"><td class="mdescLeft">&#160;</td><td class="mdescRight">index difference type  <a href="#a0535ed142129efbfa4cae9b5b84c5964">More...</a><br/></td></tr>
<tr class="separator:a0535ed142129efbfa4cae9b5b84c5964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf30371f7d6c623d9a110bb117b3380"><td class="memItemLeft" align="right" valign="top">typedef vector_t::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5cf30371f7d6c623d9a110bb117b3380">pointer</a></td></tr>
<tr class="separator:a5cf30371f7d6c623d9a110bb117b3380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a70f919de9964cacdf6ed6c75ea691"><td class="memItemLeft" align="right" valign="top">typedef vector_t::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a52a70f919de9964cacdf6ed6c75ea691">const_pointer</a></td></tr>
<tr class="separator:a52a70f919de9964cacdf6ed6c75ea691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59b371c390784a0f7206929e4c13cd"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a></td></tr>
<tr class="memdesc:a8a59b371c390784a0f7206929e4c13cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of sparse vector data  <a href="#a8a59b371c390784a0f7206929e4c13cd">More...</a><br/></td></tr>
<tr class="separator:a8a59b371c390784a0f7206929e4c13cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfebe294b81a209189dd13bc11b2aeb"><td class="memItemLeft" align="right" valign="top">typedef range_list_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a></td></tr>
<tr class="memdesc:aedfebe294b81a209189dd13bc11b2aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of iterator over ranges  <a href="#aedfebe294b81a209189dd13bc11b2aeb">More...</a><br/></td></tr>
<tr class="separator:aedfebe294b81a209189dd13bc11b2aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a00801a937328f1596028f4d922d9f7"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
range_list_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a></td></tr>
<tr class="memdesc:a7a00801a937328f1596028f4d922d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of constant iterator over ranges  <a href="#a7a00801a937328f1596028f4d922d9f7">More...</a><br/></td></tr>
<tr class="separator:a7a00801a937328f1596028f4d922d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af085ea35839fd1336675231c4b521b4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#af085ea35839fd1336675231c4b521b4b">sparse_vector</a> ()</td></tr>
<tr class="memdesc:af085ea35839fd1336675231c4b521b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: an empty vector.  <a href="#af085ea35839fd1336675231c4b521b4b">More...</a><br/></td></tr>
<tr class="separator:af085ea35839fd1336675231c4b521b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc410a56ceb2199dac1eb2c75150d3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a1bc410a56ceb2199dac1eb2c75150d3d">sparse_vector</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> new_size)</td></tr>
<tr class="memdesc:a1bc410a56ceb2199dac1eb2c75150d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: a vector with new_size elements in the void.  <a href="#a1bc410a56ceb2199dac1eb2c75150d3d">More...</a><br/></td></tr>
<tr class="separator:a1bc410a56ceb2199dac1eb2c75150d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2486775f72d568f95f476df1adb5fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0c2486775f72d568f95f476df1adb5fd">sparse_vector</a> (const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;<a class="el" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>=0)</td></tr>
<tr class="memdesc:a0c2486775f72d568f95f476df1adb5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: a solid vector from an existing STL vector.  <a href="#a0c2486775f72d568f95f476df1adb5fd">More...</a><br/></td></tr>
<tr class="separator:a0c2486775f72d568f95f476df1adb5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ab363cc2b2fd15b2960f6b0598edd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ae4ab363cc2b2fd15b2960f6b0598edd9">sparse_vector</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> const &amp;)=<a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#a6c2384a9e3f7a8c21ae6f762a8ee0ece">default</a></td></tr>
<tr class="memdesc:ae4ab363cc2b2fd15b2960f6b0598edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: default.  <a href="#ae4ab363cc2b2fd15b2960f6b0598edd9">More...</a><br/></td></tr>
<tr class="separator:ae4ab363cc2b2fd15b2960f6b0598edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b3c021a57c94ca0c1316dbaa3baef4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a77b3c021a57c94ca0c1316dbaa3baef4">sparse_vector</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> &amp;&amp;<a class="el" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>)</td></tr>
<tr class="memdesc:a77b3c021a57c94ca0c1316dbaa3baef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a77b3c021a57c94ca0c1316dbaa3baef4">More...</a><br/></td></tr>
<tr class="separator:a77b3c021a57c94ca0c1316dbaa3baef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ec6a9e12a2b2c8c2c859132eea535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a385ec6a9e12a2b2c8c2c859132eea535">operator=</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> const &amp;)=<a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#a6c2384a9e3f7a8c21ae6f762a8ee0ece">default</a></td></tr>
<tr class="memdesc:a385ec6a9e12a2b2c8c2c859132eea535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment: default.  <a href="#a385ec6a9e12a2b2c8c2c859132eea535">More...</a><br/></td></tr>
<tr class="separator:a385ec6a9e12a2b2c8c2c859132eea535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fe549730055975c32ebfd1ba150874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a42fe549730055975c32ebfd1ba150874">operator=</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> &amp;&amp;<a class="el" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>)</td></tr>
<tr class="memdesc:a42fe549730055975c32ebfd1ba150874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a42fe549730055975c32ebfd1ba150874">More...</a><br/></td></tr>
<tr class="separator:a42fe549730055975c32ebfd1ba150874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08cb28eedbc3083e07c96760e037fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aad08cb28eedbc3083e07c96760e037fb">sparse_vector</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;<a class="el" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>=0)</td></tr>
<tr class="memdesc:aad08cb28eedbc3083e07c96760e037fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: a solid vector from an existing STL vector.  <a href="#aad08cb28eedbc3083e07c96760e037fb">More...</a><br/></td></tr>
<tr class="separator:aad08cb28eedbc3083e07c96760e037fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbc2ed64ea172ed4539d32d1c022c07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8bbc2ed64ea172ed4539d32d1c022c07">~sparse_vector</a> ()=<a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#a6c2384a9e3f7a8c21ae6f762a8ee0ece">default</a></td></tr>
<tr class="memdesc:a8bbc2ed64ea172ed4539d32d1c022c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: default.  <a href="#a8bbc2ed64ea172ed4539d32d1c022c07">More...</a><br/></td></tr>
<tr class="separator:a8bbc2ed64ea172ed4539d32d1c022c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18a4f929acc8739151b3d928770b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">clear</a> ()</td></tr>
<tr class="memdesc:a0c18a4f929acc8739151b3d928770b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the data, making the vector empty.  <a href="#a0c18a4f929acc8739151b3d928770b0f">More...</a><br/></td></tr>
<tr class="separator:a0c18a4f929acc8739151b3d928770b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239eda30fd10129f2213f09549ee09a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a> () const </td></tr>
<tr class="memdesc:ae239eda30fd10129f2213f09549ee09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the vector.  <a href="#ae239eda30fd10129f2213f09549ee09a">More...</a><br/></td></tr>
<tr class="separator:ae239eda30fd10129f2213f09549ee09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6837d5208aa96a1ac80cc60268f2bf3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a6837d5208aa96a1ac80cc60268f2bf3f">empty</a> () const </td></tr>
<tr class="memdesc:a6837d5208aa96a1ac80cc60268f2bf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is empty.  <a href="#a6837d5208aa96a1ac80cc60268f2bf3f">More...</a><br/></td></tr>
<tr class="separator:a6837d5208aa96a1ac80cc60268f2bf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801fb9ad4d3b9500e05e51496de85c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a801fb9ad4d3b9500e05e51496de85c25">capacity</a> () const </td></tr>
<tr class="memdesc:a801fb9ad4d3b9500e05e51496de85c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the vector (compatibility only)  <a href="#a801fb9ad4d3b9500e05e51496de85c25">More...</a><br/></td></tr>
<tr class="separator:a801fb9ad4d3b9500e05e51496de85c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee5f0b30c8bc1959db71dfbf2ffd88a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a9ee5f0b30c8bc1959db71dfbf2ffd88a">operator[]</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="memdesc:a9ee5f0b30c8bc1959db71dfbf2ffd88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element (read only)  <a href="#a9ee5f0b30c8bc1959db71dfbf2ffd88a">More...</a><br/></td></tr>
<tr class="separator:a9ee5f0b30c8bc1959db71dfbf2ffd88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c0c294f1a934273820510bbdf2029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d6c/classlar_1_1sparse__vector_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a524c0c294f1a934273820510bbdf2029">operator[]</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:a524c0c294f1a934273820510bbdf2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element (read/write for non-void elements only!)  <a href="#a524c0c294f1a934273820510bbdf2029">More...</a><br/></td></tr>
<tr class="separator:a524c0c294f1a934273820510bbdf2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62814415f5b038505112cdfa1d017103"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a62814415f5b038505112cdfa1d017103">range_const_data</a> (std::size_t i) const </td></tr>
<tr class="memdesc:a62814415f5b038505112cdfa1d017103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613" title="Provides direct access to data of i-th non-void range (zero-based) ">range_data()</a></code> but with explicitly read-only access to data.  <a href="#a62814415f5b038505112cdfa1d017103">More...</a><br/></td></tr>
<tr class="separator:a62814415f5b038505112cdfa1d017103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e40940b2813c0f49edb7286c030c002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a2e40940b2813c0f49edb7286c030c002">begin_range</a> () const </td></tr>
<tr class="memdesc:a2e40940b2813c0f49edb7286c030c002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first data range.  <a href="#a2e40940b2813c0f49edb7286c030c002">More...</a><br/></td></tr>
<tr class="separator:a2e40940b2813c0f49edb7286c030c002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cccbfc3bc88c09ebab772d7be68506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">end_range</a> () const </td></tr>
<tr class="memdesc:ad8cccbfc3bc88c09ebab772d7be68506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to after the last data range.  <a href="#ad8cccbfc3bc88c09ebab772d7be68506">More...</a><br/></td></tr>
<tr class="separator:ad8cccbfc3bc88c09ebab772d7be68506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d07dbbbe294ddfde8436813215e9a90"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0d07dbbbe294ddfde8436813215e9a90">find_range_number</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="memdesc:a0d07dbbbe294ddfde8436813215e9a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number (0-based) of range containing <code>index</code>.  <a href="#a0d07dbbbe294ddfde8436813215e9a90">More...</a><br/></td></tr>
<tr class="separator:a0d07dbbbe294ddfde8436813215e9a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0bf47147e0ec187adf7302867b53c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0d0bf47147e0ec187adf7302867b53c2">make_void_around</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:a0d0bf47147e0ec187adf7302867b53c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the whole range with the specified item into the void.  <a href="#a0d0bf47147e0ec187adf7302867b53c2">More...</a><br/></td></tr>
<tr class="separator:a0d0bf47147e0ec187adf7302867b53c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc1825604220d6da755cbf3d0becfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a78cc1825604220d6da755cbf3d0becfb">is_valid</a> () const </td></tr>
<tr class="memdesc:a78cc1825604220d6da755cbf3d0becfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the vector is in a valid state.  <a href="#a78cc1825604220d6da755cbf3d0becfb">More...</a><br/></td></tr>
<tr class="separator:a78cc1825604220d6da755cbf3d0becfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0e1051d54a9c7659d56286ade361d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a4d0e1051d54a9c7659d56286ade361d3">make_void</a> (<a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a> first, <a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:a4d0e1051d54a9c7659d56286ade361d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all the elements from first and before last void.  <a href="#a4d0e1051d54a9c7659d56286ade361d3">More...</a><br/></td></tr>
<tr class="separator:a4d0e1051d54a9c7659d56286ade361d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a2673bf7114398570ba1b2633b1820"><td class="memTemplParams" colspan="2">template&lt;typename ITER &gt; </td></tr>
<tr class="memitem:a11a2673bf7114398570ba1b2633b1820"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;<br class="typebreak"/>
::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a11a2673bf7114398570ba1b2633b1820">add_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, ITER first, ITER last)</td></tr>
<tr class="separator:a11a2673bf7114398570ba1b2633b1820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c7072a900a5b4c490e437e69e81715"><td class="memTemplParams" colspan="2">template&lt;typename ITER , typename OP &gt; </td></tr>
<tr class="memitem:a97c7072a900a5b4c490e437e69e81715"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a97c7072a900a5b4c490e437e69e81715">combine_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, ITER first, ITER last, OP &amp;&amp;op, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> void_value) -&gt; const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;</td></tr>
<tr class="separator:a97c7072a900a5b4c490e437e69e81715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af9f87b865ed66c0ae0be183046e47ed9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">resize</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> new_size)</td></tr>
<tr class="memdesc:af9f87b865ed66c0ae0be183046e47ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the vector to the specified size, adding void.  <a href="#af9f87b865ed66c0ae0be183046e47ed9">More...</a><br/></td></tr>
<tr class="separator:af9f87b865ed66c0ae0be183046e47ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad997fce3154d9115993a1301b3b9e4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad997fce3154d9115993a1301b3b9e4e7">resize</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> new_size, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> def_value)</td></tr>
<tr class="memdesc:ad997fce3154d9115993a1301b3b9e4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the vector to the specified size, adding def_value.  <a href="#ad997fce3154d9115993a1301b3b9e4e7">More...</a><br/></td></tr>
<tr class="separator:ad997fce3154d9115993a1301b3b9e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a27f4c126aac24d29524784f74dba7f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a27f4c126aac24d29524784f74dba7f47">begin</a> ()</td></tr>
<tr class="memdesc:a27f4c126aac24d29524784f74dba7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard iterators interface.  <a href="#a27f4c126aac24d29524784f74dba7f47">More...</a><br/></td></tr>
<tr class="separator:a27f4c126aac24d29524784f74dba7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d6acf5893c79c00f6b7af9eff87a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end</a> ()</td></tr>
<tr class="separator:a605d6acf5893c79c00f6b7af9eff87a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677571b2eb742b938bb17f71fc217df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a677571b2eb742b938bb17f71fc217df8">begin</a> () const </td></tr>
<tr class="separator:a677571b2eb742b938bb17f71fc217df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e628d52be31cf9c1bc2fb6891e0c107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7e628d52be31cf9c1bc2fb6891e0c107">end</a> () const </td></tr>
<tr class="separator:a7e628d52be31cf9c1bc2fb6891e0c107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4c898884f83e6b37e9b538b9d3f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a91e4c898884f83e6b37e9b538b9d3f01">cbegin</a> () const </td></tr>
<tr class="separator:a91e4c898884f83e6b37e9b538b9d3f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65678bce1ff99f1312d548fcf87edb43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a65678bce1ff99f1312d548fcf87edb43">cend</a> () const </td></tr>
<tr class="separator:a65678bce1ff99f1312d548fcf87edb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell test</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The methods in this group test the single vector cells. </p>
</div></td></tr>
<tr class="memitem:a5f29124d201a74963689f854d9d116e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5f29124d201a74963689f854d9d116e3">is_void</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="memdesc:a5f29124d201a74963689f854d9d116e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the specified position is void.  <a href="#a5f29124d201a74963689f854d9d116e3">More...</a><br/></td></tr>
<tr class="separator:a5f29124d201a74963689f854d9d116e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea706e34c1aaea8a9739419f2f4301c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aeea706e34c1aaea8a9739419f2f4301c">back_is_void</a> () const </td></tr>
<tr class="memdesc:aeea706e34c1aaea8a9739419f2f4301c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the sparse vector ends with void.  <a href="#aeea706e34c1aaea8a9739419f2f4301c">More...</a><br/></td></tr>
<tr class="separator:aeea706e34c1aaea8a9739419f2f4301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525fc33cbd78dd8109f39d66556e36db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a525fc33cbd78dd8109f39d66556e36db">count</a> () const </td></tr>
<tr class="memdesc:a525fc33cbd78dd8109f39d66556e36db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-void cells.  <a href="#a525fc33cbd78dd8109f39d66556e36db">More...</a><br/></td></tr>
<tr class="separator:a525fc33cbd78dd8109f39d66556e36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell set</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The methods in this group access and/or change the cell values. </p>
</div></td></tr>
<tr class="memitem:ad85e95c62868cd7027d94526bf77037d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad85e95c62868cd7027d94526bf77037d">set_at</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>)</td></tr>
<tr class="memdesc:ad85e95c62868cd7027d94526bf77037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes into an element (creating or expanding a range if needed)  <a href="#ad85e95c62868cd7027d94526bf77037d">More...</a><br/></td></tr>
<tr class="separator:ad85e95c62868cd7027d94526bf77037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45f761fde6de417b32d640fa84bc5a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac45f761fde6de417b32d640fa84bc5a7">unset_at</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:ac45f761fde6de417b32d640fa84bc5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the element with the specified index into the void.  <a href="#ac45f761fde6de417b32d640fa84bc5a7">More...</a><br/></td></tr>
<tr class="separator:ac45f761fde6de417b32d640fa84bc5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8cd9f5aef77190e0069e5a3547ffb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#afc8cd9f5aef77190e0069e5a3547ffb4">push_back</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>)</td></tr>
<tr class="separator:afc8cd9f5aef77190e0069e5a3547ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5317d49a11f65ec697fe5a14f1a40c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad5317d49a11f65ec697fe5a14f1a40c0">push_back</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> thr)</td></tr>
<tr class="memdesc:ad5317d49a11f65ec697fe5a14f1a40c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one element to the end of the vector (if zero, just adds void)  <a href="#ad5317d49a11f65ec697fe5a14f1a40c0">More...</a><br/></td></tr>
<tr class="separator:ad5317d49a11f65ec697fe5a14f1a40c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a044ea2dc6b1f1eabbdf74b6a8390aa24"><td class="memTemplParams" colspan="2">template&lt;typename ITER &gt; </td></tr>
<tr class="memitem:a044ea2dc6b1f1eabbdf74b6a8390aa24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a044ea2dc6b1f1eabbdf74b6a8390aa24">assign</a> (ITER first, ITER last)</td></tr>
<tr class="memdesc:a044ea2dc6b1f1eabbdf74b6a8390aa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a sequence between two iterators.  <a href="#a044ea2dc6b1f1eabbdf74b6a8390aa24">More...</a><br/></td></tr>
<tr class="separator:a044ea2dc6b1f1eabbdf74b6a8390aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0131e1d331e41642eca629fdbb4a5de8"><td class="memTemplParams" colspan="2">template&lt;typename CONT &gt; </td></tr>
<tr class="memitem:a0131e1d331e41642eca629fdbb4a5de8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0131e1d331e41642eca629fdbb4a5de8">assign</a> (const CONT &amp;new_data)</td></tr>
<tr class="memdesc:a0131e1d331e41642eca629fdbb4a5de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a container.  <a href="#a0131e1d331e41642eca629fdbb4a5de8">More...</a><br/></td></tr>
<tr class="separator:a0131e1d331e41642eca629fdbb4a5de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d110713f2bd9a724dc1524936a19f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac5d110713f2bd9a724dc1524936a19f2">assign</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;new_data)</td></tr>
<tr class="memdesc:ac5d110713f2bd9a724dc1524936a19f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves data from a vector.  <a href="#ac5d110713f2bd9a724dc1524936a19f2">More...</a><br/></td></tr>
<tr class="separator:ac5d110713f2bd9a724dc1524936a19f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Ranges</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A range is a contiguous region of the sparse vector which contains all non-void values.</p>
<p>A sparse vector is effectively a sorted collection of ranges. This interface allows:</p>
<ul>
<li>iteration through all ranges (read only)</li>
<li>random access to a range by index (read only)</li>
<li>access to the data of a selected range (read/write)</li>
<li>look-up of the range containing a specified index (read/write; use write with care!)</li>
<li>addition (and more generically, combination with existing data) of a new range</li>
<li>extension of the sparse vector by appending a range at the end of it</li>
<li>remove the data of a range, making it void </li>
</ul>
</div></td></tr>
<tr class="memitem:a8d9b2860eee2156fe59ba0ce4f0f1393"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d9b2860eee2156fe59ba0ce4f0f1393">get_ranges</a> () const </td></tr>
<tr class="memdesc:a8d9b2860eee2156fe59ba0ce4f0f1393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal list of non-void ranges.  <a href="#a8d9b2860eee2156fe59ba0ce4f0f1393">More...</a><br/></td></tr>
<tr class="separator:a8d9b2860eee2156fe59ba0ce4f0f1393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d9bb1988e77f27a272f524efab07c4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a67d9bb1988e77f27a272f524efab07c4">iterate_ranges</a> () -&gt; decltype(auto)</td></tr>
<tr class="separator:a67d9bb1988e77f27a272f524efab07c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fec1c084eb6c81222b4048bdf98bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a08fec1c084eb6c81222b4048bdf98bf1">n_ranges</a> () const </td></tr>
<tr class="memdesc:a08fec1c084eb6c81222b4048bdf98bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal list of non-void ranges.  <a href="#a08fec1c084eb6c81222b4048bdf98bf1">More...</a><br/></td></tr>
<tr class="separator:a08fec1c084eb6c81222b4048bdf98bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6650210148fb6cd88b9d47742a44f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a> (size_t i) const </td></tr>
<tr class="memdesc:a8d6650210148fb6cd88b9d47742a44f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i-th non-void range (zero-based)  <a href="#a8d6650210148fb6cd88b9d47742a44f5">More...</a><br/></td></tr>
<tr class="separator:a8d6650210148fb6cd88b9d47742a44f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac9efcea1f9b799b9b5be46d5dc613"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">range_data</a> (std::size_t i)</td></tr>
<tr class="memdesc:acdac9efcea1f9b799b9b5be46d5dc613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to data of i-th non-void range (zero-based)  <a href="#acdac9efcea1f9b799b9b5be46d5dc613">More...</a><br/></td></tr>
<tr class="separator:acdac9efcea1f9b799b9b5be46d5dc613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af536700887cf5ecdaf53cbfef2163f6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#af536700887cf5ecdaf53cbfef2163f6c">range_data</a> (std::size_t const i) const </td></tr>
<tr class="separator:af536700887cf5ecdaf53cbfef2163f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:add3367c173b5233dc97417099a391c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#add3367c173b5233dc97417099a391c38">find_range_iterator</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="memdesc:add3367c173b5233dc97417099a391c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range containing the specified index.  <a href="#add3367c173b5233dc97417099a391c38">More...</a><br/></td></tr>
<tr class="separator:add3367c173b5233dc97417099a391c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaba539e85668bb66aadd4d0f92f8028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aeaba539e85668bb66aadd4d0f92f8028">find_range_iterator</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="separator:aeaba539e85668bb66aadd4d0f92f8028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5bf3ebf7528d621d0bc82c3fd1c7e145"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5bf3ebf7528d621d0bc82c3fd1c7e145">find_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="memdesc:a5bf3ebf7528d621d0bc82c3fd1c7e145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range containing the specified index.  <a href="#a5bf3ebf7528d621d0bc82c3fd1c7e145">More...</a><br/></td></tr>
<tr class="separator:a5bf3ebf7528d621d0bc82c3fd1c7e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303ac8450a67a2d6c647923f9ec16985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a303ac8450a67a2d6c647923f9ec16985">find_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="separator:a303ac8450a67a2d6c647923f9ec16985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a234e1a7d10a4225b66209e2d14365f27"><td class="memTemplParams" colspan="2">template&lt;typename ITER &gt; </td></tr>
<tr class="memitem:a234e1a7d10a4225b66209e2d14365f27"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, ITER first, ITER last)</td></tr>
<tr class="memdesc:a234e1a7d10a4225b66209e2d14365f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sequence of elements as a range with specified offset.  <a href="#a234e1a7d10a4225b66209e2d14365f27">More...</a><br/></td></tr>
<tr class="separator:a234e1a7d10a4225b66209e2d14365f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f37f42174528faa44840a5940e365c"><td class="memTemplParams" colspan="2">template&lt;typename CONT &gt; </td></tr>
<tr class="memitem:a05f37f42174528faa44840a5940e365c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a05f37f42174528faa44840a5940e365c">add_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, const CONT &amp;new_data)</td></tr>
<tr class="memdesc:a05f37f42174528faa44840a5940e365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in container to a range with specified offset.  <a href="#a05f37f42174528faa44840a5940e365c">More...</a><br/></td></tr>
<tr class="separator:a05f37f42174528faa44840a5940e365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5591e6670dc1a08dc31d1f779526037"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad5591e6670dc1a08dc31d1f779526037">add_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;new_data)</td></tr>
<tr class="memdesc:ad5591e6670dc1a08dc31d1f779526037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sequence of elements as a range with specified offset.  <a href="#ad5591e6670dc1a08dc31d1f779526037">More...</a><br/></td></tr>
<tr class="separator:ad5591e6670dc1a08dc31d1f779526037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab5a4f71023193c43098ac1fd65ead7a4"><td class="memTemplParams" colspan="2">template&lt;typename ITER , typename OP &gt; </td></tr>
<tr class="memitem:ab5a4f71023193c43098ac1fd65ead7a4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ab5a4f71023193c43098ac1fd65ead7a4">combine_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, ITER first, ITER last, OP &amp;&amp;op, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> void_value=<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>)</td></tr>
<tr class="memdesc:ab5a4f71023193c43098ac1fd65ead7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a sequence of elements as a range with data at <code>offset</code>.  <a href="#ab5a4f71023193c43098ac1fd65ead7a4">More...</a><br/></td></tr>
<tr class="separator:ab5a4f71023193c43098ac1fd65ead7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c35df8ebbf185c3c5c2ad65c603bd9"><td class="memTemplParams" colspan="2">template&lt;typename CONT , typename OP &gt; </td></tr>
<tr class="memitem:a38c35df8ebbf185c3c5c2ad65c603bd9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a38c35df8ebbf185c3c5c2ad65c603bd9">combine_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, const CONT &amp;other, OP &amp;&amp;op, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> void_value=<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>)</td></tr>
<tr class="memdesc:a38c35df8ebbf185c3c5c2ad65c603bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the elements in container with the data at <code>offset</code>.  <a href="#a38c35df8ebbf185c3c5c2ad65c603bd9">More...</a><br/></td></tr>
<tr class="separator:a38c35df8ebbf185c3c5c2ad65c603bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5da11d38aaae9a6c818c9d0cf8d3c50d"><td class="memTemplParams" colspan="2">template&lt;typename ITER &gt; </td></tr>
<tr class="memitem:a5da11d38aaae9a6c818c9d0cf8d3c50d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">append</a> (ITER first, ITER last)</td></tr>
<tr class="memdesc:a5da11d38aaae9a6c818c9d0cf8d3c50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sequence of elements as a range at the end of the vector.  <a href="#a5da11d38aaae9a6c818c9d0cf8d3c50d">More...</a><br/></td></tr>
<tr class="separator:a5da11d38aaae9a6c818c9d0cf8d3c50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc42920147b3fd71f9eac4ce28f08c5"><td class="memTemplParams" colspan="2">template&lt;typename CONT &gt; </td></tr>
<tr class="memitem:a1fc42920147b3fd71f9eac4ce28f08c5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a1fc42920147b3fd71f9eac4ce28f08c5">append</a> (const CONT &amp;<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">range_data</a>)</td></tr>
<tr class="memdesc:a1fc42920147b3fd71f9eac4ce28f08c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sequence of elements as a range at the end of the vector.  <a href="#a1fc42920147b3fd71f9eac4ce28f08c5">More...</a><br/></td></tr>
<tr class="separator:a1fc42920147b3fd71f9eac4ce28f08c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf76cd841e4d01c79a18c92517ebc4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aadf76cd841e4d01c79a18c92517ebc4c">append</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">range_data</a>)</td></tr>
<tr class="memdesc:aadf76cd841e4d01c79a18c92517ebc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sequence of elements as a range at the end of the vector.  <a href="#aadf76cd841e4d01c79a18c92517ebc4c">More...</a><br/></td></tr>
<tr class="separator:aadf76cd841e4d01c79a18c92517ebc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aded208488fdad5031c60a1c5bf4295e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aded208488fdad5031c60a1c5bf4295e8">void_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> const iRange)</td></tr>
<tr class="memdesc:aded208488fdad5031c60a1c5bf4295e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the specified range into void.  <a href="#aded208488fdad5031c60a1c5bf4295e8">More...</a><br/></td></tr>
<tr class="separator:aded208488fdad5031c60a1c5bf4295e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eef29eb10c2c2847844eff6aeb2b84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7eef29eb10c2c2847844eff6aeb2b84a">void_range</a> (std::size_t const iRange)</td></tr>
<tr class="separator:a7eef29eb10c2c2847844eff6aeb2b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac173bb6bb0f8f6912f5656e85dae4a4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac173bb6bb0f8f6912f5656e85dae4a4f">optimize</a> ()</td></tr>
<tr class="memdesc:ac173bb6bb0f8f6912f5656e85dae4a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs internal optimization, returns whether the object was changed.  <a href="#ac173bb6bb0f8f6912f5656e85dae4a4f">More...</a><br/></td></tr>
<tr class="separator:ac173bb6bb0f8f6912f5656e85dae4a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cdd6f6abddd5e3cfb4ec2ccc3aba4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aa1cdd6f6abddd5e3cfb4ec2ccc3aba4a">optimize</a> (size_t)</td></tr>
<tr class="separator:aa1cdd6f6abddd5e3cfb4ec2ccc3aba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Static members related to data size and optimization</div></td></tr>
<tr class="memitem:a37cd5a5710d6a036a9de112b98715424"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a37cd5a5710d6a036a9de112b98715424">expected_vector_size</a> (size_t <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>)</td></tr>
<tr class="memdesc:a37cd5a5710d6a036a9de112b98715424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expected size taken by a vector of specified size.  <a href="#a37cd5a5710d6a036a9de112b98715424">More...</a><br/></td></tr>
<tr class="separator:a37cd5a5710d6a036a9de112b98715424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9baa027630c6e45904a903d2c93e095"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#af9baa027630c6e45904a903d2c93e095">min_gap</a> ()</td></tr>
<tr class="memdesc:af9baa027630c6e45904a903d2c93e095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum optimal gap between ranges (a guess)  <a href="#af9baa027630c6e45904a903d2c93e095">More...</a><br/></td></tr>
<tr class="separator:af9baa027630c6e45904a903d2c93e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406f4982869328a7bc4a6ad7fa5da2df"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a406f4982869328a7bc4a6ad7fa5da2df">should_merge</a> (const typename <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#adb944680f136f906e00e58a73a7f27bc">datarange_t::base_t</a> &amp;<a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, const typename <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#adb944680f136f906e00e58a73a7f27bc">datarange_t::base_t</a> &amp;b)</td></tr>
<tr class="memdesc:a406f4982869328a7bc4a6ad7fa5da2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if merging the two specified ranges would save memory.  <a href="#a406f4982869328a7bc4a6ad7fa5da2df">More...</a><br/></td></tr>
<tr class="separator:a406f4982869328a7bc4a6ad7fa5da2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1e5366c7c622f84f3bb75d685feb2af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a1e5366c7c622f84f3bb75d685feb2af4">minimum_size</a> () const </td></tr>
<tr class="memdesc:a1e5366c7c622f84f3bb75d685feb2af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size determined by the ranges already present.  <a href="#a1e5366c7c622f84f3bb75d685feb2af4">More...</a><br/></td></tr>
<tr class="separator:a1e5366c7c622f84f3bb75d685feb2af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feb56eacc5cf187a70306d31f58ec8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a9feb56eacc5cf187a70306d31f58ec8a">add_range_before</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;new_data, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> nextRange)</td></tr>
<tr class="memdesc:a9feb56eacc5cf187a70306d31f58ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail of <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27" title="Adds a sequence of elements as a range with specified offset. ">add_range()</a></code>, with where to add the range.  <a href="#a9feb56eacc5cf187a70306d31f58ec8a">More...</a><br/></td></tr>
<tr class="separator:a9feb56eacc5cf187a70306d31f58ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf49e7e691b1bd57612df39d62ebc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0cf49e7e691b1bd57612df39d62ebc3a">eat_range_head</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iRange, size_t index)</td></tr>
<tr class="memdesc:a0cf49e7e691b1bd57612df39d62ebc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voids the starting elements up to index (excluded) of a given range.  <a href="#a0cf49e7e691b1bd57612df39d62ebc3a">More...</a><br/></td></tr>
<tr class="separator:a0cf49e7e691b1bd57612df39d62ebc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8350ed0e31212fd3373171a290ebba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">merge_ranges</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iRange)</td></tr>
<tr class="memdesc:abc8350ed0e31212fd3373171a290ebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the following contiguous ranges.  <a href="#abc8350ed0e31212fd3373171a290ebba">More...</a><br/></td></tr>
<tr class="separator:abc8350ed0e31212fd3373171a290ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ce75327d4c700ab4d9436f7c117603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a83ce75327d4c700ab4d9436f7c117603">fix_size</a> ()</td></tr>
<tr class="memdesc:a83ce75327d4c700ab4d9436f7c117603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the vector size according to the last range.  <a href="#a83ce75327d4c700ab4d9436f7c117603">More...</a><br/></td></tr>
<tr class="separator:a83ce75327d4c700ab4d9436f7c117603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaedbcaaf5709ab6e4d0a014b78c7cfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:aaedbcaaf5709ab6e4d0a014b78c7cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range after <code>index</code>.  <a href="#aaedbcaaf5709ab6e4d0a014b78c7cfc0">More...</a><br/></td></tr>
<tr class="separator:aaedbcaaf5709ab6e4d0a014b78c7cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2c2370f2387dd43cdb4c1727ab3d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a6cc2c2370f2387dd43cdb4c1727ab3d1">find_next_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="separator:a6cc2c2370f2387dd43cdb4c1727ab3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39d2556e9bbf79eefc61ede54e4403e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a39d2556e9bbf79eefc61ede54e4403e4">find_next_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> rbegin)</td></tr>
<tr class="memdesc:a39d2556e9bbf79eefc61ede54e4403e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range after <code>index</code>, or <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a></code> if none.  <a href="#a39d2556e9bbf79eefc61ede54e4403e4">More...</a><br/></td></tr>
<tr class="separator:a39d2556e9bbf79eefc61ede54e4403e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cb673862310be6e67c41738e504d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aa9cb673862310be6e67c41738e504d0d">find_next_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> rbegin) const </td></tr>
<tr class="separator:aa9cb673862310be6e67c41738e504d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a612885c6f6e1b94c3d21c5627035a613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a612885c6f6e1b94c3d21c5627035a613">find_range_iter_at_or_after</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:a612885c6f6e1b94c3d21c5627035a613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range at or after <code>index</code>.  <a href="#a612885c6f6e1b94c3d21c5627035a613">More...</a><br/></td></tr>
<tr class="separator:a612885c6f6e1b94c3d21c5627035a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33352c966e01d9217fefe1db448c844f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a33352c966e01d9217fefe1db448c844f">find_range_iter_at_or_after</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="separator:a33352c966e01d9217fefe1db448c844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6bf74cfaf702b9d2af69549140875926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">find_extending_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index)</td></tr>
<tr class="memdesc:a6bf74cfaf702b9d2af69549140875926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range no earlier than <code>index</code>, or <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end()</a></code> if none.  <a href="#a6bf74cfaf702b9d2af69549140875926">More...</a><br/></td></tr>
<tr class="separator:a6bf74cfaf702b9d2af69549140875926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e93a8c1881c3fc347a843dac91264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#af90e93a8c1881c3fc347a843dac91264">find_extending_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index) const </td></tr>
<tr class="separator:af90e93a8c1881c3fc347a843dac91264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a91544d1adae5ffec3c18a9c10404a288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a91544d1adae5ffec3c18a9c10404a288">find_extending_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> rbegin)</td></tr>
<tr class="memdesc:a91544d1adae5ffec3c18a9c10404a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the range that contains the first non-void element after <code>index</code>, or <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end()</a></code> if none.  <a href="#a91544d1adae5ffec3c18a9c10404a288">More...</a><br/></td></tr>
<tr class="separator:a91544d1adae5ffec3c18a9c10404a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a59be28c436bc099ae9c29ca658432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a45a59be28c436bc099ae9c29ca658432">find_extending_range_iter</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> index, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> rbegin) const </td></tr>
<tr class="separator:a45a59be28c436bc099ae9c29ca658432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac5cd9fcb98d27580e372ea6c222ada3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">insert_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iInsert, const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;data)</td></tr>
<tr class="memdesc:ac5cd9fcb98d27580e372ea6c222ada3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plug a new data range in the specified position; no check performed.  <a href="#ac5cd9fcb98d27580e372ea6c222ada3f">More...</a><br/></td></tr>
<tr class="separator:ac5cd9fcb98d27580e372ea6c222ada3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836c7efbdd028833bf07de76870476d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a836c7efbdd028833bf07de76870476d6">insert_range</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iInsert, <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&amp;data)</td></tr>
<tr class="separator:a836c7efbdd028833bf07de76870476d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8957361aeb2d633e2d4d2a3ae61e259b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a></td></tr>
<tr class="memdesc:a8957361aeb2d633e2d4d2a3ae61e259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">current size  <a href="#a8957361aeb2d633e2d4d2a3ae61e259b">More...</a><br/></td></tr>
<tr class="separator:a8957361aeb2d633e2d4d2a3ae61e259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc90eb32e8136221b52fa539a7ef3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a></td></tr>
<tr class="memdesc:adcc90eb32e8136221b52fa539a7ef3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of ranges  <a href="#adcc90eb32e8136221b52fa539a7ef3df">More...</a><br/></td></tr>
<tr class="separator:adcc90eb32e8136221b52fa539a7ef3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a50ea45eed02e6424fab0c37d5b108cb8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50ea45eed02e6424fab0c37d5b108cb8">this_t</a></td></tr>
<tr class="separator:a50ea45eed02e6424fab0c37d5b108cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Static members for dealing with this type of value</h2></td></tr>
<tr class="memitem:a50130760506a7ce9b22e07a477975cf5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a> {0}</td></tr>
<tr class="memdesc:a50130760506a7ce9b22e07a477975cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a representation of 0  <a href="#a50130760506a7ce9b22e07a477975cf5">More...</a><br/></td></tr>
<tr class="separator:a50130760506a7ce9b22e07a477975cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e095c2127eccb0cfa75e756346f967"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">abs</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> v)</td></tr>
<tr class="memdesc:ad7e095c2127eccb0cfa75e756346f967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module of the specified value.  <a href="#ad7e095c2127eccb0cfa75e756346f967">More...</a><br/></td></tr>
<tr class="separator:ad7e095c2127eccb0cfa75e756346f967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b17772d1ca521f6a9c356e5bb6e8fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">is_zero</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> v)</td></tr>
<tr class="memdesc:a27b17772d1ca521f6a9c356e5bb6e8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the value is exactly zero.  <a href="#a27b17772d1ca521f6a9c356e5bb6e8fd">More...</a><br/></td></tr>
<tr class="separator:a27b17772d1ca521f6a9c356e5bb6e8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c760e2fd9a0f4b8e48f6f57ddecb0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ab1c760e2fd9a0f4b8e48f6f57ddecb0a">is_zero</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> v, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> thr)</td></tr>
<tr class="memdesc:ab1c760e2fd9a0f4b8e48f6f57ddecb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the value is zero below a given threshold.  <a href="#ab1c760e2fd9a0f4b8e48f6f57ddecb0a">More...</a><br/></td></tr>
<tr class="separator:ab1c760e2fd9a0f4b8e48f6f57ddecb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982494b6d02fc56ce33d6ef8a36c1d9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a982494b6d02fc56ce33d6ef8a36c1d9a">is_equal</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> b)</td></tr>
<tr class="memdesc:a982494b6d02fc56ce33d6ef8a36c1d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether two values are the same.  <a href="#a982494b6d02fc56ce33d6ef8a36c1d9a">More...</a><br/></td></tr>
<tr class="separator:a982494b6d02fc56ce33d6ef8a36c1d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22909cc03b2c673fa2598f918bb0ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a3c22909cc03b2c673fa2598f918bb0ff">is_equal</a> (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d1/d82/OnlineDecoder_8fcl.html#a99b093ee2be2d37375506bb99fb5ea75">a</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> b, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> thr)</td></tr>
<tr class="memdesc:a3c22909cc03b2c673fa2598f918bb0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether two values are the same below a given threshold.  <a href="#a3c22909cc03b2c673fa2598f918bb0ff">More...</a><br/></td></tr>
<tr class="separator:a3c22909cc03b2c673fa2598f918bb0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class lar::sparse_vector&lt; T &gt;</h3>

<p>A sparse vector. </p>
<hr/>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data stored in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000078">Todo:</a></b></dt><dd>backward iteration; reverse iterators; iterator on non-void elements only; iterator on non-void elements only, returning a pair (index;value)</dd></dl>
<p>A <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html" title="A sparse vector. ">sparse_vector</a> is a container of items marked by consecutive indices (that is, a vector like std::vector), where only non-zero elements are actually stored. The implementation is a container of ranges of non-zero consecutive values; the zero elements are effectively not stored in the object, and a zero is returned whenever they are accessed. In the following, the regions of zeros between the non-zero ranges are collectively called "the void".</p>
<p>See <a class="el" href="../../dd/d59/sparse__vector__test_8cc.html" title="Implementation tests for a sparse_vector object. ">sparse_vector_test.cc</a> for examples of usage.</p>
<p>Although some level of dynamic assignment is present, the class is not very flexible and it is best assigned just once, by adding ranges (<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27" title="Adds a sequence of elements as a range with specified offset. ">add_range()</a>; or by <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#afc8cd9f5aef77190e0069e5a3547ffb4">push_back()</a>, which is less efficient). While this class mimics a good deal of the STL vector interface, it is <em>not</em> a std::vector and it does not support all the tricks of it.</p>
<p>For the following, let's assume: </p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector&lt;double&gt;</a> sv;</div>
<div class="line">std::vector&lt;double&gt; buffer;</div>
</div><!-- fragment --><h2>Supported usage </h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>: sv) <a class="code" href="../../d8/df5/messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">lar::sparse_vector&lt;double&gt;::const_iterator</a> iValue = sv.cbegin(), vend = sv.cend();</div>
<div class="line"><span class="keywordflow">while</span> (iSV != sv.end()) <a class="code" href="../../d8/df5/messageservice_8fcl.html#a6699b4dbd72f548e48d81c88697d35a6">std::cout</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *(iSV++);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> value: sv) { ... }</div>
</div><!-- fragment --><p> Common iteration on all elements. Better to do a constant one. The first two examples print the full content of the sparse vector, void included. </p>
<hr/>
<div class="fragment"><div class="line">sv[10] = 3.;</div>
</div><!-- fragment --><p> Assign to an <em>existing</em> (not void) element. Assigning to void elements is not supported, and there is no way to make an existing element to become void (assigning 0 will yield to an existing element with value 0). </p>
<hr/>
<div class="fragment"><div class="line">sv.set_at(10, 3.);</div>
</div><!-- fragment --><p> Assign a value to an element. The element could be in the void; in any case, after this call the element will not be in the void anymore (even if the assigned value is zero; to cast a cell into the void, use <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac45f761fde6de417b32d640fa84bc5a7" title="Casts the element with the specified index into the void. ">unset_at()</a>). </p>
<hr/>
<div class="fragment"><div class="line">sv.add_range(20, buffer)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">sv.add_range(20, buffer.begin(), buffer.end())</div>
</div><!-- fragment --> <div class="fragment"><div class="line">sv.add_range(20, std::move(buffer))</div>
</div><!-- fragment --><p> Add the content of buffer starting at the specified position. The last line will attempt to use the buffer directly (only happens if the start of the new range &ndash; 20 in the example &ndash; is in the void and therefore a new range will be added). The new range is merged with the existing ones when needed, and it overwrites their content in case of overlap. If the specified position is beyond the current end of the sparse vector, the gap will be filled by void. </p>
<hr/>
<div class="fragment"><div class="line">sv.append(buffer)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">sv.append(buffer.begin(), buffer.end())</div>
</div><!-- fragment --> <div class="fragment"><div class="line">sv.append(std::move(buffer))</div>
</div><!-- fragment --><p> Add the content of buffer at the end of the sparse vector. The last line will attempt to use the buffer directly (only happens if the end of the sparse vector is in the void and therefore a new range will be added). </p>
<hr/>
<div class="fragment"><div class="line">sv.resize(30)</div>
</div><!-- fragment --><p> Resizes the sparse vector to the specified size. Truncation may occur, in which case the data beyond the new size is removed. If an extension occurs instead, the new area is void. </p>
<hr/>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">lar::sparse_vector&lt;double&gt;::datarange_t</a>&amp; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>: sv.get_ranges()) {</div>
<div class="line">  <span class="keywordtype">size_t</span> first_item = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a10e0798d5351e6238e0287a2ebc474d6">begin_index</a>(); <span class="comment">// index of the first item</span></div>
<div class="line">  <span class="keywordtype">size_t</span> nItems = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a482df4edc3c71638bdce4f02e66a8b5f">size</a>(); <span class="comment">// number of items in this range</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">double</span> value: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>) { ... }</div>
<div class="line">}</div>
</div><!-- fragment --><p> A sparse vector can be parsed range by range, skipping the void. Each range object itself supports iteration. Neither the content nor the shape of the ranges can be changed this way.</p>
<h2>Possible future improvements </h2>
<div class="fragment"><div class="line">sv[10] = 3.;</div>
</div><!-- fragment --><p> is not supported if the vector is shorter than 11 (similarly to a std::vector too), and not even if the item #10 is currently in the void. This latter could be changed to create a new element/range; this would require to ship the pointer to the container with the reference (the return value of "sv[10]"), just in case an assignment will occur, or to create the element regardless, like for std::map (but this would provoke a disaster if the caller uses the non-constant operator[] for iteration). So far, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad85e95c62868cd7027d94526bf77037d" title="Writes into an element (creating or expanding a range if needed) ">set_at()</a> is the closest thing to it.</p>
<h2>Non-supported usage </h2>
<div class="fragment"><div class="line">sv.reserve(20);</div>
</div><!-- fragment --><p> This has no clear meaning. A usage analogous to STL would precede a sequence of push_back's. In that case, we should create a new empty range at the end of the vector, and reserve that. Empty ranges are currently not allowed. A replacement of this pattern is to create a new <code>std::vector</code>, reserve space for it and fill it, and finally use <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d" title="Adds a sequence of elements as a range at the end of the vector. ">sparse_vector::append()</a></code>. If the end of the vector is void, there will be no performance penalty, otherwise a reserve + copy will happen. </p>
<hr/>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; value: sv) { ... }</div>
</div><!-- fragment --><p> In order to allow for assignment in an item which is currently not void, the non-constant iterators do not dereference directly into a reference to the vector element (which would be non-existent if in the void), but instead into a lightweight object (still called "reference"). These objects are semantically working as references, but they are formally rvalues (i.e., just values, not C++ references), so they can't be assigned to references (like "auto&amp;"). Nevertheless they work as references and assigning to them does change the original value. Currently assigning to void cells is not supported (see above). </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00289">289</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a52a70f919de9964cacdf6ed6c75ea691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef vector_t::const_pointer <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a52a70f919de9964cacdf6ed6c75ea691">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00480">480</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0535ed142129efbfa4cae9b5b84c5964"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef vector_t::difference_type <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a0535ed142129efbfa4cae9b5b84c5964">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>index difference type </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00477">477</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cf30371f7d6c623d9a110bb117b3380"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef vector_t::pointer <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5cf30371f7d6c623d9a110bb117b3380">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00479">479</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a00801a937328f1596028f4d922d9f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef range_list_t::const_iterator <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of constant iterator over ranges </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00498">498</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aedfebe294b81a209189dd13bc11b2aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef range_list_t::iterator <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of iterator over ranges </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00496">496</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a59b371c390784a0f7206929e4c13cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&gt; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of sparse vector data </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00491">491</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff5f860ccf8633e81d310ae4b31f7193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef vector_t::size_type <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00476">476</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a50ea45eed02e6424fab0c37d5b108cb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt;T&gt; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50ea45eed02e6424fab0c37d5b108cb8">this_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00468">468</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84ae9b33ffba8b4b2d6e2f840ef12611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the stored values </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00473">473</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03fd3f170a77316f9410e181da02beab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&gt; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of STL vector holding this data </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00474">474</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af085ea35839fd1336675231c4b521b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor: an empty vector. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00505">505</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>(0), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>() {}</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1bc410a56ceb2199dac1eb2c75150d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: a vector with new_size elements in the void. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00509">509</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                                   : <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>(0), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>()</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    { <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">resize</a>(new_size); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_af9f87b865ed66c0ae0be183046e47ed9"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">lar::sparse_vector::resize</a></div><div class="ttdeci">void resize(size_type new_size)</div><div class="ttdoc">Resizes the vector to the specified size, adding void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01710">sparse_vector.h:1710</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0c2486775f72d568f95f476df1adb5fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: a solid vector from an existing STL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>vector to copy data from </td></tr>
    <tr><td class="paramname">offset</td><td>(default: 0) index the data starts from (preceeded by void) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00517">517</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                                                           :</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>(0), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>()</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    { <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.begin(), <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.end()); }</div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
<div class="ttc" id="testFHiCLfiles_8sh_html_a6401d1c0a168bb3757821ca209161fe2"><div class="ttname"><a href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a></div><div class="ttdeci">exclude from</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/db0/testFHiCLfiles_8sh_source.html#l00347">testFHiCLfiles.sh:347</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4ab363cc2b2fd15b2960f6b0598edd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: default. </p>

</div>
</div>
<a class="anchor" id="a77b3c021a57c94ca0c1316dbaa3baef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00525">525</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    : <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>(<a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.nominal_size)</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    , <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>(std::move(<a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.ranges))</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    { <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.nominal_size = 0; }</div>
<div class="ttc" id="testFHiCLfiles_8sh_html_a6401d1c0a168bb3757821ca209161fe2"><div class="ttname"><a href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a></div><div class="ttdeci">exclude from</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/db0/testFHiCLfiles_8sh_source.html#l00347">testFHiCLfiles.sh:347</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aad08cb28eedbc3083e07c96760e037fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: a solid vector from an existing STL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>vector to move data from </td></tr>
    <tr><td class="paramname">offset</td><td>(default: 0) index the data starts from (preceeded by void) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00547">547</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                                                      :</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>(0), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>()</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    { <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, std::move(<a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>)); }</div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
<div class="ttc" id="testFHiCLfiles_8sh_html_a6401d1c0a168bb3757821ca209161fe2"><div class="ttname"><a href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a></div><div class="ttdeci">exclude from</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/db0/testFHiCLfiles_8sh_source.html#l00347">testFHiCLfiles.sh:347</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8bbc2ed64ea172ed4539d32d1c022c07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::~<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: default. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad7e095c2127eccb0cfa75e756346f967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the module of the specified value. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01010">1010</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;{ <span class="keywordflow">return</span> (v &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>)? -v: v; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a50130760506a7ce9b22e07a477975cf5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">lar::sparse_vector::value_zero</a></div><div class="ttdeci">static constexpr value_type value_zero</div><div class="ttdoc">a representation of 0 </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01007">sparse_vector.h:1007</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a234e1a7d10a4225b66209e2d14365f27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a sequence of elements as a range with specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITER</td><td>type of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>where to add the elements </td></tr>
    <tr><td class="paramname">first</td><td>iterator to the first element to be added </td></tr>
    <tr><td class="paramname">last</td><td>iterator after the last element to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>If the offset is beyond the current end of the sparse vector, void is added before the new range.</p>
<p>Existing ranges can be merged with the new data if they overlap. </p>

</div>
</div>
<a class="anchor" id="a05f37f42174528faa44840a5940e365c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename CONT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CONT &amp;&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in container to a range with specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONT</td><td>type of container supporting the standard begin/end interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>where to add the elements </td></tr>
    <tr><td class="paramname">new_data</td><td>container holding the data to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>If the offset is beyond the current end of the sparse vector, void is added before the new range.</p>
<p>Existing ranges can be merged with the new data if they overlap. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00837">837</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, new_data.begin(), new_data.end()); }</div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad5591e6670dc1a08dc31d1f779526037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a sequence of elements as a range with specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>where to add the elements </td></tr>
    <tr><td class="paramname">new_data</td><td>container holding the data to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>If the offset is beyond the current end of the sparse vector, void is added before the new range.</p>
<p>Existing ranges can be merged with the new data if they overlap. If no merging happens, new_data vector is directly used as the new range added; otherwise, it is just copied. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01967">1967</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;{</div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;  <span class="comment">// insert the new range before the existing range which starts after offset</span></div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a9feb56eacc5cf187a70306d31f58ec8a">add_range_before</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, std::move(new_data),</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;    std::upper_bound(</div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin(), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end(), <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>,</div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;      <span class="keyword">typename</span> <a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">datarange_t::less_int_range</a>(<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">datarange_t::less</a>)</div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;    )</div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;    );</div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;</div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::add_range(vector)</span></div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a9feb56eacc5cf187a70306d31f58ec8a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a9feb56eacc5cf187a70306d31f58ec8a">lar::sparse_vector::add_range_before</a></div><div class="ttdeci">const datarange_t &amp; add_range_before(size_type offset, vector_t &amp;&amp;new_data, range_iterator nextRange)</div><div class="ttdoc">Implementation detail of add_range(), with where to add the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02224">sparse_vector.h:2224</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a88c4d216a52a40426506fd34d4f0c7dd"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">lar::range_t&lt; size_type &gt;::less_int_range</a></div><div class="ttdeci">bool(* less_int_range)(size_type, const range_t &amp;b)</div><div class="ttdoc">Helper type to be used for binary searches. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00279">sparse_vector.h:279</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a19401e6e61b9f0cf850a0196ab899f9c"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">lar::range_t&lt; size_type &gt;::less</a></div><div class="ttdeci">static bool less(const range_t &amp;a, const range_t &amp;b)</div><div class="ttdoc">Returns if a is &amp;quot;less&amp;quot; than b. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00270">sparse_vector.h:270</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a11a2673bf7114398570ba1b2633b1820"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt;T&gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01946">1946</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;{</div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;  <span class="comment">// insert the new range before the existing range which starts after offset</span></div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iInsert = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>);</div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;</div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;  <span class="comment">// is there a range before this, which includes the offset?</span></div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;  <span class="keywordflow">if</span> ((iInsert != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) &amp;&amp; std::prev(iInsert)-&gt;borders(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>)) {</div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;    <span class="comment">// then we should extend it</span></div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;    (--iInsert)-&gt;extend(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>, last);</div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;  }</div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;    <span class="comment">// no range before the insertion one includes the offset of the new range;</span></div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;    <span class="comment">// ... we need to add it as a new range</span></div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;    iInsert = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">insert_range</a>(iInsert, { <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>, last });</div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;  }</div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">merge_ranges</a>(iInsert);</div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::add_range&lt;ITER&gt;()</span></div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_af481fa22253619167bce75a37e10ec34"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">channelDBConverter.first</a></div><div class="ttdeci">first</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00146">channelDBConverter.py:146</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_abc8350ed0e31212fd3373171a290ebba"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">lar::sparse_vector::merge_ranges</a></div><div class="ttdeci">datarange_t &amp; merge_ranges(range_iterator iRange)</div><div class="ttdoc">Merges all the following contiguous ranges. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02248">sparse_vector.h:2248</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ac5cd9fcb98d27580e372ea6c222ada3f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">lar::sparse_vector::insert_range</a></div><div class="ttdeci">range_iterator insert_range(range_iterator iInsert, const datarange_t &amp;data)</div><div class="ttdoc">Plug a new data range in the specified position; no check performed. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01140">sparse_vector.h:1140</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9feb56eacc5cf187a70306d31f58ec8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::add_range_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>nextRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation detail of <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27" title="Adds a sequence of elements as a range with specified offset. ">add_range()</a></code>, with where to add the range. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02224">2224</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;{</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;  <span class="comment">// insert the new range before the existing range which starts after offset</span></div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iInsert = nextRange;</div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;</div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;  <span class="comment">// is there a range before this, which includes the offset?</span></div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;  <span class="keywordflow">if</span> ((iInsert != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) &amp;&amp; (iInsert-1)-&gt;borders(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>)) {</div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;    <span class="comment">// then we should extend it</span></div>
<div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;    (--iInsert)-&gt;extend(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, new_data.begin(), new_data.end());</div>
<div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;  }</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;    <span class="comment">// no range before the insertion one includes the offset of the new range;</span></div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;    <span class="comment">// ... we need to add it as a new range;</span></div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    <span class="comment">// it is not really clear to me [GP] why I need a std::move here, since</span></div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;    <span class="comment">// new_data is a rvalue already; in doubt, I have painted all this kind</span></div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    <span class="comment">// of constructs with move()s, just in case</span></div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;    iInsert = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">insert_range</a>(iInsert, { <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, std::move(new_data) });</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;  }</div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">merge_ranges</a>(iInsert);</div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::add_range_before(vector, iterator)</span></div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_abc8350ed0e31212fd3373171a290ebba"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">lar::sparse_vector::merge_ranges</a></div><div class="ttdeci">datarange_t &amp; merge_ranges(range_iterator iRange)</div><div class="ttdoc">Merges all the following contiguous ranges. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02248">sparse_vector.h:2248</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ac5cd9fcb98d27580e372ea6c222ada3f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">lar::sparse_vector::insert_range</a></div><div class="ttdeci">range_iterator insert_range(range_iterator iInsert, const datarange_t &amp;data)</div><div class="ttdoc">Plug a new data range in the specified position; no check performed. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01140">sparse_vector.h:1140</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5da11d38aaae9a6c818c9d0cf8d3c50d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a sequence of elements as a range at the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to be added </td></tr>
    <tr><td class="paramname">last</td><td>iterator after the last element to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>The input range is copied at the end of the sparse vector. If the end of the sparse vector was the end of a range, that range is expanded, otherwise a new one is created. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00927">927</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>(), <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>, last); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_af481fa22253619167bce75a37e10ec34"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">channelDBConverter.first</a></div><div class="ttdeci">first</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00146">channelDBConverter.py:146</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1fc42920147b3fd71f9eac4ce28f08c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename CONT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CONT &amp;&#160;</td>
          <td class="paramname"><em>range_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a sequence of elements as a range at the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_data</td><td>contained holding the data to be copied or moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>The input data is copied at the end of the sparse vector. If the end of the sparse vector was the end of a range, that range is expanded, otherwise a new one is created. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00940">940</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>(), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">range_data</a>); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_acdac9efcea1f9b799b9b5be46d5dc613"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">lar::sparse_vector::range_data</a></div><div class="ttdeci">auto range_data(std::size_t i)</div><div class="ttdoc">Provides direct access to data of i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01887">sparse_vector.h:1887</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aadf76cd841e4d01c79a18c92517ebc4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>range_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a sequence of elements as a range at the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_data</td><td>contained holding the data to be copied or moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added</dd></dl>
<p>If there is a range at the end of the sparse vector, it will be expanded with the new data. Otherwise, this method will use the data vector directly as a new range added at the end of the sparse vector. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00953">953</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>(), std::move(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">range_data</a>)); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_acdac9efcea1f9b799b9b5be46d5dc613"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613">lar::sparse_vector::range_data</a></div><div class="ttdeci">auto range_data(std::size_t i)</div><div class="ttdoc">Provides direct access to data of i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01887">sparse_vector.h:1887</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a044ea2dc6b1f1eabbdf74b6a8390aa24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a sequence between two iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITER</td><td>type of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first element to be copied </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing after the last element to be copied</td></tr>
  </table>
  </dd>
</dl>
<p>The previous content of the sparse vector is lost. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00669">669</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;{ <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">clear</a>(); <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">append</a>(<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>, last); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a0c18a4f929acc8739151b3d928770b0f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">lar::sparse_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Removes all the data, making the vector empty. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00558">sparse_vector.h:558</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_af481fa22253619167bce75a37e10ec34"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">channelDBConverter.first</a></div><div class="ttdeci">first</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00146">channelDBConverter.py:146</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a5da11d38aaae9a6c818c9d0cf8d3c50d"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">lar::sparse_vector::append</a></div><div class="ttdeci">const datarange_t &amp; append(ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range at the end of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00927">sparse_vector.h:927</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0131e1d331e41642eca629fdbb4a5de8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename CONT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CONT &amp;&#160;</td>
          <td class="paramname"><em>new_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONT</td><td>type of container supporting the standard begin/end interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td>container with the data to be copied</td></tr>
  </table>
  </dd>
</dl>
<p>The previous content of the sparse vector is lost. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00679">679</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;{ <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">clear</a>(); <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">append</a>(new_data); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a0c18a4f929acc8739151b3d928770b0f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">lar::sparse_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Removes all the data, making the vector empty. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00558">sparse_vector.h:558</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a5da11d38aaae9a6c818c9d0cf8d3c50d"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">lar::sparse_vector::append</a></div><div class="ttdeci">const datarange_t &amp; append(ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range at the end of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00927">sparse_vector.h:927</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac5d110713f2bd9a724dc1524936a19f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves data from a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td>vector with the data to be moved</td></tr>
  </table>
  </dd>
</dl>
<p>The previous content of the sparse vector is lost. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00687">687</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;{ <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">clear</a>(); <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">append</a>(std::move(new_data)); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a0c18a4f929acc8739151b3d928770b0f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a0c18a4f929acc8739151b3d928770b0f">lar::sparse_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Removes all the data, making the vector empty. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00558">sparse_vector.h:558</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a5da11d38aaae9a6c818c9d0cf8d3c50d"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">lar::sparse_vector::append</a></div><div class="ttdeci">const datarange_t &amp; append(ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range at the end of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00927">sparse_vector.h:927</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeea706e34c1aaea8a9739419f2f4301c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::back_is_void </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the sparse vector ends with void. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5f29124d201a74963689f854d9d116e3" title="Returns whether the specified position is void. ">is_void()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00612">612</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty() || (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().end_index() &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27f4c126aac24d29524784f74dba7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard iterators interface. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01751">1751</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;  { <span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>, <span class="keyword">typename</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">iterator::special::begin</a>()); }</div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a677571b2eb742b938bb17f71fc217df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01760">1760</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;  { <span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>, <span class="keyword">typename</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">const_iterator::special::begin</a>()); }</div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_acc1957472e01a8d9ecd245e26338f0b9"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#acc1957472e01a8d9ecd245e26338f0b9">icarus::ns::util::begin</a></div><div class="ttdeci">auto begin(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00573">FixedBins.h:573</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2e40940b2813c0f49edb7286c030c002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::begin_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first data range. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00757">757</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a801fb9ad4d3b9500e05e51496de85c25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the capacity of the vector (compatibility only) </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00568">568</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91e4c898884f83e6b37e9b538b9d3f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00583">583</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a27f4c126aac24d29524784f74dba7f47">begin</a>(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a27f4c126aac24d29524784f74dba7f47"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a27f4c126aac24d29524784f74dba7f47">lar::sparse_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">Standard iterators interface. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01751">sparse_vector.h:1751</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65678bce1ff99f1312d548fcf87edb43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00584">584</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end</a>(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a605d6acf5893c79c00f6b7af9eff87a8"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">lar::sparse_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01755">sparse_vector.h:1755</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0c18a4f929acc8739151b3d928770b0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all the data, making the vector empty. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00558">558</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;{ <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.clear(); <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = 0; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab5a4f71023193c43098ac1fd65ead7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::combine_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>void_value</em> = <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines a sequence of elements as a range with data at <code>offset</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITER</td><td>type of iterator </td></tr>
    <tr><td class="paramname">OP</td><td>combination operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>where to add the elements </td></tr>
    <tr><td class="paramname">first</td><td>iterator to the first element to be added </td></tr>
    <tr><td class="paramname">last</td><td>iterator after the last element to be added </td></tr>
    <tr><td class="paramname">op</td><td>operation to be executed element by element </td></tr>
    <tr><td class="paramname">void_value</td><td>(default: <code>value_zero</code>) the value to use for void cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data landed</dd></dl>
<p>This is a more generic version of <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27" title="Adds a sequence of elements as a range with specified offset. ">add_range()</a></code>, where instead of replacing the target data with the data in [ <code>first</code>, <code>last</code> [, the existing data is combined with the one in that interval. The operation <code>op</code> is a binary operation with signature equivalent to <code>Data_t op(Data_t, Data_t)</code>, and the operation is equivalent to <code>v[i + offset] = op(v[i + offset], *(first + offset))</code>: <code>op</code> is a binary operation whose first operand is the existing value and the second one is the one being provided. If the cell <code>i + offset</code> is currently void, it will be created and the value used in the combination will be <code>void_value</code>.</p>
<p>If the offset is beyond the current end of the sparse vector, void is added before the new range.</p>
<p>Existing ranges can be merged with the new data if they overlap. </p>

</div>
</div>
<a class="anchor" id="a38c35df8ebbf185c3c5c2ad65c603bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename CONT , typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::combine_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CONT &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>void_value</em> = <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines the elements in container with the data at <code>offset</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CONT</td><td>type of container supporting the standard begin/end interface </td></tr>
    <tr><td class="paramname">OP</td><td>combination operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>where to add the elements </td></tr>
    <tr><td class="paramname">other</td><td>container holding the data to be combined </td></tr>
    <tr><td class="paramname">op</td><td>operation to be executed element by element </td></tr>
    <tr><td class="paramname">void_value</td><td>(default: <code>value_zero</code>) the value to use for void cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range where the new data was added </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ab5a4f71023193c43098ac1fd65ead7a4" title="Combines a sequence of elements as a range with data at offset. ">combine_range()</a></code></dd></dl>
<p>This is equivalent to <code>combine_range(size_type, ITER, ITER, OP, Data_t)</code> using as the new data range the full content of <code>other</code> container. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00905">905</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    {</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ab5a4f71023193c43098ac1fd65ead7a4">combine_range</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, other.begin(), other.end(),</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        std::forward&lt;OP&gt;(op), void_value);</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    }</div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ab5a4f71023193c43098ac1fd65ead7a4"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ab5a4f71023193c43098ac1fd65ead7a4">lar::sparse_vector::combine_range</a></div><div class="ttdeci">const datarange_t &amp; combine_range(size_type offset, ITER first, ITER last, OP &amp;&amp;op, value_type void_value=value_zero)</div><div class="ttdoc">Combines a sequence of elements as a range with data at offset. </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97c7072a900a5b4c490e437e69e81715"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename ITER , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::combine_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>void_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01982">1982</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;{</div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;<span class="comment">   * This is a complicate enough task, that we go brute force:</span></div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;<span class="comment">   * 1) combine all the input elements within the datarange where offset falls</span></div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;<span class="comment">   *    in</span></div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;<span class="comment">   * 2) create a new datarange combining void with the remaining input elements</span></div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;<span class="comment">   * 3) if the void area is over before the input elements are, repeat steps</span></div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;<span class="comment">   *    (1) and (2) with the updated offset</span></div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;<span class="comment">   * 4) at this point we&#39;ll have a train of contiguous ranges, result of</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;<span class="comment">   *    combination of the input elements alternating with existing elements</span></div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;<span class="comment">   *    and with void cells: apply the regular merge algorithm</span></div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;<span class="comment">   *</span></div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;</div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;  <span class="keyword">auto</span> src = <a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>;</div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;  <span class="keyword">auto</span> <span class="keyword">const</span> insertionPoint = <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>; <span class="comment">// saved for later</span></div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;  <span class="keyword">auto</span> destRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a612885c6f6e1b94c3d21c5627035a613">find_range_iter_at_or_after</a>(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>);</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;  <span class="keywordflow">while</span> (src != last) {</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;</div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;    <span class="comment">// (1) combine all the input elements within the datarange including offset</span></div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;    <span class="comment">//     (NOT extending the range)</span></div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;    <span class="keywordflow">if</span> ((destRange != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">end_range</a>()) &amp;&amp; destRange-&gt;includes(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>)) {</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;      <span class="comment">// combine input data until this range is over (or input data is over)</span></div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;      <span class="keyword">auto</span> dest = destRange-&gt;get_iterator(<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>);</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;</div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;      <span class="keyword">auto</span> <span class="keyword">const</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end</a> = destRange-&gt;end();</div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;      <span class="keywordflow">while</span> (src != last) {</div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;        *dest = op(*dest, *src);</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;        ++src;</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;        ++<a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>;</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;        <span class="keywordflow">if</span> (++dest == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end</a>) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;      } <span class="comment">// while</span></div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;      <span class="keywordflow">if</span> (src == last) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;      <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a> = destRange-&gt;end_index();</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;      ++destRange;</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;    } <span class="comment">// if</span></div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;</div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;    <span class="comment">// (2) create a new datarange combining void with input elements</span></div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;    <span class="comment">// at this point, offset is in the void, we do have more input data,</span></div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;    <span class="comment">// and `destRange` does _not_ contain the current insertion offset;</span></div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;    <span class="comment">// we fill as much void as we can with data, creating a new range.</span></div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;    <span class="comment">// When to stop? at the beginning of the next range, or when data is over</span></div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <span class="keyword">const</span> newRangeSize = (destRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">end_range</a>())</div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;      ? std::distance(src, last): (destRange-&gt;begin_index() - <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>);</div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;</div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;    <span class="comment">// prepare the data (we&#39;ll plug it in directly)</span></div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a> combinedData;</div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;    combinedData.reserve(newRangeSize);</div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> i = 0;</div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;    <span class="keywordflow">while</span> (i++ &lt; newRangeSize) {</div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;      combinedData.push_back(op(void_value, *src));</div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;      <span class="keywordflow">if</span> (++src == last) <span class="keywordflow">break</span>; <span class="comment">// no more data</span></div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;    }</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;    <span class="comment">// move the data as a new range inserted before the next range we just found</span></div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;    <span class="comment">// return value is the iterator to the inserted range</span></div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;    destRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">insert_range</a>(destRange, { <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a>, std::move(combinedData) });</div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;</div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;    <span class="comment">// (3) if there is more input, repeat steps (1) and (2) with updated offset</span></div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    <a class="code" href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a> = destRange-&gt;end_index();</div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;    ++destRange;</div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;</div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;  <span class="comment">// (4) apply the regular merge algorithm;</span></div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;  <span class="comment">//     since we did not extend existing ranges, it may happen that we have</span></div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;  <span class="comment">//     created a new range at `insertionPoint` contiguous to the previous one;</span></div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;  <span class="comment">//     so we take care of checking that too</span></div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">merge_ranges</a></div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;    (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">find_extending_range_iter</a>(insertionPoint == 0? 0: insertionPoint - 1));</div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::combine_range&lt;ITER&gt;()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a03fd3f170a77316f9410e181da02beab"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">lar::sparse_vector::vector_t</a></div><div class="ttdeci">std::vector&lt; value_type &gt; vector_t</div><div class="ttdoc">type of STL vector holding this data </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00474">sparse_vector.h:474</a></div></div>
<div class="ttc" id="CORSIKAGen_8fcl_html_a424b27db311314d6e22e0e78fd28a35a"><div class="ttname"><a href="../../d2/d0d/CORSIKAGen_8fcl.html#a424b27db311314d6e22e0e78fd28a35a">offset</a></div><div class="ttdeci">BEGIN_PROLOG TPC Trig offset(g4 rise time) ProjectToHeight</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d0d/CORSIKAGen_8fcl_source.html#l00007">CORSIKAGen.fcl:7</a></div></div>
<div class="ttc" id="namespacechannelDBConverter_html_af481fa22253619167bce75a37e10ec34"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">channelDBConverter.first</a></div><div class="ttdeci">first</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00146">channelDBConverter.py:146</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a6bf74cfaf702b9d2af69549140875926"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">lar::sparse_vector::find_extending_range_iter</a></div><div class="ttdeci">range_iterator find_extending_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range no earlier than index, or end() if none. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01111">sparse_vector.h:1111</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a605d6acf5893c79c00f6b7af9eff87a8"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">lar::sparse_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01755">sparse_vector.h:1755</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aff5f860ccf8633e81d310ae4b31f7193"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">lar::sparse_vector::size_type</a></div><div class="ttdeci">vector_t::size_type size_type</div><div class="ttdoc">size type </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00476">sparse_vector.h:476</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a612885c6f6e1b94c3d21c5627035a613"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a612885c6f6e1b94c3d21c5627035a613">lar::sparse_vector::find_range_iter_at_or_after</a></div><div class="ttdeci">range_iterator find_range_iter_at_or_after(size_type index)</div><div class="ttdoc">Returns an iterator to the range at or after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02186">sparse_vector.h:2186</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_abc8350ed0e31212fd3373171a290ebba"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#abc8350ed0e31212fd3373171a290ebba">lar::sparse_vector::merge_ranges</a></div><div class="ttdeci">datarange_t &amp; merge_ranges(range_iterator iRange)</div><div class="ttdoc">Merges all the following contiguous ranges. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02248">sparse_vector.h:2248</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ac5cd9fcb98d27580e372ea6c222ada3f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ac5cd9fcb98d27580e372ea6c222ada3f">lar::sparse_vector::insert_range</a></div><div class="ttdeci">range_iterator insert_range(range_iterator iInsert, const datarange_t &amp;data)</div><div class="ttdoc">Plug a new data range in the specified position; no check performed. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01140">sparse_vector.h:1140</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ad8cccbfc3bc88c09ebab772d7be68506"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">lar::sparse_vector::end_range</a></div><div class="ttdeci">range_const_iterator end_range() const </div><div class="ttdoc">Returns a constant iterator to after the last data range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00760">sparse_vector.h:760</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a525fc33cbd78dd8109f39d66556e36db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-void cells. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01818">1818</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;{</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;  <span class="keywordflow">return</span> std::accumulate(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a2e40940b2813c0f49edb7286c030c002">begin_range</a>(), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">end_range</a>(), <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>(0),</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;    [](<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="code" href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a>, <span class="keyword">const</span> datarange_t&amp; rng) { <span class="keywordflow">return</span> s + rng.size(); }</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;    );</div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;} <span class="comment">// count()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aff5f860ccf8633e81d310ae4b31f7193"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">lar::sparse_vector::size_type</a></div><div class="ttdeci">vector_t::size_type size_type</div><div class="ttdoc">size type </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00476">sparse_vector.h:476</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a2e40940b2813c0f49edb7286c030c002"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a2e40940b2813c0f49edb7286c030c002">lar::sparse_vector::begin_range</a></div><div class="ttdeci">range_const_iterator begin_range() const </div><div class="ttdoc">Returns a constant iterator to the first data range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00757">sparse_vector.h:757</a></div></div>
<div class="ttc" id="file__to__url_8sh_html_a096ad3d3698082826189c839d7a6e46f"><div class="ttname"><a href="../../d0/dea/file__to__url_8sh.html#a096ad3d3698082826189c839d7a6e46f">s</a></div><div class="ttdeci">then echo File list $list not found else cat $list while read file do echo $file sed s</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/file__to__url_8sh_source.html#l00060">file_to_url.sh:60</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ad8cccbfc3bc88c09ebab772d7be68506"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506">lar::sparse_vector::end_range</a></div><div class="ttdeci">range_const_iterator end_range() const </div><div class="ttdoc">Returns a constant iterator to after the last data range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00760">sparse_vector.h:760</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0cf49e7e691b1bd57612df39d62ebc3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::eat_range_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>iRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Voids the starting elements up to index (excluded) of a given range. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02268">2268</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;{</div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;  <span class="keywordflow">if</span> (index &lt;= iRange-&gt;begin_index()) <span class="keywordflow">return</span> iRange;</div>
<div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;  <span class="keywordflow">if</span> (index &gt;= iRange-&gt;end_index()) <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iRange);</div>
<div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;  iRange-&gt;move_head(index);</div>
<div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;  <span class="keywordflow">return</span> iRange;</div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::eat_range_head()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6837d5208aa96a1ac80cc60268f2bf3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is empty. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00565">565</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>() == 0; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a605d6acf5893c79c00f6b7af9eff87a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01755">1755</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  { <span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>, <span class="keyword">typename</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">iterator::special::end</a>()); }</div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7e628d52be31cf9c1bc2fb6891e0c107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d1/d87/classlar_1_1sparse__vector_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01765">1765</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;  { <span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>, <span class="keyword">typename</span> <a class="code" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">const_iterator::special::end</a>()); }</div>
<div class="ttc" id="namespaceicarus_1_1ns_1_1util_html_aac918da84f16d53ad17bab4f817da1c4"><div class="ttname"><a href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">icarus::ns::util::end</a></div><div class="ttdeci">auto end(FixedBins&lt; T, C &gt; const &amp;) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/dbd/FixedBins_8h_source.html#l00585">FixedBins.h:585</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8cccbfc3bc88c09ebab772d7be68506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::end_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to after the last data range. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00760">760</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a37cd5a5710d6a036a9de112b98715424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::expected_vector_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the expected size taken by a vector of specified size. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02288">2288</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;                                                                   {</div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;  <span class="comment">// apparently, a chunk of heap memory takes at least 32 bytes;</span></div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;  <span class="comment">// that means that a vector of 1 or 5 32-bit integers takes the same</span></div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;  <span class="comment">// space; the overhead appears to be 8 bytes, which can be allocated</span></div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a>)</div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;    + std::max(<span class="keywordtype">size_t</span>(32), (<span class="keyword">alignof</span>(datarange_t)*<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a> + 8));</div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::expected_vector_size()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a03fd3f170a77316f9410e181da02beab"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">lar::sparse_vector::vector_t</a></div><div class="ttdeci">std::vector&lt; value_type &gt; vector_t</div><div class="ttdoc">type of STL vector holding this data </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00474">sparse_vector.h:474</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6bf74cfaf702b9d2af69549140875926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_extending_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the range no earlier than <code>index</code>, or <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end()</a></code> if none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the absolute index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the range including index, or the next range if none</dd></dl>
<p>The returned iterator points to a range that "borders" the specified index, meaning that the cell at <code>index</code> is either within the range, or it is the one immediately after that range. If <code>index</code> is in the middle of the void, though (i.e. if the previous cell is void), the next range is returned instead. Finally, if there is no next range, <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506" title="Returns a constant iterator to after the last data range. ">end_range()</a></code> is returned.</p>
<p>The result may be also interpreted as follow: if the start of the returned range is lower than <code>index</code>, then the cell at <code>index</code> belongs to that range. Otherwise, it initiates its own range (but that range might end up being contiguous to the next(. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01111">1111</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">find_extending_range_iter</a>(index, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a6bf74cfaf702b9d2af69549140875926"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">lar::sparse_vector::find_extending_range_iter</a></div><div class="ttdeci">range_iterator find_extending_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range no earlier than index, or end() if none. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01111">sparse_vector.h:1111</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af90e93a8c1881c3fc347a843dac91264"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_extending_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01113">1113</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">find_extending_range_iter</a>(index, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.cbegin()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a6bf74cfaf702b9d2af69549140875926"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a6bf74cfaf702b9d2af69549140875926">lar::sparse_vector::find_extending_range_iter</a></div><div class="ttdeci">range_iterator find_extending_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range no earlier than index, or end() if none. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01111">sparse_vector.h:1111</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91544d1adae5ffec3c18a9c10404a288"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_extending_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>rbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the range that contains the first non-void element after <code>index</code>, or <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end()</a></code> if none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the absolute index </td></tr>
    <tr><td class="paramname">rbegin</td><td>consider only from this range on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next range not including index, or <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a></code> if none</dd></dl>
<p>Note that the returned range can contain <code>index</code> as well. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02199">2199</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;{</div>
<div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;  <span class="keyword">auto</span> it = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index, rbegin);</div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;  <span class="comment">// if index were not void, would it belong to the previous range?</span></div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;  <span class="comment">// if so, the previous range is the one we want</span></div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;  <span class="keywordflow">return</span> ((it != rbegin) &amp;&amp; std::prev(it)-&gt;borders(index))? std::prev(it): it;</div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_extending_range_iter()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45a59be28c436bc099ae9c29ca658432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_extending_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td>
          <td class="paramname"><em>rbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02212">2212</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;{</div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;  <span class="keyword">auto</span> it = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index, rbegin);</div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;  <span class="comment">// if index were not void, would it belong to the previous range?</span></div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;  <span class="comment">// if so, the previus range is the one we want</span></div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;  <span class="keywordflow">return</span> ((it != rbegin) &amp;&amp; std::prev(it)-&gt;borders(index))? std::prev(it): it;</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_extending_range_iter() const</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaedbcaaf5709ab6e4d0a014b78c7cfc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_next_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the range after <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the absolute index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next range not including index, or <a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a> if none </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01056">1056</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6cc2c2370f2387dd43cdb4c1727ab3d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_next_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01058">1058</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.cbegin()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a39d2556e9bbf79eefc61ede54e4403e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_next_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>rbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the range after <code>index</code>, or <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a></code> if none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the absolute index </td></tr>
    <tr><td class="paramname">rbegin</td><td>consider only from this range on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next range not including index, or <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a></code> if none </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02150">2150</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;{</div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;  <span class="keywordflow">return</span> std::upper_bound(</div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;    rbegin, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end(), index,</div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    <span class="keyword">typename</span> <a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">datarange_t::less_int_range</a>(<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">datarange_t::less</a>)</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;    );</div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_next_range_iter()</span></div>
<div class="ttc" id="classlar_1_1range__t_html_a88c4d216a52a40426506fd34d4f0c7dd"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">lar::range_t&lt; size_type &gt;::less_int_range</a></div><div class="ttdeci">bool(* less_int_range)(size_type, const range_t &amp;b)</div><div class="ttdoc">Helper type to be used for binary searches. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00279">sparse_vector.h:279</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a19401e6e61b9f0cf850a0196ab899f9c"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">lar::range_t&lt; size_type &gt;::less</a></div><div class="ttdeci">static bool less(const range_t &amp;a, const range_t &amp;b)</div><div class="ttdoc">Returns if a is &amp;quot;less&amp;quot; than b. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00270">sparse_vector.h:270</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa9cb673862310be6e67c41738e504d0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_next_range_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a>&#160;</td>
          <td class="paramname"><em>rbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02162">2162</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;{</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;  <span class="keywordflow">return</span> std::upper_bound(</div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;    rbegin, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end(), index,</div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;    <span class="keyword">typename</span> <a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">datarange_t::less_int_range</a>(<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">datarange_t::less</a>)</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;    );</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_next_range_iter() const</span></div>
<div class="ttc" id="classlar_1_1range__t_html_a88c4d216a52a40426506fd34d4f0c7dd"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a88c4d216a52a40426506fd34d4f0c7dd">lar::range_t&lt; size_type &gt;::less_int_range</a></div><div class="ttdeci">bool(* less_int_range)(size_type, const range_t &amp;b)</div><div class="ttdoc">Helper type to be used for binary searches. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00279">sparse_vector.h:279</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a19401e6e61b9f0cf850a0196ab899f9c"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a19401e6e61b9f0cf850a0196ab899f9c">lar::range_t&lt; size_type &gt;::less</a></div><div class="ttdeci">static bool less(const range_t &amp;a, const range_t &amp;b)</div><div class="ttdoc">Returns if a is &amp;quot;less&amp;quot; than b. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00270">sparse_vector.h:270</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5bf3ebf7528d621d0bc82c3fd1c7e145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range containing the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>absolute index of the element to be sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the containing range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is in no range (how appropriate!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5f29124d201a74963689f854d9d116e3" title="Returns whether the specified position is void. ">is_void()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01910">1910</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;{</div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;empty sparse vector&quot;</span>);</div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;  <span class="comment">// range on the index:</span></div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#add3367c173b5233dc97417099a391c38">find_range_iterator</a>(index);</div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  <span class="keywordflow">if</span> (iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end())</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;    <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;index in no range of the sparse vector&quot;</span>);</div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;  <span class="keywordflow">return</span> *iNextRange;</div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_range() const</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a7a00801a937328f1596028f4d922d9f7"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">lar::sparse_vector::range_const_iterator</a></div><div class="ttdeci">range_list_t::const_iterator range_const_iterator</div><div class="ttdoc">type of constant iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00498">sparse_vector.h:498</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_add3367c173b5233dc97417099a391c38"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#add3367c173b5233dc97417099a391c38">lar::sparse_vector::find_range_iterator</a></div><div class="ttdeci">range_const_iterator find_range_iterator(size_type index) const </div><div class="ttdoc">Returns an iterator to the range containing the specified index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01897">sparse_vector.h:1897</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a303ac8450a67a2d6c647923f9ec16985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01922">1922</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;{</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>datarange_t&amp;<span class="keyword">&gt;</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;    (<span class="keyword">const_cast&lt;</span><span class="keyword">const </span><a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50ea45eed02e6424fab0c37d5b108cb8">this_t</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a5bf3ebf7528d621d0bc82c3fd1c7e145">find_range</a>(index));</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_range()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a50ea45eed02e6424fab0c37d5b108cb8"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a50ea45eed02e6424fab0c37d5b108cb8">lar::sparse_vector::this_t</a></div><div class="ttdeci">sparse_vector&lt; T &gt; this_t</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00468">sparse_vector.h:468</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a5bf3ebf7528d621d0bc82c3fd1c7e145"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a5bf3ebf7528d621d0bc82c3fd1c7e145">lar::sparse_vector::find_range</a></div><div class="ttdeci">const datarange_t &amp; find_range(size_type index) const </div><div class="ttdoc">Returns the range containing the specified index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01910">sparse_vector.h:1910</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a612885c6f6e1b94c3d21c5627035a613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range_iter_at_or_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the range at or after <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the absolute index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next range including index or after it, or <a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a> if none </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0" title="Returns an iterator to the range after index. ">find_next_range_iter()</a></code></dd></dl>
<p>If <code>index</code> is in a range, an iterator to that range is returned. If <code>index</code> is in the void, an iterator to the next range after <code>index</code> is returned. If there is no such range after <code>index</code>, <code><a class="el" href="../../d5/d62/namespaceicarus_1_1ns_1_1util.html#aac918da84f16d53ad17bab4f817da1c4">ranges.end()</a></code> is returned. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02186">2186</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;{</div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;  <span class="keyword">auto</span> after = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;  <span class="comment">// if the previous range exists and contains index, that&#39;s the one we want</span></div>
<div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;  <span class="keywordflow">return</span> ((after != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) &amp;&amp; (index &lt; std::prev(after)-&gt;end_index()))</div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;    ? std::prev(after): after;</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_range_iter_at_or_after()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a33352c966e01d9217fefe1db448c844f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range_iter_at_or_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02174">2174</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;{</div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;  <span class="comment">// this range has the offset (first index) above the index argument:</span></div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;  <span class="keyword">auto</span> after = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;  <span class="comment">// if the previous range exists and contains index, that&#39;s the one we want</span></div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;  <span class="keywordflow">return</span> ((after != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) &amp;&amp; (index &lt; std::prev(after)-&gt;end_index()))</div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;    ? std::prev(after): after;</div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_range_iter_at_or_after() const</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="add3367c173b5233dc97417099a391c38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the range containing the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>absolute index of the element to be sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to containing range, or <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d9b2860eee2156fe59ba0ce4f0f1393" title="Returns the internal list of non-void ranges. ">get_ranges()</a>.<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a605d6acf5893c79c00f6b7af9eff87a8">end()</a> if in void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is not in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5f29124d201a74963689f854d9d116e3" title="Returns whether the specified position is void. ">is_void()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01897">1897</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;{</div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty()) <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;empty sparse vector&quot;</span>);</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;  <span class="comment">// range after the index:</span></div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;  <span class="keywordflow">return</span> ((iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin())</div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;    || (index &gt;= (--iNextRange)-&gt;end_index()))?</div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end(): iNextRange;</div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::find_range_iterator() const</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a7a00801a937328f1596028f4d922d9f7"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">lar::sparse_vector::range_const_iterator</a></div><div class="ttdeci">range_list_t::const_iterator range_const_iterator</div><div class="ttdoc">type of constant iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00498">sparse_vector.h:498</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeaba539e85668bb66aadd4d0f92f8028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00772">772</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin() + <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a0d07dbbbe294ddfde8436813215e9a90">find_range_number</a>(index); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a0d07dbbbe294ddfde8436813215e9a90"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a0d07dbbbe294ddfde8436813215e9a90">lar::sparse_vector::find_range_number</a></div><div class="ttdeci">std::size_t find_range_number(size_type index) const </div><div class="ttdoc">Returns the number (0-based) of range containing index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00783">sparse_vector.h:783</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d07dbbbe294ddfde8436813215e9a90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::find_range_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number (0-based) of range containing <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>absolute index of the element to be sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of containing range, or <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a08fec1c084eb6c81222b4048bdf98bf1" title="Returns the internal list of non-void ranges. ">n_ranges()</a></code> if in void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is not in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a5f29124d201a74963689f854d9d116e3" title="Returns whether the specified position is void. ">is_void()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00783">783</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#add3367c173b5233dc97417099a391c38">find_range_iterator</a>(index) - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a2e40940b2813c0f49edb7286c030c002">begin_range</a>(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a2e40940b2813c0f49edb7286c030c002"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a2e40940b2813c0f49edb7286c030c002">lar::sparse_vector::begin_range</a></div><div class="ttdeci">range_const_iterator begin_range() const </div><div class="ttdoc">Returns a constant iterator to the first data range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00757">sparse_vector.h:757</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_add3367c173b5233dc97417099a391c38"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#add3367c173b5233dc97417099a391c38">lar::sparse_vector::find_range_iterator</a></div><div class="ttdeci">range_const_iterator find_range_iterator(size_type index) const </div><div class="ttdoc">Returns an iterator to the range containing the specified index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01897">sparse_vector.h:1897</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a83ce75327d4c700ab4d9436f7c117603"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::fix_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the vector size according to the last range. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02278">2278</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;                                                                    {</div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty())</div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = std::max(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().end_index());</div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>;</div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::fix_size()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8d9b2860eee2156fe59ba0ce4f0f1393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::get_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal list of non-void ranges. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00717">717</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac5cd9fcb98d27580e372ea6c222ada3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::insert_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>iInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plug a new data range in the specified position; no check performed. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01140">1140</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    { <span class="keywordflow">return</span> data.empty()? iInsert: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.insert(iInsert, data); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a836c7efbdd028833bf07de76870476d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::insert_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>iInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01142">1142</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    { <span class="keywordflow">return</span> data.empty()? iInsert: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.insert(iInsert, std::move(data)); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a982494b6d02fc56ce33d6ef8a36c1d9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether two values are the same. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01020">1020</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">is_zero</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">abs</a>(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> - b)); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ad7e095c2127eccb0cfa75e756346f967"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">lar::sparse_vector::abs</a></div><div class="ttdeci">static value_type abs(value_type v)</div><div class="ttdoc">Returns the module of the specified value. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01010">sparse_vector.h:1010</a></div></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a27b17772d1ca521f6a9c356e5bb6e8fd"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">lar::sparse_vector::is_zero</a></div><div class="ttdeci">static value_type is_zero(value_type v)</div><div class="ttdoc">Returns whether the value is exactly zero. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01013">sparse_vector.h:1013</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3c22909cc03b2c673fa2598f918bb0ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether two values are the same below a given threshold. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01024">1024</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">is_zero</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">abs</a>(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> - b), thr); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ad7e095c2127eccb0cfa75e756346f967"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">lar::sparse_vector::abs</a></div><div class="ttdeci">static value_type abs(value_type v)</div><div class="ttdoc">Returns the module of the specified value. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01010">sparse_vector.h:1010</a></div></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a27b17772d1ca521f6a9c356e5bb6e8fd"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">lar::sparse_vector::is_zero</a></div><div class="ttdeci">static value_type is_zero(value_type v)</div><div class="ttdoc">Returns whether the value is exactly zero. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01013">sparse_vector.h:1013</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78cc1825604220d6da755cbf3d0becfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the vector is in a valid state. </p>
<p>The vector is in a valid state if:</p>
<ul>
<li>no ranges overlap or touch each other (a void gap must exist)</li>
<li>no range is empty</li>
<li>all ranges are sorted</li>
<li>the size of the vector is not smaller than the sum of the size of the ranges plus the internal gaps An invalid state can be the result of &ldquo;too smart&rdquo; use of this class, or of a bug, which should be reported to the author. </li>
</ul>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02126">2126</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;                                         {</div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;  <span class="comment">// a sparse vector with no non-null elements can&#39;t be detected invalid</span></div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;</div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iNext = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin(), rend = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end();</div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;  <span class="keywordflow">while</span> (iNext != rend) {</div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iRange = iNext++;</div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;    <span class="keywordflow">if</span> (iRange-&gt;empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;    <span class="keywordflow">if</span> (iNext != rend) {</div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;      <span class="keywordflow">if</span> (!(*iRange &lt; *iNext)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;      <span class="keywordflow">if</span> (!iRange-&gt;separate(*iNext)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;    }</div>
<div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().end_index()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::is_valid()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a7a00801a937328f1596028f4d922d9f7"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">lar::sparse_vector::range_const_iterator</a></div><div class="ttdeci">range_list_t::const_iterator range_const_iterator</div><div class="ttdoc">type of constant iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00498">sparse_vector.h:498</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5f29124d201a74963689f854d9d116e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_void </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified position is void. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the cell to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>if index is not in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>is_back_void() </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01807">1807</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;                                                       {</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty() || (index &gt;= <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()))</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;    <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;empty sparse vector&quot;</span>);</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;  <span class="comment">// range after the index:</span></div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;  <span class="keywordflow">return</span> ((iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin())</div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;    || ((--iNextRange)-&gt;end_index() &lt;= index));</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::is_void()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a7a00801a937328f1596028f4d922d9f7"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">lar::sparse_vector::range_const_iterator</a></div><div class="ttdeci">range_list_t::const_iterator range_const_iterator</div><div class="ttdoc">type of constant iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00498">sparse_vector.h:498</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27b17772d1ca521f6a9c356e5bb6e8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the value is exactly zero. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01013">1013</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;{ <span class="keywordflow">return</span> v == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a50130760506a7ce9b22e07a477975cf5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">lar::sparse_vector::value_zero</a></div><div class="ttdeci">static constexpr value_type value_zero</div><div class="ttdoc">a representation of 0 </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01007">sparse_vector.h:1007</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab1c760e2fd9a0f4b8e48f6f57ddecb0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::is_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the value is zero below a given threshold. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01016">1016</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">abs</a>(v - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>) &lt;= thr; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ad7e095c2127eccb0cfa75e756346f967"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ad7e095c2127eccb0cfa75e756346f967">lar::sparse_vector::abs</a></div><div class="ttdeci">static value_type abs(value_type v)</div><div class="ttdoc">Returns the module of the specified value. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01010">sparse_vector.h:1010</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a50130760506a7ce9b22e07a477975cf5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">lar::sparse_vector::value_zero</a></div><div class="ttdeci">static constexpr value_type value_zero</div><div class="ttdoc">a representation of 0 </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01007">sparse_vector.h:1007</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a67d9bb1988e77f27a272f524efab07c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::iterate_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d0e1051d54a9c7659d56286ade361d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::make_void </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d13/classlar_1_1sparse__vector_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes all the elements from first and before last void. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02069">2069</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;                                                                 {</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;  <span class="comment">// iterators have in &quot;currentRange&quot; either the range they point into,</span></div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;  <span class="comment">// or the range next to the void they point to</span></div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;</div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;  <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>.cont != <span class="keyword">this</span>) || (last.cont != <span class="keyword">this</span>)) {</div>
<div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;    <span class="keywordflow">throw</span> std::runtime_error</div>
<div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;      (<span class="stringliteral">&quot;lar::sparse_vector::make_void(): iterators from alien container&quot;</span>);</div>
<div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;  }</div>
<div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;  <span class="comment">// if first is after next, no range is identified</span></div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a> &gt;= last) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a></div>
<div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;    first_range</div>
<div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;      = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin() + (<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>.get_current_range() - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()),</div>
<div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;    last_range = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin() + (last.get_current_range() - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin());</div>
<div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;</div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;  <span class="comment">//--- &quot;first&quot;: void up to this iterator ---</span></div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;  <span class="comment">// if first in the last void region, there is nothing to erase</span></div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;  <span class="keywordflow">if</span> (first_range == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end()) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;</div>
<div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;  <span class="comment">// if first is in the middle of a valid range instead, we have to resize it</span></div>
<div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>.index &gt; first_range-&gt;begin_index()) {</div>
<div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;    <span class="keywordflow">if</span> (first_range == last_range) {</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;      <span class="comment">// we are going to erase a subset of a range;</span></div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;      <span class="comment">// this effectively creates two ranges;</span></div>
<div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;      <span class="comment">// first create the rightmost (last) range, and add it to the list</span></div>
<div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;      last_range = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.emplace(++last_range, last.index,</div>
<div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;        first_range-&gt;begin() + first_range-&gt;relative_index(last.index),</div>
<div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;        first_range-&gt;end()</div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;        );</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;      <span class="comment">// then cut the existing one</span></div>
<div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;      first_range-&gt;move_tail(<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>.index);</div>
<div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;    }</div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;    first_range-&gt;move_tail(<a class="code" href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">first</a>.index);</div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;    ++first_range; <span class="comment">// from next range on, start voiding</span></div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;  }</div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;</div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;  <span class="comment">//--- &quot;last&quot;</span></div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;  <span class="comment">// if the index is inside a range, remove up to it</span></div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;  <span class="keywordflow">if</span> ((last_range != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end()) &amp;&amp; (last.index &gt; last_range-&gt;begin_index()))</div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a0cf49e7e691b1bd57612df39d62ebc3a">eat_range_head</a>(last_range, last.index);</div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;</div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;  <span class="comment">// finally, remove entirely the ranges in between</span></div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(first_range, last_range);</div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::make_void()</span></div>
<div class="ttc" id="namespacechannelDBConverter_html_af481fa22253619167bce75a37e10ec34"><div class="ttname"><a href="../../d4/d43/namespacechannelDBConverter.html#af481fa22253619167bce75a37e10ec34">channelDBConverter.first</a></div><div class="ttdeci">first</div><div class="ttdef"><b>Definition:</b> <a href="../../db/d11/channelDBConverter_8py_source.html#l00146">channelDBConverter.py:146</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a0cf49e7e691b1bd57612df39d62ebc3a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a0cf49e7e691b1bd57612df39d62ebc3a">lar::sparse_vector::eat_range_head</a></div><div class="ttdeci">range_iterator eat_range_head(range_iterator iRange, size_t index)</div><div class="ttdoc">Voids the starting elements up to index (excluded) of a given range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02268">sparse_vector.h:2268</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d0bf47147e0ec187adf7302867b53c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::make_void_around </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the whole range with the specified item into the void. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>absolute index of the element whose range is cast to void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range just voided </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is not in the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>unset(), <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a4d0e1051d54a9c7659d56286ade361d3" title="Makes all the elements from first and before last void. ">make_void()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01930">1930</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;                                                                         {</div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty() || (index &gt;= <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()))</div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;    <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;empty sparse vector&quot;</span>);</div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;  <span class="comment">// range after the index:</span></div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;  <span class="keywordflow">if</span> ((iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin())</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;    || ((--iNextRange)-&gt;end_index() &lt;= index))</div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;  {</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;    <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;  }</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aded208488fdad5031c60a1c5bf4295e8">void_range</a>(iNextRange);</div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::make_void_around()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aded208488fdad5031c60a1c5bf4295e8"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aded208488fdad5031c60a1c5bf4295e8">lar::sparse_vector::void_range</a></div><div class="ttdeci">datarange_t void_range(range_iterator const iRange)</div><div class="ttdoc">Turns the specified range into void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02118">sparse_vector.h:2118</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc8350ed0e31212fd3373171a290ebba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::merge_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a>&#160;</td>
          <td class="paramname"><em>iRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges all the following contiguous ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iRange</td><td>iterator to the range to merge the following ones into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the merged range</dd></dl>
<p>Starting from the range next to <code>iRange</code>, if that range is contiguous to <code>iRange</code> the two are merged. The merging continues while there are ranges contiguous to <code>iRange</code>. In the end, an iterator is returned pointing to a range that has the same starting point that <code>iRange</code> had, and that is not followed by a contiuguous range, since all contiguous ranges have been merged into it. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02248">2248</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;{</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iNext = iRange + 1;</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;  <span class="keywordflow">while</span> (iNext != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end()) {</div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;    <span class="keywordflow">if</span> (!iRange-&gt;borders(iNext-&gt;begin_index())) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;    <span class="comment">// iRange content dominates, but if iNext has data beyond it,</span></div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;    <span class="comment">// then we copy it</span></div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;    <span class="keywordflow">if</span> (iNext-&gt;end_index() &gt; iRange-&gt;end_index()) {</div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;      iRange-&gt;extend</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;        (iRange-&gt;end_index(), iNext-&gt;get_iterator(iRange-&gt;end_index()), iNext-&gt;end());</div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;    }</div>
<div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;    iNext = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iNext);</div>
<div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;  } <span class="comment">// while</span></div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a83ce75327d4c700ab4d9436f7c117603">fix_size</a>();</div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;  <span class="keywordflow">return</span> *iRange;</div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::merge_ranges()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a83ce75327d4c700ab4d9436f7c117603"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a83ce75327d4c700ab4d9436f7c117603">lar::sparse_vector::fix_size</a></div><div class="ttdeci">size_type fix_size()</div><div class="ttdoc">Extends the vector size according to the last range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02278">sparse_vector.h:2278</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af9baa027630c6e45904a903d2c93e095"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::min_gap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum optimal gap between ranges (a guess) </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02298">2298</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;                                           {</div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;  <span class="comment">// we assume here that there is no additional overhead by alignment;</span></div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;  <span class="comment">// the gap adds the space of another datarange_t, including the vector,</span></div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;  <span class="comment">// its data and overhead from heap (apparently, 8 bytes);</span></div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;  <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(datarange_t) + 8) / <span class="keyword">sizeof</span>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>) + 1; <span class="comment">// round up</span></div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::min_gap()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a84ae9b33ffba8b4b2d6e2f840ef12611"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">lar::sparse_vector::value_type</a></div><div class="ttdeci">T value_type</div><div class="ttdoc">type of the stored values </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00473">sparse_vector.h:473</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1e5366c7c622f84f3bb75d685feb2af4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::minimum_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size determined by the ranges already present. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01135">1135</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty()? 0: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().end_index(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a08fec1c084eb6c81222b4048bdf98bf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::n_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal list of non-void ranges. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00721">721</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.size(); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a385ec6a9e12a2b2c8c2c859132eea535"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment: default. </p>

</div>
</div>
<a class="anchor" id="a42fe549730055975c32ebfd1ba150874"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">sparse_vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00534">534</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a> = std::move(<a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.ranges);</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.nominal_size;</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;      <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a>.nominal_size = 0;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    } <span class="comment">// operator= (sparse_vector&amp;&amp;)</span></div>
<div class="ttc" id="testFHiCLfiles_8sh_html_a6401d1c0a168bb3757821ca209161fe2"><div class="ttname"><a href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a></div><div class="ttdeci">exclude from</div><div class="ttdef"><b>Definition:</b> <a href="../../dd/db0/testFHiCLfiles_8sh_source.html#l00347">testFHiCLfiles.sh:347</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ee5f0b30c8bc1959db71dfbf2ffd88a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to an element (read only) </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01770">1770</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;{</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;  <span class="comment">// first range not including the index</span></div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">range_const_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;  <span class="comment">// if not even the first range includes the index, we are in the void</span></div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  <span class="comment">// (or in some negative index space, if index signedness allowed);</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;  <span class="keywordflow">if</span> (iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>;</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;  <span class="comment">// otherwise, let&#39;s take the previous range;</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  <span class="comment">// if it includes the index, we return its value;</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;  <span class="comment">// or it precedes it, and our index is in the void: return zero</span></div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;  <span class="keyword">const</span> datarange_t&amp; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>(*--iNextRange);</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;  <span class="keywordflow">return</span> (index &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>())? <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>[index]: <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">value_zero</a>;</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::operator[]</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8d6650210148fb6cd88b9d47742a44f5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">lar::sparse_vector::range</a></div><div class="ttdeci">const datarange_t &amp; range(size_t i) const </div><div class="ttdoc">Returns the i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00724">sparse_vector.h:724</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a50130760506a7ce9b22e07a477975cf5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a50130760506a7ce9b22e07a477975cf5">lar::sparse_vector::value_zero</a></div><div class="ttdeci">static constexpr value_type value_zero</div><div class="ttdoc">a representation of 0 </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01007">sparse_vector.h:1007</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a9a5b3dd94d4b09dcefe928b135e75e99"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">lar::range_t::end_index</a></div><div class="ttdeci">size_type end_index() const </div><div class="ttdoc">Returns the first absolute index not included in the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00213">sparse_vector.h:213</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a7a00801a937328f1596028f4d922d9f7"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a7a00801a937328f1596028f4d922d9f7">lar::sparse_vector::range_const_iterator</a></div><div class="ttdeci">range_list_t::const_iterator range_const_iterator</div><div class="ttdoc">type of constant iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00498">sparse_vector.h:498</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a524c0c294f1a934273820510bbdf2029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../dd/d6c/classlar_1_1sparse__vector_1_1reference.html">reference</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to an element (read/write for non-void elements only!) </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01789">1789</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;{</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;  <span class="comment">// first range not including the index</span></div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;  <span class="comment">// if not even the first range includes the index, we are in the void</span></div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;  <span class="comment">// (or in some negative index space, if index signedness allowed);</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;  <span class="keywordflow">if</span> (iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) <span class="keywordflow">return</span> reference();</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;  <span class="comment">// otherwise, let&#39;s take the previous range;</span></div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  <span class="comment">// if it includes the index, we return its value;</span></div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;  <span class="comment">// or it precedes it, and our index is in the void: return zero</span></div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;  datarange_t&amp; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>(*--iNextRange);</div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;  <span class="keywordflow">return</span> (index &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>())? reference(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>[index]): reference();</div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::operator[]</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8d6650210148fb6cd88b9d47742a44f5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">lar::sparse_vector::range</a></div><div class="ttdeci">const datarange_t &amp; range(size_t i) const </div><div class="ttdoc">Returns the i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00724">sparse_vector.h:724</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a9a5b3dd94d4b09dcefe928b135e75e99"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">lar::range_t::end_index</a></div><div class="ttdeci">size_type end_index() const </div><div class="ttdoc">Returns the first absolute index not included in the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00213">sparse_vector.h:213</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac173bb6bb0f8f6912f5656e85dae4a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs internal optimization, returns whether the object was changed. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01000">1000</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ac173bb6bb0f8f6912f5656e85dae4a4f">optimize</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#af9baa027630c6e45904a903d2c93e095">min_gap</a>()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_af9baa027630c6e45904a903d2c93e095"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#af9baa027630c6e45904a903d2c93e095">lar::sparse_vector::min_gap</a></div><div class="ttdeci">static size_t min_gap()</div><div class="ttdoc">Minimum optimal gap between ranges (a guess) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02298">sparse_vector.h:2298</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ac173bb6bb0f8f6912f5656e85dae4a4f"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ac173bb6bb0f8f6912f5656e85dae4a4f">lar::sparse_vector::optimize</a></div><div class="ttdeci">bool optimize()</div><div class="ttdoc">Performs internal optimization, returns whether the object was changed. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01000">sparse_vector.h:1000</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa1cdd6f6abddd5e3cfb4ec2ccc3aba4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::optimize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01001">1001</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* no optimization implemented yet */</span> }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afc8cd9f5aef77190e0069e5a3547ffb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds one element to the end of the vector (zero values too) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00642">642</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;{ <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">resize</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>() + 1, <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_af9f87b865ed66c0ae0be183046e47ed9"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">lar::sparse_vector::resize</a></div><div class="ttdeci">void resize(size_type new_size)</div><div class="ttdoc">Resizes the vector to the specified size, adding void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01710">sparse_vector.h:1710</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="pmtsimulation__icarus_8fcl_html_a9fc569190f32b40862f18ac3c03a8e49"><div class="ttname"><a href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></div><div class="ttdeci">temporary value</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d36/pmtsimulation__icarus_8fcl_source.html#l00158">pmtsimulation_icarus.fcl:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad5317d49a11f65ec697fe5a14f1a40c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one element to the end of the vector (if zero, just adds void) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be added </td></tr>
    <tr><td class="paramname">thr</td><td>threshold below which the value is considered zero</td></tr>
  </table>
  </dd>
</dl>
<p>If the threshold is strictly negative, all values are pushed back </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00651">651</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    {</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">is_zero</a>(<a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>, thr)) <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">resize</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>() + 1);</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;      <span class="keywordflow">else</span>                     <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#afc8cd9f5aef77190e0069e5a3547ffb4">push_back</a>(<a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>);</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    } <span class="comment">// push_back()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_af9f87b865ed66c0ae0be183046e47ed9"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">lar::sparse_vector::resize</a></div><div class="ttdeci">void resize(size_type new_size)</div><div class="ttdoc">Resizes the vector to the specified size, adding void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01710">sparse_vector.h:1710</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a27b17772d1ca521f6a9c356e5bb6e8fd"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a27b17772d1ca521f6a9c356e5bb6e8fd">lar::sparse_vector::is_zero</a></div><div class="ttdeci">static value_type is_zero(value_type v)</div><div class="ttdoc">Returns whether the value is exactly zero. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01013">sparse_vector.h:1013</a></div></div>
<div class="ttc" id="pmtsimulation__icarus_8fcl_html_a9fc569190f32b40862f18ac3c03a8e49"><div class="ttname"><a href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></div><div class="ttdeci">temporary value</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d36/pmtsimulation__icarus_8fcl_source.html#l00158">pmtsimulation_icarus.fcl:158</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_afc8cd9f5aef77190e0069e5a3547ffb4"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#afc8cd9f5aef77190e0069e5a3547ffb4">lar::sparse_vector::push_back</a></div><div class="ttdeci">void push_back(value_type value)</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00642">sparse_vector.h:642</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8d6650210148fb6cd88b9d47742a44f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a>&amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the i-th non-void range (zero-based) </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00724">724</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>[i]; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a62814415f5b038505112cdfa1d017103"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::range_const_data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#acdac9efcea1f9b799b9b5be46d5dc613" title="Provides direct access to data of i-th non-void range (zero-based) ">range_data()</a></code> but with explicitly read-only access to data. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01891">1891</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;  { <span class="keyword">auto</span>&amp; <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a> = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>[i]; <span class="keywordflow">return</span> details::iteratorRange(<a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>.cbegin(), <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>.cend()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="condor__lar__pubs_8sh_html_aace24c54f354f24f1dec3b4fd3a15d10"><div class="ttname"><a href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a></div><div class="ttdeci">esac echo uname r</div><div class="ttdef"><b>Definition:</b> <a href="../../da/dc6/condor__lar__pubs_8sh_source.html#l00698">condor_lar_pubs.sh:698</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acdac9efcea1f9b799b9b5be46d5dc613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::range_data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides direct access to data of i-th non-void range (zero-based) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object suitable for ranged-for iteration</dd></dl>
<p>No information about the positioning of the range itself is provided, which can be obtained with other means (e.g. <code>range(i).begin_index()</code>). The returned object can be used in a ranged-for loop: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t iRange = 0; iRange &lt; sv.n_ranges(); ++iRange) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>: sv.range_data(iRange)) {</div>
<div class="line">    v *= 2.0;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> (with <code>sv</code> a <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html" title="A sparse vector. ">lar::sparse_vector</a></code> instance).</p>
<p>While this is a somehow clumsier interface than <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d9b2860eee2156fe59ba0ce4f0f1393" title="Returns the internal list of non-void ranges. ">get_ranges()</a></code>, it allows, using the non-<code>const</code> version, write access to the data elements. It intentionally provides no write access to the location of each range, though. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01887">1887</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;  { <span class="keyword">auto</span>&amp; <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a> = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>[i]; <span class="keywordflow">return</span> details::iteratorRange(<a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>.begin(), <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>.end()); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="condor__lar__pubs_8sh_html_aace24c54f354f24f1dec3b4fd3a15d10"><div class="ttname"><a href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a></div><div class="ttdeci">esac echo uname r</div><div class="ttdef"><b>Definition:</b> <a href="../../da/dc6/condor__lar__pubs_8sh_source.html#l00698">condor_lar_pubs.sh:698</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af536700887cf5ecdaf53cbfef2163f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::range_data </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00750">750</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a62814415f5b038505112cdfa1d017103">range_const_data</a>(i); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a62814415f5b038505112cdfa1d017103"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a62814415f5b038505112cdfa1d017103">lar::sparse_vector::range_const_data</a></div><div class="ttdeci">auto range_const_data(std::size_t i) const </div><div class="ttdoc">Like range_data() but with explicitly read-only access to data. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01891">sparse_vector.h:1891</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af9f87b865ed66c0ae0be183046e47ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the vector to the specified size, adding void. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01710">1710</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;                                                   {</div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;  <span class="keywordflow">if</span> (new_size &gt;= <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()) {</div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = new_size;</div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;  }</div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;</div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;  <span class="comment">// truncating...</span></div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iLastRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(new_size);</div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iLastRange, <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end());</div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.empty()) {</div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iLastRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.end() - 1;</div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;    <span class="keywordflow">if</span> (new_size == iLastRange-&gt;begin_index())</div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iLastRange);</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_size &lt; iLastRange-&gt;end_index())</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;      iLastRange-&gt;resize(new_size - iLastRange-&gt;begin_index());</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;  } <span class="comment">// if we have ranges</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;  <span class="comment">// formally resize</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = new_size;</div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::resize()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad997fce3154d9115993a1301b3b9e4e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>def_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the vector to the specified size, adding def_value. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01733">1733</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;                                                                         {</div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;  <span class="keywordflow">if</span> (new_size == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;  <span class="keywordflow">if</span> (new_size &gt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>()) {</div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aeea706e34c1aaea8a9739419f2f4301c">back_is_void</a>()) <span class="comment">// add a new range</span></div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">append</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">vector_t</a>(new_size - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">size</a>(), def_value));</div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;    <span class="keywordflow">else</span> <span class="comment">// extend the last range</span></div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().resize(new_size - <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.back().begin_index(), def_value);</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;</div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a> = new_size;</div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;  }</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;  <span class="comment">// truncating is the same whether there is a default value or not</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">resize</a>(new_size);</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::resize()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a03fd3f170a77316f9410e181da02beab"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a03fd3f170a77316f9410e181da02beab">lar::sparse_vector::vector_t</a></div><div class="ttdeci">std::vector&lt; value_type &gt; vector_t</div><div class="ttdoc">type of STL vector holding this data </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00474">sparse_vector.h:474</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_af9f87b865ed66c0ae0be183046e47ed9"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#af9f87b865ed66c0ae0be183046e47ed9">lar::sparse_vector::resize</a></div><div class="ttdeci">void resize(size_type new_size)</div><div class="ttdoc">Resizes the vector to the specified size, adding void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01710">sparse_vector.h:1710</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_ae239eda30fd10129f2213f09549ee09a"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#ae239eda30fd10129f2213f09549ee09a">lar::sparse_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00562">sparse_vector.h:562</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aeea706e34c1aaea8a9739419f2f4301c"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aeea706e34c1aaea8a9739419f2f4301c">lar::sparse_vector::back_is_void</a></div><div class="ttdeci">bool back_is_void() const </div><div class="ttdoc">Returns whether the sparse vector ends with void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00612">sparse_vector.h:612</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a5da11d38aaae9a6c818c9d0cf8d3c50d"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a5da11d38aaae9a6c818c9d0cf8d3c50d">lar::sparse_vector::append</a></div><div class="ttdeci">const datarange_t &amp; append(ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range at the end of the vector. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00927">sparse_vector.h:927</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad85e95c62868cd7027d94526bf77037d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> &amp; <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::set_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes into an element (creating or expanding a range if needed) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the element to set </td></tr>
    <tr><td class="paramname">value</td><td>the value to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the changed value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac45f761fde6de417b32d640fa84bc5a7" title="Casts the element with the specified index into the void. ">unset_at()</a></dd></dl>
<p>Note that setting the value to zero will not cast the element into void. Use unset_at for that. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01829">1829</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;{</div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;  <span class="comment">// first range not including the index</span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;  <span class="comment">// if not even the first range includes the index, we are in the void</span></div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;  <span class="comment">// (or in some negative index space, if index signedness allowed);</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;  <span class="keywordflow">if</span> (iNextRange != <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) {</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;    <span class="comment">// otherwise, let&#39;s take the previous range;</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;    <span class="comment">// if it includes the index, we set the existing value;</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;    <span class="comment">// or it precedes it, and our index is in the void, add the value as a</span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;    <span class="comment">// range</span></div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;    datarange_t&amp; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>(*std::prev(iNextRange));</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;    <span class="keywordflow">if</span> (index &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>()) <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>[index] = <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a>;</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;  }</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;  <span class="comment">// so we are in the void; add the value as a new range</span></div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>datarange_t&amp;<span class="keyword">&gt;</span>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">add_range</a>(index, { <a class="code" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a> }))[index];</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::set_at()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8d6650210148fb6cd88b9d47742a44f5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">lar::sparse_vector::range</a></div><div class="ttdeci">const datarange_t &amp; range(size_t i) const </div><div class="ttdoc">Returns the i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00724">sparse_vector.h:724</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a234e1a7d10a4225b66209e2d14365f27"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a234e1a7d10a4225b66209e2d14365f27">lar::sparse_vector::add_range</a></div><div class="ttdeci">const datarange_t &amp; add_range(size_type offset, ITER first, ITER last)</div><div class="ttdoc">Adds a sequence of elements as a range with specified offset. </div></div>
<div class="ttc" id="classlar_1_1range__t_html_a9a5b3dd94d4b09dcefe928b135e75e99"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">lar::range_t::end_index</a></div><div class="ttdeci">size_type end_index() const </div><div class="ttdoc">Returns the first absolute index not included in the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00213">sparse_vector.h:213</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
<div class="ttc" id="pmtsimulation__icarus_8fcl_html_a9fc569190f32b40862f18ac3c03a8e49"><div class="ttname"><a href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></div><div class="ttdeci">temporary value</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d36/pmtsimulation__icarus_8fcl_source.html#l00158">pmtsimulation_icarus.fcl:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a406f4982869328a7bc4a6ad7fa5da2df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::should_merge </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#adb944680f136f906e00e58a73a7f27bc">datarange_t::base_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#adb944680f136f906e00e58a73a7f27bc">datarange_t::base_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if merging the two specified ranges would save memory. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02308">2308</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;{</div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> gap_size = (<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a> &lt; b)?</div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;    b.begin_index() - <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.begin_index() - <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.size():</div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;    <a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.begin_index() - b.begin_index() - b.size();</div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a37cd5a5710d6a036a9de112b98715424">expected_vector_size</a>(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.size() + b.size() + gap_size)</div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;    &lt;= <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a37cd5a5710d6a036a9de112b98715424">expected_vector_size</a>(<a class="code" href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a>.size()) + <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a37cd5a5710d6a036a9de112b98715424">expected_vector_size</a>(b.size());</div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::should_merge()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a37cd5a5710d6a036a9de112b98715424"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a37cd5a5710d6a036a9de112b98715424">lar::sparse_vector::expected_vector_size</a></div><div class="ttdeci">static size_t expected_vector_size(size_t size)</div><div class="ttdoc">Returns the expected size taken by a vector of specified size. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02288">sparse_vector.h:2288</a></div></div>
<div class="ttc" id="decode__signalprocess__icarus_8fcl_html_a2a105cb669129f9c63eb7a4c15bf2d9b"><div class="ttname"><a href="../../d0/d8f/decode__signalprocess__icarus_8fcl.html#a2a105cb669129f9c63eb7a4c15bf2d9b">a</a></div><div class="ttdeci">process_name gaushit a</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d8f/decode__signalprocess__icarus_8fcl_source.html#l00037">decode_signalprocess_icarus.fcl:37</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aff5f860ccf8633e81d310ae4b31f7193"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">lar::sparse_vector::size_type</a></div><div class="ttdeci">vector_t::size_type size_type</div><div class="ttdoc">size type </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00476">sparse_vector.h:476</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae239eda30fd10129f2213f09549ee09a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the vector. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00562">562</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">nominal_size</a>; }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8957361aeb2d633e2d4d2a3ae61e259b"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8957361aeb2d633e2d4d2a3ae61e259b">lar::sparse_vector::nominal_size</a></div><div class="ttdeci">size_type nominal_size</div><div class="ttdoc">current size </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01046">sparse_vector.h:1046</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac45f761fde6de417b32d640fa84bc5a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::unset_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the element with the specified index into the void. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01850">1850</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;                                                  {</div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;  <span class="comment">// first range not including the index</span></div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> iNextRange = <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">find_next_range_iter</a>(index);</div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;</div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;  <span class="comment">// if not even the first range includes the index, we are in the void</span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;  <span class="comment">// (or in some negative index space, if index signedness allowed);</span></div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;  <span class="keywordflow">if</span> (iNextRange == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin()) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;  <span class="comment">// otherwise, let&#39;s take the previous range;</span></div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;  <span class="comment">// or it precedes the index, and our index is in the void</span></div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;  datarange_t&amp; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>(*--iNextRange);</div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;  <span class="keywordflow">if</span> (index &gt;= <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>()) <span class="keywordflow">return</span>; <span class="comment">// void already</span></div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;</div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;  <span class="comment">// it includes the index:</span></div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;  <span class="comment">// - if it&#39;s a one-element range, remove the range</span></div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a482df4edc3c71638bdce4f02e66a8b5f">size</a>() == 1) <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iNextRange);</div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;  <span class="comment">// - if it&#39;s on a border, resize the range</span></div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a10e0798d5351e6238e0287a2ebc474d6">begin_index</a>())</div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a432da6514fb804258cbb0dc26f5bf276">move_head</a>(index + 1);</div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index == <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>() - 1)</div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a392e7739ef3beb95ecc02d50283b8d2b">move_tail</a>(index);</div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;  <span class="comment">// - if it&#39;s inside, break the range in two</span></div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index &lt; <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">end_index</a>()) {</div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;    <span class="comment">// we are going to put a hole in a range;</span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;    <span class="comment">// this effectively creates two ranges;</span></div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;    <span class="comment">// first create the rightmost range, and add it to the list</span></div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.emplace(++iNextRange, index + 1,</div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#ab29318dd8e4969f6e7387d2bb2482012">begin</a>() + <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d8/d7d/classlar_1_1range__t.html#adf99bba72e9becebe7267c09fea09c31">relative_index</a>(index + 1),</div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;      <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a6e35f115f548c37f2166ad14015149c5">end</a>()</div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;      );</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;    <span class="comment">// then cut the existing one</span></div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;    <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">range</a>.<a class="code" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a392e7739ef3beb95ecc02d50283b8d2b">move_tail</a>(index);</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;  }</div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::unset_at()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_a8d6650210148fb6cd88b9d47742a44f5"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#a8d6650210148fb6cd88b9d47742a44f5">lar::sparse_vector::range</a></div><div class="ttdeci">const datarange_t &amp; range(size_t i) const </div><div class="ttdoc">Returns the i-th non-void range (zero-based) </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00724">sparse_vector.h:724</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a10e0798d5351e6238e0287a2ebc474d6"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a10e0798d5351e6238e0287a2ebc474d6">lar::range_t::begin_index</a></div><div class="ttdeci">size_type begin_index() const </div><div class="ttdoc">Returns the first absolute index included in the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00210">sparse_vector.h:210</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_1_1datarange__t_html_a392e7739ef3beb95ecc02d50283b8d2b"><div class="ttname"><a href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a392e7739ef3beb95ecc02d50283b8d2b">lar::sparse_vector::datarange_t::move_tail</a></div><div class="ttdeci">void move_tail(size_type to_index, value_type def_value=value_zero)</div><div class="ttdoc">Moves the end of this range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01293">sparse_vector.h:1293</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a9a5b3dd94d4b09dcefe928b135e75e99"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a9a5b3dd94d4b09dcefe928b135e75e99">lar::range_t::end_index</a></div><div class="ttdeci">size_type end_index() const </div><div class="ttdoc">Returns the first absolute index not included in the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00213">sparse_vector.h:213</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aaedbcaaf5709ab6e4d0a014b78c7cfc0"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aaedbcaaf5709ab6e4d0a014b78c7cfc0">lar::sparse_vector::find_next_range_iter</a></div><div class="ttdeci">range_iterator find_next_range_iter(size_type index)</div><div class="ttdoc">Returns an iterator to the range after index. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01056">sparse_vector.h:1056</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_1_1datarange__t_html_a432da6514fb804258cbb0dc26f5bf276"><div class="ttname"><a href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a432da6514fb804258cbb0dc26f5bf276">lar::sparse_vector::datarange_t::move_head</a></div><div class="ttdeci">void move_head(size_type to_index, value_type def_value=value_zero)</div><div class="ttdoc">Moves the begin of this range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02366">sparse_vector.h:2366</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_a482df4edc3c71638bdce4f02e66a8b5f"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#a482df4edc3c71638bdce4f02e66a8b5f">lar::range_t::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Returns the size of the range. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00219">sparse_vector.h:219</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aedfebe294b81a209189dd13bc11b2aeb"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">lar::sparse_vector::range_iterator</a></div><div class="ttdeci">range_list_t::iterator range_iterator</div><div class="ttdoc">type of iterator over ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00496">sparse_vector.h:496</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_1_1datarange__t_html_ab29318dd8e4969f6e7387d2bb2482012"><div class="ttname"><a href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#ab29318dd8e4969f6e7387d2bb2482012">lar::sparse_vector::datarange_t::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">begin and end iterators </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01240">sparse_vector.h:1240</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_1_1datarange__t_html_a6e35f115f548c37f2166ad14015149c5"><div class="ttname"><a href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html#a6e35f115f548c37f2166ad14015149c5">lar::sparse_vector::datarange_t::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01241">sparse_vector.h:1241</a></div></div>
<div class="ttc" id="classlar_1_1range__t_html_adf99bba72e9becebe7267c09fea09c31"><div class="ttname"><a href="../../d8/d7d/classlar_1_1range__t.html#adf99bba72e9becebe7267c09fea09c31">lar::range_t::relative_index</a></div><div class="ttdeci">size_type relative_index(size_type index) const </div><div class="ttdoc">Returns the position within the range of the absolute index specified. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l00216">sparse_vector.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aded208488fdad5031c60a1c5bf4295e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::void_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aedfebe294b81a209189dd13bc11b2aeb">range_iterator</a> const&#160;</td>
          <td class="paramname"><em>iRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the specified range into void. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iRange</td><td>iterator or index of range to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range just voided </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a4d0e1051d54a9c7659d56286ade361d3" title="Makes all the elements from first and before last void. ">make_void()</a>, <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ac45f761fde6de417b32d640fa84bc5a7" title="Casts the element with the specified index into the void. ">unset_at()</a></dd></dl>
<p>The range is effectively removed from the sparse vector, rendering void the interval it previously covered. The range object itself is returned (no copy is performed).</p>
<p>The specified range must be valid. Trying to void an invalid range (including <code><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#ad8cccbfc3bc88c09ebab772d7be68506" title="Returns a constant iterator to after the last data range. ">end_range()</a></code>) yields undefined behavior. </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l02118">2118</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;                                                                         {</div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;  <span class="keyword">auto</span> <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a> { std::move(*iRange) }; <span class="comment">// triggering move constructor</span></div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;  <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.erase(iRange);          <span class="comment">// the emptied range is removed from vector</span></div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a>;                      <span class="comment">// returning it as a temporary avoids copies</span></div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;} <span class="comment">// lar::sparse_vector&lt;T&gt;::void_range()</span></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="condor__lar__pubs_8sh_html_aace24c54f354f24f1dec3b4fd3a15d10"><div class="ttname"><a href="../../da/dc6/condor__lar__pubs_8sh.html#aace24c54f354f24f1dec3b4fd3a15d10">r</a></div><div class="ttdeci">esac echo uname r</div><div class="ttdef"><b>Definition:</b> <a href="../../da/dc6/condor__lar__pubs_8sh_source.html#l00698">condor_lar_pubs.sh:698</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7eef29eb10c2c2847844eff6aeb2b84a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dcc/classlar_1_1sparse__vector_1_1datarange__t.html">datarange_t</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::void_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>iRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l00973">973</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#aded208488fdad5031c60a1c5bf4295e8">void_range</a>(<a class="code" href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">ranges</a>.begin() + iRange); }</div>
<div class="ttc" id="classlar_1_1sparse__vector_html_adcc90eb32e8136221b52fa539a7ef3df"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#adcc90eb32e8136221b52fa539a7ef3df">lar::sparse_vector::ranges</a></div><div class="ttdeci">range_list_t ranges</div><div class="ttdoc">list of ranges </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l01047">sparse_vector.h:1047</a></div></div>
<div class="ttc" id="classlar_1_1sparse__vector_html_aded208488fdad5031c60a1c5bf4295e8"><div class="ttname"><a href="../../d4/da5/classlar_1_1sparse__vector.html#aded208488fdad5031c60a1c5bf4295e8">lar::sparse_vector::void_range</a></div><div class="ttdeci">datarange_t void_range(range_iterator const iRange)</div><div class="ttdoc">Turns the specified range into void. </div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d5b/sparse__vector_8h_source.html#l02118">sparse_vector.h:2118</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8957361aeb2d633e2d4d2a3ae61e259b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#aff5f860ccf8633e81d310ae4b31f7193">size_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::nominal_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current size </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01046">1046</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="adcc90eb32e8136221b52fa539a7ef3df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a8a59b371c390784a0f7206929e4c13cd">range_list_t</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::ranges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>list of ranges </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01047">1047</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a50130760506a7ce9b22e07a477975cf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::<a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html#a84ae9b33ffba8b4b2d6e2f840ef12611">value_type</a> <a class="el" href="../../d4/da5/classlar_1_1sparse__vector.html">lar::sparse_vector</a>&lt; T &gt;::value_zero {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a representation of 0 </p>

<p>Definition at line <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html#l01007">1007</a> of file <a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d1/d5b/sparse__vector_8h_source.html">sparse_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
