<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Simple utility traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Simple utility traits<div class="ingroups"><a class="el" href="../../d0/d85/group__Metaprogramming.html">General utilities for metaprogramming</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple traits for the implementation of other traits.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:de/df8/namespaceutil_1_1details"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/namespaceutil_1_1details.html">util::details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d02/structutil_1_1self__type.html">util::self_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait returning the very same type as in the template argument.  <a href="../../d9/d02/structutil_1_1self__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/structutil_1_1always__false__type.html">util::always_false_type&lt; typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::false_type</code> with a template argument.  <a href="../../da/d94/structutil_1_1always__false__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd1/structutil_1_1always__true__type.html">util::always_true_type&lt; typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::true_type</code> with a template argument.  <a href="../../d4/dd1/structutil_1_1always__true__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d02/structutil_1_1find__next__type.html">util::find_next_type&lt; T, StartFrom, Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: index of the first occurrence of <code>T</code> among the specified <code>Types</code>, starting from the one with index <code>StartFrom</code>.  <a href="../../d9/d02/structutil_1_1find__next__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d95/structutil_1_1is__any__of.html">util::is_any_of&lt; T, Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: whether <code>T</code> is among the specified <code>Types</code>.  <a href="../../d7/d95/structutil_1_1is__any__of.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad92e74901a6fa461ce0ccbd97c445928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad92e74901a6fa461ce0ccbd97c445928"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gad92e74901a6fa461ce0ccbd97c445928">util::self_t</a> = typename self_type&lt; T &gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:gad92e74901a6fa461ce0ccbd97c445928"><td class="mdescLeft">&#160;</td><td class="mdescRight">The very same type as in the template argument.  <a href="#gad92e74901a6fa461ce0ccbd97c445928">More...</a><br/></td></tr>
<tr class="separator:gad92e74901a6fa461ce0ccbd97c445928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ec377e9ab85c27b7d6cb7571b97c98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gae9ec377e9ab85c27b7d6cb7571b97c98">util::type_traits</a> = std::bool_constant&lt; Value &gt;</td></tr>
<tr class="separator:gae9ec377e9ab85c27b7d6cb7571b97c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4f01d734224cf596f7e619a1b7d093b3">util::is_not_same</a> = std::negation&lt; std::is_same&lt; A, B &gt;&gt;</td></tr>
<tr class="memdesc:ga4f01d734224cf596f7e619a1b7d093b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negation of <code>std::is_same</code>.  <a href="#ga4f01d734224cf596f7e619a1b7d093b3">More...</a><br/></td></tr>
<tr class="separator:ga4f01d734224cf596f7e619a1b7d093b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08165b3442ddda786a178ce2823ef668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga08165b3442ddda786a178ce2823ef668"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668">util::find_type</a> = find_next_type&lt; T, 0U, Types...&gt;</td></tr>
<tr class="memdesc:ga08165b3442ddda786a178ce2823ef668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait: index of the first occurrence of <code>T</code> among the specified <code>Types</code>.  <a href="#ga08165b3442ddda786a178ce2823ef668">More...</a><br/></td></tr>
<tr class="separator:ga08165b3442ddda786a178ce2823ef668"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7dcc69829d516683281c361980940922"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ga7dcc69829d516683281c361980940922"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922">util::always_false_v</a> = false</td></tr>
<tr class="memdesc:ga7dcc69829d516683281c361980940922"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated constant, always false.  <a href="#ga7dcc69829d516683281c361980940922">More...</a><br/></td></tr>
<tr class="separator:ga7dcc69829d516683281c361980940922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4d0dfc8abee84fd9607cf5fc251412d8">util::always_true_v</a> = <a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#af8bc618309fb2d0f55f7f5ae0760b466">true</a></td></tr>
<tr class="memdesc:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template constant always true.  <a href="#ga4d0dfc8abee84fd9607cf5fc251412d8">More...</a><br/></td></tr>
<tr class="separator:ga4d0dfc8abee84fd9607cf5fc251412d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t StartFrom, typename... Types&gt; </td></tr>
<tr class="memitem:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga07ab55a3a8bc171ede71bf7aac7528be">util::find_next_type_v</a> = find_next_type&lt;T, StartFrom, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:ga07ab55a3a8bc171ede71bf7aac7528be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccd6e233deec6493f880ceefe42ecca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gaaccd6e233deec6493f880ceefe42ecca"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaaccd6e233deec6493f880ceefe42ecca">util::find_type_v</a> = find_type&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="separator:gaaccd6e233deec6493f880ceefe42ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c1cae81194565fb7be9409851d661a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga1c1cae81194565fb7be9409851d661a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga1c1cae81194565fb7be9409851d661a5">util::is_any_of_v</a> = is_any_of&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td></tr>
<tr class="memdesc:ga1c1cae81194565fb7be9409851d661a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <code>T</code> is among the specified <code>Types</code> (see <code><a class="el" href="../../d7/d95/structutil_1_1is__any__of.html" title="Trait: whether T is among the specified Types. ">util::is_any_of</a></code>).  <a href="#ga1c1cae81194565fb7be9409851d661a5">More...</a><br/></td></tr>
<tr class="separator:ga1c1cae81194565fb7be9409851d661a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gace903934bdebaf7027a4a0c3e4fb974f">util::is_same_decay_v</a> = std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</td></tr>
<tr class="memdesc:gace903934bdebaf7027a4a0c3e4fb974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <code>T</code> and <code>U</code> are the same type, after being applied <code>std::decay</code>.  <a href="#gace903934bdebaf7027a4a0c3e4fb974f">More...</a><br/></td></tr>
<tr class="separator:gace903934bdebaf7027a4a0c3e4fb974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">util::staticDumpClassName</a> ()</td></tr>
<tr class="memdesc:ga7399688afb3116ea838d6b2ae1015cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine the type of a variable at compilation time.  <a href="#ga7399688afb3116ea838d6b2ae1015cd6">More...</a><br/></td></tr>
<tr class="separator:ga7399688afb3116ea838d6b2ae1015cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga8815c7b8fe5d503b3f10d45ee197ba34">util::staticDumpClassName</a> (T)</td></tr>
<tr class="separator:ga8815c7b8fe5d503b3f10d45ee197ba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaa3ef7a171041e419c0e85ce62bd866a9">util::count_type_in_list</a> = details::count_type_in_list_impl&lt; Target, T...&gt;</td></tr>
<tr class="memdesc:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many of the types in <code>T</code> exactly match <code>Target</code>.  <a href="#gaa3ef7a171041e419c0e85ce62bd866a9">More...</a><br/></td></tr>
<tr class="separator:gaa3ef7a171041e419c0e85ce62bd866a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename... T&gt; </td></tr>
<tr class="memitem:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga429c66f884b21f2b6b22c37e8a2769ec">util::typelist_element_type</a> = std::tuple_element&lt; <a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, std::tuple&lt; T...&gt;&gt;</td></tr>
<tr class="memdesc:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>N</code> type of the type list.  <a href="#ga429c66f884b21f2b6b22c37e8a2769ec">More...</a><br/></td></tr>
<tr class="separator:ga429c66f884b21f2b6b22c37e8a2769ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876132317188329a32c1f27018f408e8"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename... T&gt; </td></tr>
<tr class="memitem:ga876132317188329a32c1f27018f408e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga876132317188329a32c1f27018f408e8">util::typelist_element_t</a> = typename typelist_element_type&lt; <a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, T...&gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td></tr>
<tr class="memdesc:ga876132317188329a32c1f27018f408e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>typelist_element_type</code>.  <a href="#ga876132317188329a32c1f27018f408e8">More...</a><br/></td></tr>
<tr class="separator:ga876132317188329a32c1f27018f408e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga830eb5fc4da7eae3e964208f6da0b1ea">util::type_is_in</a> = details::type_is_in_impl&lt; Target, T...&gt;</td></tr>
<tr class="memdesc:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds whether the <code>Target</code> type is among the ones in the <code>T</code> pack.  <a href="#ga830eb5fc4da7eae3e964208f6da0b1ea">More...</a><br/></td></tr>
<tr class="separator:ga830eb5fc4da7eae3e964208f6da0b1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad333eee614fb8d78d61393c5a4271f3d"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:gad333eee614fb8d78d61393c5a4271f3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gad333eee614fb8d78d61393c5a4271f3d">util::count_type_in_list_v</a> = count_type_in_list&lt;Target, T...&gt;()</td></tr>
<tr class="memdesc:gad333eee614fb8d78d61393c5a4271f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>count_type_in_list</code>.  <a href="#gad333eee614fb8d78d61393c5a4271f3d">More...</a><br/></td></tr>
<tr class="separator:gad333eee614fb8d78d61393c5a4271f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename... T&gt; </td></tr>
<tr class="memitem:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4ecd3b0bc852eef6da2a9e0615ab987f">util::type_is_in_v</a> = type_is_in&lt;Target, T...&gt;()</td></tr>
<tr class="memdesc:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the value in <code>type_is_in</code>.  <a href="#ga4ecd3b0bc852eef6da2a9e0615ab987f">More...</a><br/></td></tr>
<tr class="separator:ga4ecd3b0bc852eef6da2a9e0615ab987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Simple traits for the implementation of other traits. </p>
<p>Class triggering a <code>static_assert</code> failure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type accompanying the assertion </td></tr>
    <tr><td class="paramname">Enable</td><td>assertion will fail only if <code>Enable</code> expands to <code>true</code></td></tr>
  </table>
  </dd>
</dl>
<p>Instantiating this class anywhere (where it's legit) will trigger a static assertion failure. Since the error message emitted by the compiler usually contains an expansion of the template parameters, it is then possible to see the "value" of type <code>T</code> that was used when the assertion failed. The argument <code>Enable</code> allows to tune when the assertion should fail.</p>
<p>For the following example, we want to investigate the value of the type <code>element_type</code>, which is provided, among others, by <code>std::unique_ptr</code>. We want to find out the exact type <code>element_type</code> of the collection type passed to <code><a class="el" href="../../dd/df5/structOurClass.html">OurClass</a></code>, but only when the collection type is, say, not constant: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Coll&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="../../dd/df5/structOurClass.html">OurClass</a> {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> Collection_t = Coll;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Collection_t::element_type;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// DEBUG: have the compiler print `value_type`</span></div>
<div class="line">  <a class="code" href="../../d9/d67/structlar_1_1debug_1_1static__assert__on.html">lar::debug::static_assert_on</a></div>
<div class="line">    &lt;value_type, std::is_const_v&lt;std::remove_reference_t&lt;Coll&gt;&gt;&gt;</div>
<div class="line">    debugVar;</div>
<div class="line"></div>
<div class="line">}; <span class="comment">// struct OurClass</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// this should never trigger a static assertion failure:</span></div>
<div class="line"><a class="code" href="../../dd/df5/structOurClass.html">OurClass&lt;std::unique_ptr&lt;double&gt;</a>&gt; doubleData;</div>
<div class="line"></div>
<div class="line"><span class="comment">// this triggers a static assertion failure:</span></div>
<div class="line"><a class="code" href="../../dd/df5/structOurClass.html">OurClass&lt;std::unique_ptr&lt;double[4]&gt;</a> <span class="keyword">const</span> fourVectorData;</div>
</div><!-- fragment --><p> (a working example is provided in <code>DebugUtils_test.h</code>). The output with GCC 7.2 is similar to the following: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ In file included from <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:17:0: larcorealg/larcorealg/CoreUtils/DebugUtils.h: In instantiation of ‘struct lar::debug::details::THE_TYPE_IS&lt;int [10]&gt;’: larcorealg/larcorealg/CoreUtils/DebugUtils.h:476:29: required from ‘struct lar::debug::static_assert_on&lt;int [10], true&gt;’ <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:49:5: required from ‘struct <a class="el" href="../../dd/df5/structOurClass.html">OurClass</a>&lt;const std::unique_ptr&lt;int [10]&gt; &gt;’ <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:61:51: required from here larcorealg/larcorealg/CoreUtils/DebugUtils.h:467:7: error: static assertion failed: static_assert_on&lt;T&gt;: check the error message ("THE_TYPE_IS&lt;&gt;") for expansion of type <code>T</code>. static_assert(<a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922" title="A templated constant, always false. ">util::always_false_v&lt;T&gt;</a>, ^~~~~~~~~~~~~ </p>
<div class="fragment"><div class="line">The <a class="code" href="../../de/dfd/icarus__ci__nucosmics__gen__quick__test__icaruscode_8fcl.html#a0e9d37a779f44bf5c7815e454d524235">message</a> of <a class="code" href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a09c6b60bb7451f9136e25140ffdff6bd">the</a> assertion points to <a class="code" href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a09c6b60bb7451f9136e25140ffdff6bd">the</a> key <a class="code" href="../../dc/df0/namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">string</a> (<span class="stringliteral">&quot;THE_TYPE_IS&quot;</span>), <a class="code" href="../../d9/dd2/selectors_8fcl.html#aadc113fa4af9aeff01481eed2a98e7cc">and</a></div>
<div class="line">it can be seen <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a> <a class="code" href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a09c6b60bb7451f9136e25140ffdff6bd">the</a> <a class="code" href="../../d1/d33/detectorproperties__icarus_8fcl.html#acfd440223f806c44323dbd1053b99123">second</a> line of <span class="keyword">this</span> excerpt that <a class="code" href="../../de/ddc/generate__icarus__geometry__splitwire_8pl.html#a09c6b60bb7451f9136e25140ffdff6bd">the</a> <a class="code" href="../../d5/df9/find__global__symbol_8sh.html#a7ffd29742ae15e2201e70eed8b83ffe6">information</a> is</div>
<div class="line">printed as `<span class="keyword">struct </span><a class="code" href="../../de/d85/structlar_1_1debug_1_1details_1_1THE__TYPE__IS.html">lar::debug::details::THE_TYPE_IS</a>&lt;int [10]&gt;`.</div>
<div class="line">This is Clang 5.0:</div>
</div><!-- fragment --><p> In file included from <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:17: larcorealg/larcorealg/CoreUtils/DebugUtils.h:451:7: error: static_assert failed "static_assert_on&lt;T&gt;: check the error message (\"THE_TYPE_IS&lt;&gt;") for expansion of type `T`." static_assert(<a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922" title="A templated constant, always false. ">util::always_false_v&lt;T&gt;</a>, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ larcorealg/larcorealg/CoreUtils/DebugUtils.h:460:29: note: in instantiation of template class 'lar::debug::details::THE_TYPE_IS&lt;int [10]&gt;' requested here details::THE_TYPE_IS&lt;T&gt; _; ^ <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:49:5: note: in instantiation of template class 'lar::debug::static_assert_on&lt;int [10], true&gt;' requested here debugVar; ^ <a class="el" href="../../d0/d5c/DebugUtils__test_8cc.html" title="Unit test for some of the utilities in DebugUtils.h. ">larcorealg/test/CoreUtils/DebugUtils_test.cc</a>:61:10: note: in instantiation of template class '<a class="el" href="../../dd/df5/structOurClass.html">OurClass</a>&lt;const std::__1::unique_ptr&lt;int [10], std::__1::default_delete&lt;int [10]&gt; &gt; &gt;' requested here (void) <a class="el" href="../../dd/df5/structOurClass.html">OurClass</a>&lt;std::unique_ptr&lt;int[10]&gt; const&gt;(); ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ where the type can be read in the message of the first note. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa3ef7a171041e419c0e85ce62bd866a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gaa3ef7a171041e419c0e85ce62bd866a9">util::count_type_in_list</a> = typedef details::count_type_in_list_impl&lt;Target, T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns how many of the types in <code>T</code> exactly match <code>Target</code>. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00107">107</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga08165b3442ddda786a178ce2823ef668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668">util::find_type</a> = typedef find_next_type&lt;T, 0U, Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait: index of the first occurrence of <code>T</code> among the specified <code>Types</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of check the presence of </td></tr>
    <tr><td class="paramname">Types</td><td>the possible types <code>T</code> can match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d9/d02/structutil_1_1find__next__type.html" title="Trait: index of the first occurrence of T among the specified Types, starting from the one with index...">util::find_next_type</a></code></dd></dl>
<p>The value of the trait is the index of <code>T</code> within the specified list of <code>Types</code> (first type as index <code>0</code>). The match is exact, as in <code>std::is_same</code>. If none of the <code>Types</code> exactly matches <code>T</code>, the trait value will be the number of types (i.e. <code>sizeof...(Types)</code>), which is the index after the last of the types.</p>
<p>This is a integral trait (type <code>std::size_t</code>): use it as <code>std::integer_constant</code>. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00232">232</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f01d734224cf596f7e619a1b7d093b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4f01d734224cf596f7e619a1b7d093b3">util::is_not_same</a> = typedef std::negation&lt;std::is_same&lt;A, B&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The negation of <code>std::is_same</code>. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00183">183</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad92e74901a6fa461ce0ccbd97c445928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gad92e74901a6fa461ce0ccbd97c445928">util::self_t</a> = typedef typename self_type&lt;T&gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The very same type as in the template argument. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00068">68</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga830eb5fc4da7eae3e964208f6da0b1ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga830eb5fc4da7eae3e964208f6da0b1ea">util::type_is_in</a> = typedef details::type_is_in_impl&lt;Target, T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds whether the <code>Target</code> type is among the ones in the <code>T</code> pack. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00125">125</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae9ec377e9ab85c27b7d6cb7571b97c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::negation&lt; BoolTrait &gt; <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#gae9ec377e9ab85c27b7d6cb7571b97c98">util::type_traits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00174">174</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga876132317188329a32c1f27018f408e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga876132317188329a32c1f27018f408e8">util::typelist_element_t</a> = typedef typename typelist_element_type&lt;<a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, T...&gt;::<a class="el" href="../../d9/da0/structtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>typelist_element_type</code>. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00120">120</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga429c66f884b21f2b6b22c37e8a2769ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga429c66f884b21f2b6b22c37e8a2769ec">util::typelist_element_type</a> = typedef std::tuple_element&lt;<a class="el" href="../../d7/ded/prova__source_8fcl.html#ab58e1ede8542ac672a1c146fb3870f2e">N</a>, std::tuple&lt;T...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>N</code> type of the type list. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00116">116</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7399688afb3116ea838d6b2ae1015cd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::staticDumpClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to determine the type of a variable at compilation time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to be investigated</td></tr>
  </table>
  </dd>
</dl>
<p>It may be difficult to understand which type is being used in a failing static assertion or in some complicate metaprogramming code (is there any other kind?), especially when due to a compilation failure the code can't be run. This class is supposed to help by forcing the compiler to a halt, and it is devised so that the compiler should print in the error message what it thinks the type <code>T</code> is.</p>
<p>An example of usage: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/d7f/MetaUtils_8h.html">larcorealg/CoreUtils/MetaUtils.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  constexpr <span class="keyword">auto</span> v = 5U - 6U; <span class="comment">// which type is `v` of?</span></div>
<div class="line">  <a class="code" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">util::staticDumpClassName</a>(v);</div>
<div class="line">}</div>
</div><!-- fragment --><p> For example, Clang 5.0.1 emits these errors: </p>
<div class="fragment"><div class="line">In <a class="code" href="../../d0/dea/file__to__url_8sh.html#a79854d43ae87cec96a59d17fc4141bf0">file</a> included <a class="code" href="../../dd/db0/testFHiCLfiles_8sh.html#a6401d1c0a168bb3757821ca209161fe2">from</a> metatest.cpp:1:</div>
<div class="line">./MetaUtils.h:217:7: <a class="code" href="../../d8/d79/namespacetest__msg.html#a79cb67e67dd7c11ad227880f7bd5625a">error</a>: static_assert failed <span class="stringliteral">&quot;ClassNameStaticDumper&lt;T&gt;: look for T in the error message context&quot;</span></div>
<div class="line">      static_assert(</div>
<div class="line">      ^</div>
<div class="line">./MetaUtils.h:228:39: note: <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a> instantiation of <span class="keyword">template</span> <span class="keyword">class</span> <span class="stringliteral">&#39;util::details::ClassNameStaticDumper&lt;unsigned int&gt;&#39;</span> requested here</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">staticDumpClassName</a>() { (<a class="code" href="../../dc/df0/namespacenlohmann_1_1detail.html#a59fca69799f6b9e366710cb9043aa77d">void</a>) details::ClassNameStaticDumper&lt;T&gt;(); }</div>
<div class="line">                                      ^</div>
<div class="line">./MetaUtils.h:195:46: note: <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a> instantiation of <span class="keyword">function</span> <span class="keyword">template</span> specialization <span class="stringliteral">&#39;util::staticDumpClassName&lt;unsigned int&gt;&#39;</span> requested here</div>
<div class="line">  [[noreturn]] <span class="keywordtype">void</span> <a class="code" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">staticDumpClassName</a>(T) { staticDumpClassName&lt;T&gt;(); }</div>
<div class="line">                                             ^</div>
<div class="line">metatest.cpp:5:16: note: <a class="code" href="../../d2/df7/quiet__Math__Functor__test_8sh.html#adfac98fbd1e85554d2cf0454cdcbc717">in</a> instantiation of <span class="keyword">function</span> <span class="keyword">template</span> specialization <span class="stringliteral">&#39;util::staticDumpClassName&lt;unsigned int&gt;&#39;</span> requested here</div>
<div class="line">  (<span class="keywordtype">void</span>) util::<a class="code" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6">staticDumpClassName</a>(v);</div>
<div class="line">               ^</div>
<div class="line">1 <a class="code" href="../../d8/d79/namespacetest__msg.html#a79cb67e67dd7c11ad227880f7bd5625a">error</a> generated.</div>
</div><!-- fragment --><p> From the first "note" we can see that the type of <code>v</code> is <code>unsigned int</code>. Note that if <code>v</code> is not copiable, an additional error will be emitted. To avoid that, the type can be specified as template parameter, as in <code><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6" title="Helper to determine the type of a variable at compilation time. ">util::staticDumpClassName</a>&lt;decltype(v)&gt;()</code>. The same program is processed by GNU GCC with an error message: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ In file included from metatest.cpp:1:0: MetaUtils.h: In instantiation of ‘struct util::details::ClassNameStaticDumper&lt;unsigned int&gt;’: MetaUtils.h:248:48: required from ‘void <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7399688afb3116ea838d6b2ae1015cd6" title="Helper to determine the type of a variable at compilation time. ">util::staticDumpClassName()</a> [with T = unsigned int]’ MetaUtils.h:215:68: required from ‘void <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga8815c7b8fe5d503b3f10d45ee197ba34">util::staticDumpClassName(T)</a> [with T = unsigned int]’ metatest.cpp:5:30: required from here MetaUtils.h:237:7: error: static assertion failed: ClassNameStaticDumper&lt;T&gt;: look for T in the error message context static_assert( ^~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ where the type is mentioned in all the three context lines. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00986">986</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;{ (<a class="code" href="../../dc/df0/namespacenlohmann_1_1detail.html#a59fca69799f6b9e366710cb9043aa77d">void</a>) details::ClassNameStaticDumper&lt;T&gt;(); }</div>
<div class="ttc" id="namespacenlohmann_1_1detail_html_a59fca69799f6b9e366710cb9043aa77d"><div class="ttname"><a href="../../dc/df0/namespacenlohmann_1_1detail.html#a59fca69799f6b9e366710cb9043aa77d">nlohmann::detail::void</a></div><div class="ttdeci">j template void())</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/db8/json_8hpp_source.html#l03108">json.hpp:3108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga8815c7b8fe5d503b3f10d45ee197ba34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::staticDumpClassName </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00327">327</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;{ staticDumpClassName&lt;T&gt;(); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7dcc69829d516683281c361980940922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::always_false_v = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A templated constant, always false. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../da/d94/structutil_1_1always__false__type.html" title="A std::false_type with a template argument. ">util::always_false_type</a>, <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga4d0dfc8abee84fd9607cf5fc251412d8" title="A template constant always true. ">util::always_true_v</a></dd></dl>
<p>This constant allows a <code>static_assert</code> to fail only when the template type it's in is being instantiated: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>MandatoryCustomizationPoint {</div>
<div class="line">  static_assert(util::always_false_v&lt;T&gt;, <span class="stringliteral">&quot;You have to specialize!&quot;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>MandatoryCustomizationPoint&lt;<a class="code" href="../../da/dc9/namespacepmtana.html#a9860e62c78db1dd9c7d635a2832b883a">std</a>::<a class="code" href="../../db/dfa/namespacelar_1_1dump.html#a71d4403edbac4d265176f8677118194f">vector</a>&lt;T&gt;&gt; {</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="../../d9/da0/structtype.html">type</a> = <span class="keyword">typename</span> std::vector&lt;T&gt;::reference;</div>
<div class="line">};</div>
</div><!-- fragment --><p> In this example, using <code>std::false_type</code> might have tipped the compiler to trigger the assertion failure even if the class is not instantiated. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00119">119</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d0dfc8abee84fd9607cf5fc251412d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::always_true_v = <a class="el" href="../../de/d36/crtt0matchingalg__sbnd_8fcl.html#af8bc618309fb2d0f55f7f5ae0760b466">true</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template constant always true. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d4/dd1/structutil_1_1always__true__type.html" title="A std::true_type with a template argument. ">util::always_true_type</a>, <a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga7dcc69829d516683281c361980940922" title="A templated constant, always false. ">util::always_false_v</a></dd></dl>
<p>This is one way to allow to specialize for classes with a certain type: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">class </span>ReferenceTypeExtractor {</div>
<div class="line">  static_assert(util::always_false_v&lt;T&gt;, <span class="stringliteral">&quot;Type has no reference!&quot;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Cont&gt;</div>
<div class="line"><span class="keyword">struct </span>ReferenceTypeExtractor</div>
<div class="line">  &lt;Cont, <a class="code" href="../../da/dc9/namespacepmtana.html#a9860e62c78db1dd9c7d635a2832b883a">std</a>::<a class="code" href="../../dc/df0/namespacenlohmann_1_1detail.html#a02bcbc878bee413f25b985ada771aa9c">enable_if_t</a>&lt;util::always_true_v&lt;typename Cont::value_type&gt;&gt;&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="../../d9/da0/structtype.html">type</a> = <span class="keyword">typename</span> Cont::reference;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00168">168</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad333eee614fb8d78d61393c5a4271f3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int util::count_type_in_list_v = count_type_in_list&lt;Target, T...&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>count_type_in_list</code>. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00112">112</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga07ab55a3a8bc171ede71bf7aac7528be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t StartFrom, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t util::find_next_type_v = find_next_type&lt;T, StartFrom, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00211">211</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaccd6e233deec6493f880ceefe42ecca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t util::find_type_v = find_type&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of the first occurrence of <code>T</code> among the specified <code>Types</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><code><a class="el" href="../../d0/dcf/group__MetaprogrammingBase.html#ga08165b3442ddda786a178ce2823ef668" title="Trait: index of the first occurrence of T among the specified Types. ">util::find_type</a></code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00238">238</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c1cae81194565fb7be9409851d661a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::is_any_of_v = is_any_of&lt;T, Types...&gt;::<a class="el" href="../../da/d36/pmtsimulation__icarus_8fcl.html#a9fc569190f32b40862f18ac3c03a8e49">value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether <code>T</code> is among the specified <code>Types</code> (see <code><a class="el" href="../../d7/d95/structutil_1_1is__any__of.html" title="Trait: whether T is among the specified Types. ">util::is_any_of</a></code>). </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00256">256</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gace903934bdebaf7027a4a0c3e4fb974f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::is_same_decay_v = std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether <code>T</code> and <code>U</code> are the same type, after being applied <code>std::decay</code>. </p>

<p>Definition at line <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html#l00263">263</a> of file <a class="el" href="../../d4/d7f/MetaUtils_8h_source.html">MetaUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ecd3b0bc852eef6da2a9e0615ab987f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::type_is_in_v = type_is_in&lt;Target, T...&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct access to the value in <code>type_is_in</code>. </p>

<p>Definition at line <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html#l00129">129</a> of file <a class="el" href="../../d3/ddc/TupleLookupByTag_8h_source.html">TupleLookupByTag.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
